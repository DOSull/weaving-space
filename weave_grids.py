#!/usr/bin/env python
# coding: utf-8

from calendar import c
from dataclasses import dataclass
# from itertools import chain
# import logging

import numpy as np

from shapely.affinity import translate
from shapely.affinity import rotate
from shapely.affinity import scale
from shapely.geometry import Polygon
from shapely.geometry import MultiPolygon
from shapely.ops import unary_union
from shapely.wkt import dumps
from shapely.wkt import loads
# import geopandas


# Class to encapsulate the generation of square or triangular
# 'sites' or cells where strands intersect in a weave
@dataclass
class _WeaveGrid:
  basis: np.ndarray
  orientations: tuple[float]
  grid_cell: Polygon = None
  n_axes: int = 2
  spacing: float = 10000
  precision: int = 1
  
  def __init__(self, n_axes, orientations, spacing = 10000, precision = 1):
    self.n_axes = n_axes
    self.orientations = orientations
    self.spacing = spacing
    self.basis = self.setup_basis()
    self.precision = precision
    self.grid_cell = self._make_grid_cell()
      
  def setup_basis(self):
    if self.n_axes == 2:
      angles = (np.pi / 2, 0)
      dx = [self.spacing * np.cos(a) for a in angles]
      dy = [self.spacing * np.sin(a) for a in angles]
    elif self.n_axes == 3:
      angles = [np.pi / 6 * x for x in range(3, 12, 4)]
      dx = [self.spacing * 2 / 3 * np.cos(a) for a in angles]
      dy = [self.spacing * 2 / 3 * np.sin(a) for a in angles]
    return np.array(dx + dy).reshape(2, self.n_axes)
      
  def get_coordinates(self, coords):
    return self.basis @ coords
      
  # Returns a grid cell centred at (0, 0) with  number of sides 
  # requested. One side of polygon will lie horizontal below the 
  # x-axis symmetric about the y-axis. This means radii to corners 
  # of the polygon are arranged either
  #
  # n even:      or, n odd:
  #   \  /            |
  # ___\/___       ___|___
  #    /\            / \
  #   /  \          /   \
  # 
  # face to face distance of the polygon from base edge vertically 
  # to the opposite face (or if n is odd to he opposite corner) 
  # is either:
  # n even: L = 2Rcos(pi/n), or
  # n odd:  L = R + Rcos(pi/n)
  # where R is the radius of the circumcircle
  #
  # Polygon is generated by finding the n points equally spaced
  # on this circumcircle
  def get_grid_cell_at(self, coords = None):
    if coords is None:
      coords = tuple([0] * self.n_axes)
    if self.grid_cell is None:
      polygon = self.make_grid_cell()
    else:
      polygon = self.grid_cell
    xy = self.get_coordinates(coords)
    polygon = translate(polygon, xy[0], xy[1])
    if self.n_axes == 2 or sum(coords) %2 == 0:
      return self._gridify(polygon)
    else:
      return self._gridify(rotate(polygon, 180, origin = polygon.centroid))
      
  def _make_grid_cell(self):
    n_sides = 4 if self.n_axes == 2 else 3
    if n_sides == 4:
      R = self.spacing / (2 * np.cos(np.pi / n_sides))
    else:
      R = self.spacing / (1 + np.cos(np.pi / n_sides))
    # determine angles
    # we start at 6 o'clock (3pi/2), then add (pi/n), then add n more 2pi/n steps
    angles = [3 * np.pi / 2 + np.pi / n_sides + 
              i / n_sides * 2 * np.pi for i in range(n_sides)]
    corners = [(R * np.cos(a), R * np.sin(a)) for a in angles]
    return Polygon(corners)

  def _gridify(self, shape):
    return loads(dumps(shape, rounding_precision = self.precision))
      
  # Returns 'slices' across grid cell (i.e. horizontally) centered vertically
  # relative to the cell, ie
  #
  #            /\
  #           /  \
  #   +------------------+
  #   |     /      \     |
  #   +------------------+
  #   |   /          \   |
  #   +------------------+
  #     /              \
  #    /________________\
  #
  # Horizontal extent is spacing, total width of the strips is W, they are
  # 'sliced' horizontally in n_equal slices. An offset should be provided to
  # center the slices vertically on the vertical extent of the cell (not its)
  # centroid
  def _get_grid_cell_slices(self, L = 0, W = 1, n_slices = 1, offset = (0, 0)):
    L = self.spacing if L == 0 else L
    ribbon_w = self.spacing * W
    slice_w = ribbon_w / n_slices
    odd_numbers = [x for x in range(1, 2 * n_slices, 2)]
    slice_offsets = [slice_w * o / 2 - ribbon_w / 2 for o in odd_numbers] # -0.2 
    slices = []
    for o in slice_offsets:
      slice = Polygon([(0, 0), (L, 0), (L, slice_w), (0, slice_w)])
      slice = translate(slice, -L / 2, -slice_w / 2)
      slice = translate(slice, 0, o)
      slice = translate(slice, offset[0], offset[1])
      slices.append(self._gridify(slice))
    return slices

  # Gets the cross grid cell strands running across a cell in the x direction
  # optionally rotated by orientation for a grid cell spacing S, total strand
  # width width (as a fraction of S), sliced into n_slices along its length
  def _get_cell_strands(self, width = 1, coords = None, 
                        orientation = 0, n_slices = 1):
    cell = self.get_grid_cell_at(coords)
    cell_offset = cell.envelope.centroid.coords[0]
    sf = 2 - width if self.n_axes == 2 else (5 - 3 * width) / 2
    expanded_cell = scale(cell, sf, sf, origin = cell.centroid)
    big_l = sf * self.spacing if self.n_axes == 2 \
      else sf * self.spacing * 2 / np.sqrt(3) * (3 - width) / 2
    strands = MultiPolygon(
      self._get_grid_cell_slices(big_l, width, n_slices))
    strands = translate(strands, cell_offset[0], cell_offset[1])
    strands = MultiPolygon([expanded_cell.intersection(s) for s in strands.geoms])
    strands = self._gridify(rotate(strands, orientation, origin = cell.centroid))
    return strands.geoms


  # Returns the visible parts of the strands in a grid, given the spacing S
  # strand width width, parity (for the triangular case), a vector of strand
  # orders and matching vectors of orientations and the desired number of slices
  def get_visible_cell_strands(self, width = 1, coords = None, 
                               strand_order = None, n_slices = None):
    if strand_order is None:
      strand_order = tuple([i for i in range(self.n_axes)])
    if n_slices is None:
      n_slices = tuple([1] * self.n_axes)
    all_polys = []
    for order in strand_order:
      next_polys = self._get_cell_strands(width, coords, 
                                          self.orientations[order], 
                                          n_slices[order])
      if all_polys == []:
        all_polys.extend(next_polys)
        mask = unary_union(next_polys)
      else:
        all_polys.extend([p.difference(mask) for p in next_polys])
        mask = mask.union(unary_union(next_polys))
    return all_polys

