#!/usr/bin/env python
# coding: utf-8

from itertools import chain

import numpy as np

from shapely.affinity import translate
from shapely.affinity import rotate
from shapely.geometry import Polygon
from shapely.geometry import MultiPolygon
from shapely.ops import unary_union
from shapely.wkt import dumps
from shapely.wkt import loads
import geopandas


# hacky workaround to fix precision of a shape
# hopefully in shapely 2.0 this won't be needed
def gridify(shape, digits = 1):
  return loads(dumps(shape, rounding_precision = digits))


def apply_precision(x, p):
  return np.round(x * p) / p


# Returns a function that will generate the x-y coordinates for
# a supplied set of integer coordinates in a particular 'space'
# n_axes = 2 is a Cartesian grid with spacing S and reverse x-y order
# n_axes = 3 is a Nagy triangular grid with spacing S, and axes in
# vertical, down 120 SW and down 120 SE directions
# See: Nagy, B. N. 2003. Shortest Paths in Triangular Grids with
#      Neighbourhood Sequences. Journal of Computing and Information
#      Technology 11 (2):111.
def grid_generator(n_axes = 2, spacing = 1):
  if n_axes == 2:
    angles = (np.pi / 2, 0)
    dx = [spacing * np.cos(a) for a in angles]
    dy = [spacing * np.sin(a) for a in angles]
  elif n_axes == 3:
    angles = [np.pi / 6 * x for x in range(3, 12, 4)]
    dx = [spacing * 2 / 3 * np.cos(a) for a in angles]
    dy = [spacing * 2 / 3 * np.sin(a) for a in angles]
  basis = np.array(dx + dy).reshape(2, n_axes)
  
  def convert(coords):
    return basis @ coords
  
  return convert


# wrappers for shapely transforms to help with refactor into python
def rotate_shape(shape, angle, centre = (0, 0)):
  return rotate(shape, angle, origin = centre)


def translate_shape(shape, dxdy = (0, 0)):
  return translate(shape, dxdy[0], dxdy[1])


# Returns a grid cell polygon centred at (0, 0) with
# the number of sides requested. One side of the polygon
# will lie horizontal below the x-axis symmetric about the
# y-axis. This means that radii to the corners of the polygon
# are arranged as either
#
# n even:      or, n odd:
#   \  /            |
# ___\/___       ___|___
#    /\            / \
#   /  \          /   \
# The parameter L is the face to face distance of the polygon from
# the base edge vertically to the opposite face (or if n is odd to
# the opposite corner). This means L is either:
# n even: L = 2Rcos(pi/n), or
# n odd:  L = R + Rcos(pi/n)
# where R is the radius of the circumcircle
#
# The polygon is generated by finding the n points equally spaced
# on this circumcircle
def get_grid_cell_polygon(face_to_face_distance = 1, n_sides = 4, parity = 0):
  if n_sides % 2 == 0:
    R = face_to_face_distance / (2 * np.cos(np.pi / n_sides))
  else:
    R = face_to_face_distance / (1 + np.cos(np.pi / n_sides))
  # determine angles
  # we start at 6 o'clock (3pi/2), then add (pi/n), then add n more 2pi/n steps
  angles = [3 * np.pi / 2 + np.pi / n_sides + 
                i / n_sides * 2 * np.pi for i in range(n_sides)]
  corners = [(R * np.cos(a), R * np.sin(a)) for a in angles]
  polygon = Polygon(corners)
  if n_sides == 4 or parity % 2 == 1:
    return polygon
  else:
    return rotate(polygon, 180, (0, 0))


# Returns 'slices' across a grid cell (i.e. horizontally) centered vertically
# relative to the cell, ie
#
#            /\
#           /  \
#   +------------------+
#   |     /      \     |
#   +------------------+
#   |   /          \   |
#   +------------------+
#     /              \
#    /________________\
#
# Horizontal extent is given by L, total width of the strips is W, they are
# 'sliced' horizontally in n_equal slices. An offset should be provided to
# center the slices vertically on the vertical extent of the cell (not its)
# centroid. This is supplied from get_cell_strands()
def get_grid_cell_slices(L = 1, W = 1, n_slices = 1, offset = (0, 0)):
  sW = W / n_slices
  odd_numbers = [x for x in range(1, 2 * n_slices, 2)]
  slice_offsets = [sW * o / 2 - W / 2 for o in odd_numbers]
  slices = []
  for o in slice_offsets:
    slice = Polygon([(0, 0), (L, 0), (L, sW), (0, sW)])
    slice = translate(slice, -L / 2, -sW / 2)
    slice = translate(slice, 0, o)
    slice = translate(slice, offset[0], offset[1])
    slices.append(slice)
  return slices


# Gets the cross grid cell strands running across a cell in the x direction
# optionally rotated by orientation for a grid cell spacing S, total strand
# width width (as a fraction of S), sliced into n_slices along its length
def get_cell_strands(n = 4, S = 1, width = 1, parity = 0, 
                      orientation = 0, n_slices = 1):
  slice_w = width * S
  # make expanded cell that reaches to the strands in neighbours
  big_s = S + S * (1 - width) if n == 4 else S * (5 - 3 * width) / 2
  expanded_cell = get_grid_cell_polygon(big_s, n, parity)
  strand_offset = expanded_cell.envelope.centroid.coords[0]
  cell = get_grid_cell_polygon(S, n, parity)
  cell_offset = cell.envelope.centroid.coords[0]
  big_l = big_s if n == 4 else big_s * 2 / np.sqrt(3) * (3 - width) / 2
  strands = MultiPolygon(get_grid_cell_slices(big_l, slice_w, n_slices, strand_offset))
  strands = translate(strands, -strand_offset[0], -strand_offset[1])
  strands = translate(strands, cell_offset[0], cell_offset[1])
  strands = MultiPolygon([expanded_cell.intersection(s) for s in strands.geoms])
  strands = gridify(rotate(strands, orientation, (0, 0)), 1)
  return strands.geoms


# Essentially a wrapper for get_cell_strands that returns the strands in all
# the requested cross directions
def get_all_cell_strands(n = 4, S = 1, width = 1, parity = 0, 
                          orientations = (0, -90), n_slices = (1, 1)):
  polys = []
  for o, ns in zip(orientations, n_slices):
    next_polys = get_cell_strands(n, S, width, parity, o, ns)
    polys.extend(next_polys)
  return polys  


# Returns the visible parts of the strands in a grid, given the spacing S
# strand width width, parity (for the triangular case), a vector of strand
# orders and matching vectors of orientations and the desired number of slices
def get_visible_cell_strands(
      n = 4, S = 1, width = 1, parity = 0, strand_order = (0, 1), 
      orientations = (0, -90), n_slices = (1, 1)):

  all_polys = []
  for i, order in enumerate(strand_order):
    next_polys = get_cell_strands(n, S, width, parity, 
                                  orientations[order], n_slices[order])
    if i == 0:
      all_polys.extend(next_polys)
      mask = unary_union(next_polys)
    else:
      all_polys.extend([p.difference(mask) for p in next_polys])
      mask = mask.union(unary_union(next_polys))
  return all_polys  


def centre_offset(shape, centre = (0, 0)):
  shape_c = shape.envelope.centroid.coords[0]
  return (centre[0] - shape_c[0], centre[1] - shape_c[1])


# builds the sf associate with a given weave supplied as 'loom' which is a list
# containing the coordinates in an appropriate grid (Cartesian or triangular)
# and the orderings of the strands at each coordinate location
def make_shapes_from_coded_weave_matrix(
      loom, spacing = 1, width = 1, margin = 0,
      axis1_threads = "a", axis2_threads = "b", axis3_threads = "c", crs = 3857):
  
  n_sides = 4 if loom.n_axes == 2 else 3
  gg = grid_generator(n_axes = loom.n_axes, spacing = spacing)
  ids1 = axis1_threads * (loom.dimensions[0] // len(axis1_threads))
  ids2 = axis2_threads * (loom.dimensions[1] // len(axis2_threads))
  if loom.n_axes == 3:
    ids3 = axis3_threads * (loom.dimensions[2] // len(axis3_threads))
  parity = 1
  weave_polys = []
  bb_polys = []
  strands = []
  for coords, strand_order in zip(loom.indices, loom.orderings):
    ids = [ids1[coords[0]], ids2[coords[1]]]
    if loom.n_axes == 3:
      ids.append(ids3[coords[2]])
      parity = (sum(coords) - loom.parity) % 2
    xy = gg(coords)
    cell = gridify(
            translate(
            get_grid_cell_polygon(spacing, n_sides, parity), xy[0], xy[1]), 1)
    bb_polys.append(cell)
    # print(f"strand_order: {strand_order} ids: {ids}")
    if strand_order is None: continue
    if strand_order == "NA":
      weave_polys.append(cell)
      strands.append("NA")
      continue
    n_slices = [len(id) for id in ids]
    next_polys = [translate(p, xy[0], xy[1]) for p in 
                  get_visible_cell_strands(n_sides, spacing, width, 
                            parity, strand_order, loom.orientations, n_slices)]
    weave_polys.extend(next_polys)
    labels = [list(ids[i]) for i in strand_order] # a list of lists
    labels = list(chain(*labels))                 # flatten list of lists
    # print(f"n: {len(next_polys)} labels: {labels}")
    strands.extend(labels)
  tile = unary_union(bb_polys)
  shift = centre_offset(tile)
  tile = translate(tile, shift[0], shift[1])
  return { 
    "weave_unit": make_weave_gdf(weave_polys, strands, tile, shift, margin, crs),
    "tile": geopandas.GeoDataFrame(geometry = geopandas.GeoSeries([tile])).set_crs(crs) 
    }


def make_weave_gdf(polys, strand_ids, bb, offset, margin, crs):
  weave = geopandas.GeoDataFrame(
    data = { "strand": strand_ids },
    # geometry = geopandas.GeoSeries(polys)
    geometry = geopandas.GeoSeries([translate(p, offset[0], offset[1]) for p in polys])
  )
  weave = weave[weave.strand != "-"]
  weave = weave.dissolve(by = "strand", as_index = False)
  weave.geometry = weave.buffer(-margin)
  return weave.clip(bb).set_crs(crs)


