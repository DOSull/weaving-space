#!/usr/bin/env python
# coding: utf-8

from types import new_class
import numpy as np
from dataclasses import dataclass

from shapely.affinity import translate
from shapely.affinity import rotate
from shapely.geometry import Polygon
from shapely.geometry import MultiPolygon

def apply_precision(x, p):
  return np.round(x * p) / p


bi_to_tri = [
    {1: 1, 2:2, 3:None, 4:(1,2), 5:(2,1)},
    {1: 2, 2:1, 3:None, 4:(2,1), 5:(1,2)},
    {1: 3, 2:2, 3:None, 4:(3,2), 5:(2,3)},
    {1: 1, 2:3, 3:None, 4:(1,3), 5:(3,1)}
]
def decode_biaxial_to_order(code, axis = 0):
    return bi_to_tri[axis][code]


@dataclass
class Loom:
  indices: list[tuple]
  orderings: list
  parity: int
  dimensions: tuple
  orientations: tuple
  
  def __init__(self, matrices):
    m = matrices[0]
    self.indices = [(i, j) for i in range(m.shape[0]) \
                           for j in range(m.shape[1])]
    self.orderings = [decode_biaxial_to_order(m[ij]) for ij in self.indices]
    self.parity = None
    self.orientations = (0, -90)
    self.dimensions = m.shape


# Returns a function that will generate the x-y coordinates for
# a supplied set of integer coordinates in a particular 'space'
# n_axes = 2 is a Cartesian grid with spacing S and reverse x-y order
# n_axes = 3 is a Nagy triangular grid with spacing S, and axes in
# vertical, down 120 SW and down 120 SE directions
# See: Nagy, B. N. 2003. Shortest Paths in Triangular Grids with
#      Neighbourhood Sequences. Journal of Computing and Information
#      Technology 11 (2):111.
def grid_generator(n_axes = 2, spacing = 1):
  if n_axes == 2:
    angles = (np.pi / 2, 0)
    dx = [spacing * np.cos(a) for a in angles]
    dy = [spacing * np.sin(a) for a in angles]
  elif n_axes == 3:
    angles = [np.pi / 6 * x for x in range(3, 12, 4)]
    dx = [spacing * 2 / 3 * np.cos(a) for a in angles]
    dy = [spacing * 2 / 3 * np.sin(a) for a in angles]
  basis = np.array(dx + dy).reshape(n_axes, 2)
  
  def convert(coords):
    return basis @ coords
  
  return convert


# wrappers for shapely transforms to help with refactor into python
def rotate_shape(shape, angle, centre = (0, 0)):
  return rotate(shape, angle, origin = centre)


def translate_shape(shape, dxdy = (0, 0)):
  return translate(shape, dxdy[0], dxdy[1])


# Returns a grid cell polygon centred at (0, 0) with
# the number of sides requested. One side of the polygon
# will lie horizontal below the x-axis symmetric about the
# y-axis. This means that radii to the corners of the polygon
# are arranged as either
#
# n even:      or, n odd:
#   \  /            |
# ___\/___       ___|___
#    /\            / \
#   /  \          /   \
# The parameter L is the face to face distance of the polygon from
# the base edge vertically to the opposite face (or if n is odd to
# the opposite corner). This means L is either:
# n even: L = 2Rcos(pi/n), or
# n odd:  L = R + Rcos(pi/n)
# where R is the radius of the circumcircle
#
# The polygon is generated by finding the n points equally spaced
# on this circumcircle
def get_grid_cell_polygon(face_to_face_distance = 1, n_sides = 4, parity = 0):
  if n_sides % 2 == 0:
    R = face_to_face_distance / (2 * np.cos(np.pi / n_sides))
  else:
    R = face_to_face_distance / (1 + np.cos(np.pi / n_sides))
  # determine angles
  # we start at 6 o'clock (3pi/2), then add (pi/n), then add n more 2pi/n steps
  angles = [3 * np.pi / 2 + np.pi / n_sides + 
                i / n_sides * 2 * np.pi for i in range(n_sides)]
  corners = [(R * np.cos(a), R * np.sin(a)) for a in angles]
  polygon = Polygon(corners)
  if n_sides == 4 or parity % 2 == 1:
    return polygon
  else:
    return rotate(polygon, 180, (0, 0))


# Returns 'slices' across a grid cell (i.e. horizontally) centered vertically
# relative to the cell, ie
#
#            /\
#           /  \
#   +------------------+
#   |     /      \     |
#   +------------------+
#   |   /          \   |
#   +------------------+
#     /              \
#    /________________\
#
# Horizontal extent is given by L, total width of the strips is W, they are
# 'sliced' horizontally in n_equal slices. An offset should be provided to
# center the slices vertically on the vertical extent of the cell (not its)
# centroid. This is supplied from get_cell_strands()
def get_grid_cell_slices(L = 1, W = 1, n_slices = 1, offset = (0, 0)):
  sW = W / n_slices
  odd_numbers = [x for x in range(1, 2 * n_slices, 2)]
  slice_offsets = [sW * o / 2 - W / 2 for o in odd_numbers]
  slices = []
  for o in slice_offsets:
    slice = Polygon([(0, 0), (L, 0), (L, sW), (0, sW)])
    slice = translate(slice, -L / 2, -sW / 2)
    slice = translate(slice, 0, o)
    slice = translate(slice, offset[0], offset[1])
    slices.append(slice)
  return slices


# Gets the cross grid cell strands running across a cell in the x direction
# optionally rotated by orientation for a grid cell spacing S, total strand
# width width (as a fraction of S), sliced into n_slices along its length
def get_cell_strands(n = 4, S = 1, width = 1, parity = 0, 
                      orientation = 0, n_slices = 1):
  slice_w = width * S
  # make expanded cell that reaches to the strands in neighbours
  big_s = S + S * (1 - width) if n == 4 else S * (5 - 3 * width) / 2
  expanded_cell = get_grid_cell_polygon(big_s, n, parity)
  strand_offset = expanded_cell.envelope.centroid.coords[0]
  cell = get_grid_cell_polygon(S, n, parity)
  cell_offset = cell.envelope.centroid.coords[0]
  big_l = big_s if n == 4 else big_s * 2 / np.sqrt(3) * (3 - width) / 2
  strands = MultiPolygon(get_grid_cell_slices(big_l, slice_w, n_slices, strand_offset))
  strands = translate(strands, -strand_offset[0], -strand_offset[1])
  strands = translate(strands, cell_offset[0], cell_offset[1])
  strands = MultiPolygon([expanded_cell.intersection(s) for s in strands.geoms])
  strands = rotate(strands, orientation, (0, 0))
  return strands.geoms


# get_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
#                              orientation = 0, n_slices = 1) {
#   W <- width * S
#   # make expanded cell that reaches to the strands in neighbours 
#   big_s <- ifelse(n == 4, 
#                   S + S * (1 - width), 
#                   S * (5 - 3 * width) / 2)
#   expanded_cell <- get_grid_cell_polygon(face_to_face_distance = big_s, 
#                                          n = n, parity = parity)
#   bb <- st_bbox(expanded_cell)
#   strand_offset <- c(bb$xmin + bb$xmax, bb$ymin + bb$ymax) / 2
#   cell <- get_grid_cell_polygon(face_to_face_distance = S,
#                                 n = n, parity = parity)
#   # determine its x-y centre (which may not be where its centroid is)
#   bb <- st_bbox(cell)
#   cell_offset <- c(bb$xmin + bb$xmax, bb$ymin + bb$ymax) / 2
#   big_l <- ifelse(n == 4, big_s, 
#                   big_s * 2 / sqrt(3) * (3 - width) / 2)
#   get_grid_cell_slices(L = big_l, W = W, n_slices = n_slices, 
#                        offset = strand_offset) %>%
#     lapply(translate_shape, dxdy = -strand_offset + cell_offset) %>%
#     st_sfc() %>% #precision = gPRECISION) %>% 
#     st_intersection(expanded_cell) %>%
#     lapply(rotate_shape, angle = orientation) %>%
#     st_sfc() #precision = gPRECISION)
# }



# Essentially a wrapper for get_cell_strands that returns the strands in all
# the requested cross directions
def get_all_cell_strands(n = 4, S = 1, width = 1, parity = 0, 
                          orientations = (0, -90), n_slices = (1, 1)):
  polys = []
  for o, ns in zip(orientations, n_slices):
    next_polys = get_cell_strands(n, S, width, parity, o, ns)
    polys.extend(next_polys)
  return polys  

# get_all_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
#                                  orientations = c(0, 90),
#                                  n_slices = rep(1, length(orientations))) {
#   polys <- list()
#   for (i in seq_along(orientations)) {
#     next_strands <- get_cell_strands(n = n, S = S, width = width,
#                                      parity = parity,
#                                      orientation = orientations[i],
#                                      n_slices = n_slices[i])
#     polys <- add_shapes_to_list(polys, next_strands)
#   }
#   polys %>% st_sfc() #precision = gPRECISION)
# }

