```{r}
library(dplyr)
library(sf)
library(pracma)
library(tmap)

source("weave-grids.R")
source("biaxial-weave-units.R")
```

# Very very very much a work in progress...
## Using `weave-grids.R` to make weave drawings
The approach is to make a grid generator, then a set of coordinates, then apply positional offsets from the coordinates returned by the generator to the base cell strands.

For a triangular grid only coordinate combinations that sum to two consecutive values exist, and the parity of the sum determines the facing (up or down) of the triangular cell.


```{r}
trigrid <- grid_generator(n_axes = 3)
```

## Conversion of biaxial strand coordinates to triaxial
The biaxial pattern between each pair of layers A+B, B+C, C+A, produces a n x m matrix
of warp/weft 1/0 values.

Each single value at a row-column position in each of these matrices has to be assigned to two positions in an output _triangular_ grid.

```{r}
transform_ab_to_abc <- function(i, j, parity = 0, axis = 1) {
  ac <- switch(axis, i, c(parity + 1 - i - j, parity - i -j), j)
  bc <- switch(axis, j, i, c(parity + 1 - i - j, parity - i -j))
  cc <- switch(axis, c(parity + 1 - i - j, parity - i -j), j, i)
  result <- switch(
    axis,
    matrix(c(ac, bc, cc[1], ac, bc, cc[2]), nrow = 2, ncol = 3, byrow = TRUE),
    matrix(c(ac[1], bc, cc, ac[2], bc, cc), nrow = 2, ncol = 3, byrow = TRUE),
    matrix(c(ac, bc[1], cc, ac, bc[2], cc), nrow = 2, ncol = 3, byrow = TRUE))
  return(result)
}
```


Now to try to do the triaxial weave with matrices...

```{r}
# three tie-up matrices - no idea if these are right
tu_AB <- diag(3) %>% repmat(2)
tu_BC <- diag(3) %>% repmat(2)
tu_CA <- diag(3) %>% repmat(2)

th <- diag(6)
tr <- diag(6)
```

```{r}
# thread patterns, these are coded 1 for a thread, -1 for missing
weft <- matrix(c(1, 1, 1), 3, 3) %>% repmat(2)
warp <- t(weft)

AB_A <- warp
AB_B <- weft * 2
BC_B <- warp * 2 
BC_C <- weft * 3
CA_C <- warp * 3
CA_A <- weft

# for example
AB_A
```

```{r}
# three weave-patterns 1 for the warp on top 0 for the weft
pat_AB <- (((tr %*% tu_AB %*% th) > 0) * 1) 
pat_BC <- (((tr %*% tu_BC %*% th) > 0) * 1)
pat_CA <- (((tr %*% tu_CA %*% th) > 0) * 1)

pat_AB
```


```{r}
add_biaxial_to_triaxial <- function(tri, M, axis = 1, parity = 0) {
  for (col in 1:ncol(M)) {
    for (row in 1:nrow(M)) {
      abc <- transform_ab_to_abc(col, row, parity = parity, axis = axis)
      for (par in 1:2) {
        key <- abc[par, ] %>% str_c(collapse = ",")
        if (is.null(tri[[key]])) { # && axis == 1) {
          tri[[key]] <- c(M[row, col])
        } else {
          tri[[key]] <- c(tri[[key]], M[row, col] )
        }
      }
    }
  }
  return(tri)
}
```

```{r}
pat_to_order <- function(x) {
  # if (sum(x) == 3 || sum(x) == 0) {return(NA)}
  if (x[1] == 1) {
    if (x[2] == 1) { return(1:3) }          # 110 -> ABC
    else {
      if (x[3] == 0) { return(c(1, 3, 2)) } # 100 -> ACB
      else { return(c(3, 1, 2)) }           # 101 -> CAB
    }
  }
  if (x[2] == 1) {
    if (x[3] == 1) { return(c(2, 3, 1)) }   # 011 -> BCA
    else { return(c(2, 1, 3)) }             # 010 -> BAC
  }
  return(3:1)                               # 001 -> CBA
}
```


```{r}
loom <- list() %>%
  add_biaxial_to_triaxial(pat_AB, axis = 1, parity = 10) %>% 
  add_biaxial_to_triaxial(pat_BC, axis = 2, parity = 10) %>% 
  add_biaxial_to_triaxial(pat_CA, axis = 3, parity = 10)
loom <- loom[which(lengths(loom) == 3)]
loom <- lapply(loom, pat_to_order)
loom <- loom[which(!is.na(loom))]
```


```{r}
weave <- list()
colours <- c()
for (key in names(loom)) {
  coords <- str_split(key, ",")[[1]] %>% as.numeric()
  xy <- trigrid(coords)
  permutation <- loom[[key]] %>% rev()
  o <- ifelse(sum(coords) %% 2 == 0, 180, 0) + (permutation - 1) * 120
  weave <- append(weave, 
                  list(get_all_cell_strands(n = 3, width = 0.75, orientations = o) + xy))
  colours <- c(colours, permutation)
}
tris <- weave %>% sapply("[") %>% 
  c() %>% st_sfc()

weave <- st_sf(data.frame(colours = as.factor(colours)), geometry = tris)

weave %>% plot(border = NA)
```





