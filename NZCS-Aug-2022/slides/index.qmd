---
title: Tiled & woven thematic maps
author: David O'Sullivan & Luke R Bergmann
format: 
  revealjs:
    theme: [beige, custom.scss]
    transition: fade
    transition-speed: slow
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: true
    slide-number: true
    logo: images/logo.png
    footer: "GeoCart 2022 - Tiled & woven maps - O'Sullivan & Bergmann"
jupyter: python3
---

```{python}
import sys
sys.path.append("../..") # so I can find weavingspace

import os
os.chdir("/home/osullid3/Documents/code/weaving-space")

import matplotlib.pyplot as pyplot
import geopandas as gpd

from shapely.geometry import Polygon
from shapely.affinity import rotate

from weavingspace import TileUnit
from weavingspace import TileShape  
from weavingspace import WeaveUnit
from weavingspace import Tiling
```

# Multivariate maps {.smaller background-image="images/detailed-weave.png" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
Some background to the problem.

## But first... where we are headed
Two new kinds of thematic map for handling complex multivariate data associated with polygons.

We've [developed python code](https://github.com/DOSull/weaving-space) that helps you make tiled and woven maps.

::: aside
Many of the maps we show are of Dan Exeter's index of multiple deprivation (IMD). See: Exeter DJ, Zhao J, Crengle S, Lee A, Browne M, 2017, [The New Zealand Indices of Multiple Deprivation (IMD): A new suite of indicators for social and health research in Aotearoa, New Zealand](https://dx.plos.org/10.1371/journal.pone.0181260) _PLOS ONE_ **12**(8) e0181260
:::


```{python}
ak = gpd.read_file("data/imd-auckland-2018.gpkg")
vars = [v for v in ak.columns if "Rank" in v][:4]
variables = dict(zip(list("abcd"), vars))
colourmaps = dict(zip(variables.values(), 4 * ["viridis"]))
```

## {transition="slide-in none-out"}

```{python}
tile_unit = TileUnit(tiling_type = "laves", code = "4.8.8",
                      crs = ak.crs, spacing = 500)

tiling = Tiling(tile_unit, ak, id_var = "DZ2018")

fig = tiling.get_tiled_map(prioritise_tiles = True) \
  .render(variables = variables, colourmaps = colourmaps,
          legend = False, figsize = (10, 7))
```

## {transition="none-in slide-out"}

```{python}
tile_unit = WeaveUnit(weave_type = "twill", strands = "ab|cd",
                      aspect = 0.75, crs = ak.crs, spacing = 250)
tile_unit = tile_unit.inset_elements(5)
tile_unit = tile_unit.transform_rotate(45)
tiling = Tiling(tile_unit, ak, id_var = "DZ2018")

fig = tiling.get_tiled_map(prioritise_tiles = True) \
  .render(variables = variables, colourmaps = colourmaps,
          legend = False, figsize = (10, 7))
```

## Some other approaches
This is a perennially challenging problem, so many different ways of tackling it have been attempted...

A little more context for these was provided in [our earlier talk](https://dosull.github.io/weaving-space/NZCS-Nov-2021/make-weave-map.html).

##

::: {.r-stack}
![](images/small-multiples.png "Tufte recommends this approach"){.fragment .fade-out fragment-index=1 width="800"}

![](images/bivariate-choropleth-stevens-qgis.png "2-colours, OK"){.fragment .fade-in-then-out fragment-index=1 width="800"}

![](images/tricolore.png "3-colours, brown"){.fragment .fade-in-then-out fragment-index=2 width="800"}

![](images/choropleth-with-symbols-qgis.png "Probably the most conventional option"){.fragment .fade-in-then-out fragment-index=3 width="800"}

![](images/dorling-chernoff-faces.jpg "Probably the least conventional option"){.fragment .fade-in-then-out fragment-index=4 width="500"}

![](images/dot-map.png "This approach is older than you might imagine, see Jenks GF, 1953, “‘Pointilism’ as a cartographic technique” The Professional Geographer 5(5) 4–6
"){.fragment .fade-in fragment-index=5 width="800"}
:::


# Tiling theory {.smaller background-image="images/mosaic-south-america.jpg" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}

Mosaic world map by Chris Chamberlain; see [this article](https://mymodernmet.com/chris-chamberlain-jewel-of-the-universe/) and 
[this video](https://www.youtube.com/watch?v=bgcc3w0-9X0) for more.


## A _plane tiling_ is...

> "... a countable family of closed sets $\mathcal{T}=\{T_1,T_2,\ldots\}$ which covers the plane without gaps or overlaps. More explicitly, the union of the sets $T_1,T_2,\ldots$ (which are known as the *tiles* of $\mathcal{T}$) is to be the whole plane, and the interiors of the sets $T_i$ are to be pairwise disjoint" (Grünbaum and Shephard 1987, page 16)

. . . 

... a GIS coverage!

::: aside
Grünbaum B, Shephard GC, 1987 _Tilings and Patterns_ (WH Freeman and Company, New York)
:::

## How many tilings?
It's a lot. 

Systematic enumeration up to a certain complexity yields a ‘galaxy’ of 2.4 billion tilings (Zeller et al. 2021). You can explore the galaxy here: [_Tegula_](https://github.com/husonlab/tegula).

Grünbaum and Shephard repeatedly narrow focus to tilings with specific properties so they can say anything at all.

::: aside
Zeller R, Delgado-Friedrichs O, Huson DH, 2021, “[_Tegula_ – exploring a galaxy of two-dimensional periodic tilings](https://doi.org/10.1016/j.cagd.2021.102027)” _Computer Aided Geometric Design_ **90** 102027
:::

## Symmetry in mathematical tiling
The symmetries of a tiling map tiles on to other tiles. 

The sets of tiles related to one another in this way are the *transitivity groups* of the tiling. 

An *isohedral* tiling has only one transitivity group.

```{python}
fig, ax = pyplot.subplots(1, 3, figsize = (12, 4))

tilings = [
  TileUnit(tiling_type = "cairo") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"],

  TileUnit(tiling_type = "archimedean", code = "4.8.8") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"],  

  WeaveUnit(weave_type = "plain", strands = "(abc)|(def)") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"]
]

for a, t, n in zip(ax, tilings, ("iso", "2-", "2-")):
  t.plot(ax = a, fc = "#00000040", ec = "w", lw = 0.5) \
    .set_axis_off()
  a.set_title(f"{n}hedral") 
```


## Symmetry in cartographic tiling
:::: {.columns}

::: {.column width="60%" style="font-size:72%;"}
*Directionality* or *orientation* is irrelevant to mathematicians because they consider tiles and tilings identical under rotation. 

However, they *are* important for mapping. Many isohedral tilings contain directionally distinguishable tiles.

We likely need a new cartographic notion of the transitivity groups where different tile orientations ‘count’ as different.
:::

::: {.column width="40%"}
```{python}
arrow_tile = TileUnit()
d = arrow_tile.spacing
arrow1 = Polygon([(-3*d/4, -d/4), (-d/4,-d/4), (-d/4,-d/2), 
                  (d/4,0), (-d/4,d/2), (-d/4,d/4), (-3*d/4,d/4)])
arrow2 = rotate(arrow1, 180, origin = (0, -d/4))
arrow_tile.elements = gpd.GeoDataFrame(
    data = {"element_id" : list("ab")}, crs = 2193,
    geometry = gpd.GeoSeries([arrow1, arrow2]))

arrow_tile = arrow_tile.transform_scale(4/3, 3/4)
arrow_tile = arrow_tile.transform_skew(30)
arrow_tile = arrow_tile.transform_rotate(-15)

arrow_tile.plot(show_vectors = True, show_ids = False,
                figsize = (6, 6)).set_axis_off()
```
:::
::::


::: aside
Olson RK, Attneave F, 1970, “[What Variables Produce Similarity Grouping?](https://doi.org/10.2307/1420852)” _The American Journal of Psychology_ **83**(1) 1
:::

## What we learned from tiling theory

. . .

::: {.r-fit-text}
¯&#92;&#95;(ツ)&#95;&#47;¯
:::

. . .

We are not entirely sure... <span class="fragment">yet!</span> 


# Tile units {.smaller background-image="images/wooden-diamond-triangle-tiling-toy.jpg" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
The building blocks of our approach.

## The basic pattern
```{python}
#| echo: true
#| output-location: fragment
#| code-line-numbers: "1|2-3"
cairo_tile = TileUnit(tiling_type = "cairo")
cairo_tile.plot(r = 1, show_vectors = True, 
                figsize = (7, 7)).set_axis_off()
```

## Triangles, squares, hexagons
```{python}
#| echo: true
triangles = TileUnit(tile_shape = TileShape.TRIANGLE)
squares = TileUnit() 
hexagons = TileUnit(tile_shape = TileShape.HEXAGON)
```
```{python}
fig = pyplot.figure(figsize = (12, 4))
for u, posn in zip((triangles, squares, hexagons), range(131, 134)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_vectors = True).set_axis_off()
```

## Archimedean tilings by regular polygons
```{python}
units = [
  TileUnit(tiling_type = "archimedean", code = "3.3.4.3.4"),
  TileUnit(tiling_type = "archimedean", code = "3.3.3.3.6"),
  TileUnit(tiling_type = "archimedean", code = "3.4.6.4"),
  TileUnit(tiling_type = "archimedean", code = "3.6.3.6"),
  TileUnit(tiling_type = "archimedean", code = "4.6.12"),
  TileUnit(tiling_type = "archimedean", code = "4.8.8")
]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## Laves (the Archimedean duals)
```{python}
units = [
  TileUnit(tiling_type = "laves", code = "3.3.3.3.6"),
  TileUnit(tiling_type = "laves", code = "3.4.6.4"),
  TileUnit(tiling_type = "laves", code = "3.6.3.6"),
  TileUnit(tiling_type = "laves", code = "3.12.12"),
  TileUnit(tiling_type = "laves", code = "4.6.12"),
  TileUnit(tiling_type = "laves", code = "4.8.8")
]
laves2 = units[1]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## Hexagon dissections and colourings
```{python}
units = [
  TileUnit(tiling_type = "hex-dissection", n = 2),
  TileUnit(tiling_type = "hex-dissection", n = 3, dissection_offset = 1),
  TileUnit(tiling_type = "hex-dissection", n = 12, dissection_offset = 1),
  TileUnit(tiling_type = "hex-colouring", n = 3),
  TileUnit(tiling_type = "hex-colouring", n = 4),
  TileUnit(tiling_type = "hex-colouring", n = 7)
]
hexc3 = units[3]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## In general
These (and more) are all available with the same command:

```{python} 
#| echo: true
#| eval: false
tile = TileUnit(
  tiling_type = "cairo|archimedean|laves|hex-dissection|square-dissection",
  n = ..., code = "3.3.4.3.4", dissection_offset = 0|1,  # optional
  spacing = 500, crs = 2193
)
```

We can then make various adjustments:

```{python} 
#| echo: true
#| eval: false
tile = tile.transform_rotate(...)
tile = tile.transform_scale(...)
tile = tile.transform_skew(...)
tile = tile.inset_tile(...)
tile = tile.inset_elements(...)
tile = tile.scale_elements(...)
```

## 'Insetting'
Insetting relative to the repeating tile unit helps distinguish elements.
```{python}
laves2 = laves2.inset_tile(25).transform_rotate(15)
hexc3 = hexc3.inset_tile(25)
cairo_tile = cairo_tile.inset_tile(25).transform_rotate(-45)
fig = pyplot.figure(figsize = (12, 4))
ax = fig.add_subplot(131)
laves2.plot(ax = ax, r = 1, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
ax = fig.add_subplot(132)
hexc3.plot(ax = ax, r = 1, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
ax = fig.add_subplot(133)
cairo_tile.plot(ax = ax, r = 2, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
```

# Weaving {.smaller background-image="images/weave-pic-2.jpg" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
For a lot more on woven maps, see [our earlier talk](https://dosull.github.io/weaving-space/NZCS-Nov-2021/make-weave-map.html).

## Some weaving theory
Weaving theory leads to useful matrix-based approaches.

Primarily for *biaxial weaves*.

We (eventually) figured out how to extend the matrix approach to *triaxial* weaves (see [our notes](https://dosull.github.io/weaving-space/code-junkyard/three-way-matrices.html)).

:::aside
This video by Lea Albaugh provided a nice way into the topic: 

["It's Just Matrix Multiplication": Notation for Weaving](https://www.youtube.com/watch?v=oMOSiag3dxg), presented at the Strange Loop conference, St Louis, 27-28 Sept, 2018. 

And this paper spells out the details: 

Glassner A. 2002. [_Digital weaving 1_](https://dx.doi.org/10.1109/MCG.2002.1046635). IEEE Computer Graphics and Applications **22**(6):108–118.
:::

## Weave units
We make these the same way we make tile units.

```{python}
#| echo: true
#| code-line-numbers: "2,5"
w1 = WeaveUnit(weave_type = "twill", n = 3, aspect = .9, 
               strands = "ab-|cde-")

w2 = WeaveUnit(weave_type = "cube", aspect = .8, 
               strands = "a-c|d-f|g-i")
```

The `strands` parameter specifies which strands in each axis separated by the `"|"` are distinct, and also allows us to 'skip' strands on `"-"` characters  .

##

```{python}
fig, ax = pyplot.subplots(1, 2, figsize = (15, 9))
for a, w in zip(ax, (w1, w2)):
  w.plot(ax = a, show_ids = False).set_axis_off()
  a.set_title(f'strands = "{w.strands}"')
```


# Making maps {.smaller background-image="images/vermeer-the-geographer.jpg" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
Vermeer's _The Geographer_ (&bsim;1675) from [commons.wikimedia.org](https://commons.wikimedia.org/wiki/File:Johannes_Vermeer_-_The_Geographer_-_WGA24687.jpg).

```{python}
region = gpd.read_file("/home/osullid3/Documents/code/weaving-space/data/imd-auckland-2018.gpkg")

cairo_tile.crs = region.crs
cairo_tile = cairo_tile.transform_scale(0.5, 0.5)
```

## Tiling a dataset
Making a tiled map, `TileUnit` and `WeaveUnit` objects are both `Tileable` objects and can be treated the same.

We make a `Tiling` object from one of these and a polygon dataset to be tiled. 

```{python}
#| echo: true
tiling = Tiling(cairo_tile, region, id_var = "DZ2018")
```

## The tiling process
The `Tiling` generates a `TileGrid` which governs a process of copying, translating and dissolving the tileable units into a tiled or woven map.

![](images/the-tiling-process.png)

## Making a tiled map
Next, make a `TiledMap` by calling the `get_tiled_map()` method of the `Tiling`.

```{python}
#| echo: true
tiled_map = tiling.get_tiled_map(prioritise_tiles = True)
```

Here we can choose to emphasize tile boundaries, or zone boundaries in the dataset using the  `prioritise_tiles` setting.

## Designing the final map
We then have to specify the mapping from tileable unit identifiers (`"a"`, `"b"`, `"c"` ...) to data variable names.

```{python}
#| echo: true
tiled_map.variables = dict(a = "Rank_Emplo", b = "Rank_Incom", 
                           c = "Rank_Crime", d = "Rank_Housi")
```

We also specify the mapping from variable names to preferred colour palettes. 

```{python}
#| echo: true
tiled_map.colourmaps = dict(zip(tiled_map.variables.values(),
                                ("Reds", "Blues", "Greens", "Greys")))
```

Now we are ready to render a map.

##
```{python}
#| echo: true
#| output-location: slide
fig = tiled_map.render(use_ellipse = True, figsize = (12, 6),
                       legend_dx = -0.05, legend_dy = 0.05)
```

There a range of options here particularly in relation to the tricky business of generating a legend.

# Some more examples {.smaller background-image="images/imd-escher-clip.png" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
Because we can...

##

::: {.r-stack}

![](images/imd-weave.png){.fragment .fade-out fragment-index=1 width="950"}

![](images/imd-arrows.png){.fragment .fade-in-then-out fragment-index=1 width="950"}

![](images/imd-escher.png){.fragment .fade-in-then-out fragment-index=2 width="950"}

![](images/gwr-example.png){.fragment .fade-in-then-out fragment-index=3 width="950"}

![](images/election-2016-weave.png){.fragment .fade-in fragment-index=4 width="900"}
:::


# Further work {.smaller background-image="images/chevron-fabric.jpg" background-opacity=0.65 style="text-shadow: 2px 2px 5px #ffc, -2px -2px 5px #ffc;"}
Image from [publicdomainpictures.net](https://www.publicdomainpictures.net/en/view-image.php?image=371246&picture=tejido-textil-con-estampado-de-chevon) by [Andrea Stöckel](https://www.publicdomainpictures.net/en/browse-author.php?a=149229)


##
This work is an exploration of pattern, orientation, texture, and colour as visual variables. We invite collaboration! 

The code used to make this talk is available at [github.com/DOSull/weaving-space](https://github.com/DOSull/weaving-space).

We're close to finalizing a release, and are keen to get feedback, contributions, and ideas, especially:

+ Actual use of the approach
+ QGIS plugin development

If you have a project that might benefit from our approach, please reach out!

## {style="text-align:center;"}
### Questions? {.r-fit-text} 
[github.com/DOSull/weaving-space](https://github.com/DOSull/weaving-space)

