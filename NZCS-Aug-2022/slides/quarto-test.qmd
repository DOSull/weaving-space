---
title: "Tiled & woven thematic maps"
author: David O'Sullivan & Luke Bergmann
format: 
  revealjs:
    theme: [beige, custom.scss]
    transition: fade
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: true
    slide-number: true
    logo: images/logo.png
    footer: "GeoCart 2022 - Tiled & woven maps - O'Sullivan & Bergmann"
jupyter: python3
---

```{python}
import sys
sys.path.append("../..") # so I can find weavingspace

import os
os.chdir("/home/osullid3/Documents/code/weaving-space")

import matplotlib.pyplot as pyplot
import geopandas as gpd

from shapely.geometry import Polygon
from shapely.affinity import rotate

from weavingspace import TileUnit
from weavingspace import TileShape
from weavingspace import WeaveUnit
from weavingspace import Tiling
```

# Multivariate data mapping {background-image="images/detailed-weave.png" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}
Some background to the problem.

## But first... where we are headed
Two new kinds of thematic map for handling complex multivariate data associated with polygons.

We've [developed python code](https://github.com/DOSull/weaving-space) that helps you make tiled and woven maps.

::: aside
Many of the maps we show are of Dan Exeter's index of multiple deprivation (IMD). See: Exeter DJ, Zhao J, Crengle S, Lee A, Browne M, 2017, [The New Zealand Indices of Multiple Deprivation (IMD): A new suite of indicators for social and health research in Aotearoa, New Zealand](https://dx.plos.org/10.1371/journal.pone.0181260) _PLOS ONE_ **12**(8) e0181260
:::


```{python}
ak = gpd.read_file("data/imd-auckland-2018.gpkg")
vars = [v for v in ak.columns if "Rank" in v][:4]
variables = dict(zip(list("abcd"), vars))
colourmaps = dict(zip(variables.values(), 4 * ["viridis"]))
```

## {transition="slide-in none-out"}

```{python}
tile_unit = TileUnit(tiling_type = "laves", code = "4.8.8",
                      crs = ak.crs, spacing = 500)

tiling = Tiling(tile_unit, ak, id_var = "DZ2018")

fig = tiling.get_tiled_map(prioritise_tiles = True) \
  .render(variables = variables, colourmaps = colourmaps,
          legend = False, figsize = (10, 7))
```

## {transition="none-in slide-out"}

```{python}
tile_unit = WeaveUnit(weave_type = "twill", strands = "ab|cd",
                      aspect = 0.75, crs = ak.crs, spacing = 250)
tile_unit = tile_unit.inset_elements(5)
tile_unit = tile_unit.transform_rotate(45)
tiling = Tiling(tile_unit, ak, id_var = "DZ2018")

fig = tiling.get_tiled_map(prioritise_tiles = True) \
  .render(variables = variables, colourmaps = colourmaps,
          legend = False, figsize = (10, 7))
```

## Some other approaches
This is a perennially challenging problem, so many different ways of tackling it have been attempted...

A little more context for these was provided in [our earlier talk](https://dosull.github.io/weaving-space/NZCS-Nov-2021/make-weave-map.html).

##

::: {.r-stack}
![](images/small-multiples.png "Tufte recommends this approach"){.fragment .fade-out fragment-index=1 width="800"}

![](images/bivariate-choropleth-stevens-qgis.png "2-colours, OK"){.fragment .fade-in-then-out fragment-index=1 width="800"}

![](images/tricolore.png "3-colours, brown"){.fragment .fade-in-then-out fragment-index=2 width="800"}

![](images/choropleth-with-symbols-qgis.png "Probably the most conventional option"){.fragment .fade-in-then-out fragment-index=3 width="800"}

![](images/dorling-chernoff-faces.jpg "Probably the least conventional option"){.fragment .fade-in-then-out fragment-index=4 width="500"}

![](images/dot-map.png "This approach is older than you might imagine, see Jenks GF, 1953, “‘Pointilism’ as a cartographic technique” The Professional Geographer 5(5) 4–6
"){.fragment .fade-in fragment-index=5 width="800"}
:::


# Tiling theory {background-image="images/mosaic-south-america.jpg" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}

A mosaic map of the world by Chris Chamberlain; see [this article](https://mymodernmet.com/chris-chamberlain-jewel-of-the-universe/) and 
[this video](https://www.youtube.com/watch?v=bgcc3w0-9X0) for more.


## A _plane tiling_ is...

> "... a countable family of closed sets $\mathcal{T}=\{T_1,T_2,\ldots\}$ which covers the plane without gaps or overlaps. More explicitly, the union of the sets $T_1,T_2,\ldots$ (which are known as the *tiles* of $\mathcal{T}$) is to be the whole plane, and the interiors of the sets $T_i$ are to be pairwise disjoint" (Grünbaum and Shephard 1987, page 16)

. . . 

... a GIS coverage!

::: aside
Grünbaum B, Shephard GC, 1987 _Tilings and Patterns_ (WH Freeman and Company, New York)
:::

## How many tilings?
It's a lot. 

Systematic enumeration up to a certain complexity yields a ‘galaxy’ of 2.4 billion tilings (Zeller et al. 2021). You can explore the galaxy here: [_Tegula_](https://github.com/husonlab/tegula).

Grünbaum and Shephard repeatedly narrow focus to tilings with specific properties so they can say anything at all.

::: aside
Zeller R, Delgado-Friedrichs O, Huson DH, 2021, “[_Tegula_ – exploring a galaxy of two-dimensional periodic tilings](https://doi.org/10.1016/j.cagd.2021.102027)” _Computer Aided Geometric Design_ **90** 102027
:::

## Symmetry in mathematical tiling
The symmetries of a tiling map tiles on to other tiles. 

The sets of tiles related to one another in this way are the *transitivity groups* of the tiling. 

An *isohedral* tiling has only one transitivity group.

```{python}
fig, ax = pyplot.subplots(1, 3, figsize = (12, 4))

tilings = [
  TileUnit(tiling_type = "cairo") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"],

  TileUnit(tiling_type = "archimedean", code = "4.8.8") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"],  

  WeaveUnit(weave_type = "plain", strands = "(abc)|(def)") \
    .transform_rotate(45) \
    .get_local_patch(r = 2, include_0 = True)["geometry"]
]

for a, t, n in zip(ax, tilings, ("iso", "2-", "2-")):
  t.plot(ax = a, fc = "#00000040", ec = "w", lw = 0.5) \
    .set_axis_off()
  a.set_title(f"{n}hedral") 
```


## Symmetry in cartographic tiling
:::: {.columns}

::: {.column width="60%" style="font-size:75%;"}
*Directionality* or *orientation* is irrelevant to mathematicians because they consider tiles and tilings identical under rotation. 

However, they *are* important for mapping. Many isohedral tilings contain directionally distinguishable tiles.

We likely need a new cartographic notion of the transitivity groups where different tile orientations ‘count’ as different.
:::

::: {.column width="40%"}
```{python}
arrow_tile = TileUnit()
d = arrow_tile.spacing
arrow1 = Polygon([(-3*d/4, -d/4), (-d/4,-d/4), (-d/4,-d/2), 
                  (d/4,0), (-d/4,d/2), (-d/4,d/4), (-3*d/4,d/4)])
arrow2 = rotate(arrow1, 180, origin = (0, -d/4))
arrow_tile.elements = gpd.GeoDataFrame(
    data = {"element_id" : list("ab")}, crs = 2193,
    geometry = gpd.GeoSeries([arrow1, arrow2]))

arrow_tile = arrow_tile.transform_scale(4/3, 3/4)
arrow_tile = arrow_tile.transform_skew(30)
arrow_tile = arrow_tile.transform_rotate(-15)

arrow_tile.plot(show_vectors = True, show_ids = False,
                figsize = (6, 6)).set_axis_off()
```
:::
::::


::: aside
Olson RK, Attneave F, 1970, “[What Variables Produce Similarity Grouping?](https://doi.org/10.2307/1420852)” _The American Journal of Psychology_ **83**(1) 1
:::

## What we learned from tiling theory

. . .

::: {.r-fit-text}
¯&#92;&#95;(ツ)&#95;&#47;¯
:::

. . .

We are not entirely sure... <span class="fragment">yet!</span> 


# Tile units {background-image="images/wooden-diamond-triangle-tiling-toy.jpg" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}
The building blocks of our approach.

It may (not) surprise you to know I had a toy very much like this as a child...

## The basic pattern
```{python}
#| echo: true
#| output-location: fragment
#| code-line-numbers: "1|2-3"
cairo_tile = TileUnit(tiling_type = "cairo")
cairo_tile.plot(r = 1, show_vectors = True, 
                figsize = (7, 7)).set_axis_off()
```

## Triangles, squares, hexagons
```{python}
#| echo: true
triangles = TileUnit(tile_shape = TileShape.TRIANGLE)
squares = TileUnit() 
hexagons = TileUnit(tile_shape = TileShape.HEXAGON)
```
```{python}
fig = pyplot.figure(figsize = (12, 4))
for u, posn in zip((triangles, squares, hexagons), range(131, 134)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_vectors = True).set_axis_off()
```

## Archimedean tilings by regular polygons
```{python}
units = [
  TileUnit(tiling_type = "archimedean", code = "3.3.4.3.4"),
  TileUnit(tiling_type = "archimedean", code = "3.3.3.3.6"),
  TileUnit(tiling_type = "archimedean", code = "3.4.6.4"),
  TileUnit(tiling_type = "archimedean", code = "3.6.3.6"),
  TileUnit(tiling_type = "archimedean", code = "4.6.12"),
  TileUnit(tiling_type = "archimedean", code = "4.8.8")
]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## Laves (the Archimedean duals)
```{python}
units = [
  TileUnit(tiling_type = "laves", code = "3.3.3.3.6"),
  TileUnit(tiling_type = "laves", code = "3.4.6.4"),
  TileUnit(tiling_type = "laves", code = "3.6.3.6"),
  TileUnit(tiling_type = "laves", code = "3.12.12"),
  TileUnit(tiling_type = "laves", code = "4.6.12"),
  TileUnit(tiling_type = "laves", code = "4.8.8")
]
laves2 = units[1]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## Hexagon dissections and colourings
```{python}
units = [
  TileUnit(tiling_type = "hex-dissection", n = 2),
  TileUnit(tiling_type = "hex-dissection", n = 3, dissection_offset = 1),
  TileUnit(tiling_type = "hex-dissection", n = 12, dissection_offset = 1),
  TileUnit(tiling_type = "hex-colouring", n = 3),
  TileUnit(tiling_type = "hex-colouring", n = 4),
  TileUnit(tiling_type = "hex-colouring", n = 7)
]
hexc3 = units[3]
fig = pyplot.figure(figsize = (11, 7))
for u, posn in zip(units, range(231, 237)):
    ax = fig.add_subplot(posn)
    u.plot(ax = ax, r = 1, show_ids = False).set_axis_off()
```

## In general
These (and more) are all available with the same command:

```{python} 
#| echo: true
#| eval: false
tile = TileUnit(
  tiling_type = "cairo|archimedean|laves|hex-dissection|square-dissection",
  n = ..., code = "3.3.4.3.4", dissection_offset = 0|1,  # optional
  spacing = 500, crs = 2193
)
```

We can then make various adjustments:

```{python} 
#| echo: true
#| eval: false
tile = tile.transform_rotate(...)
tile = tile.transform_scale(...)
tile = tile.transform_skew(...)
tile = tile.inset_tile(...)
tile = tile.inset_elements(...)
tile = tile.scale_elements(...)
```

## 'Insetting'
Insetting relative to the repeating tile unit helps distinguish elements.
```{python}
laves2 = laves2.inset_tile(25).transform_rotate(15)
hexc3 = hexc3.inset_tile(25)
cairo_tile = cairo_tile.inset_tile(25).transform_rotate(-45)
fig = pyplot.figure(figsize = (12, 4))
ax = fig.add_subplot(131)
laves2.plot(ax = ax, r = 1, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
ax = fig.add_subplot(132)
hexc3.plot(ax = ax, r = 1, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
ax = fig.add_subplot(133)
cairo_tile.plot(ax = ax, r = 2, show_ids = False, 
            show_tile = False, show_reg_tile = False).set_axis_off()
```

# Weaving {background-image="images/weave-pic-2.jpg" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}
For a lot more on woven maps, see [our earlier talk](https://dosull.github.io/weaving-space/NZCS-Nov-2021/make-weave-map.html).

## Some weaving theory
Weaving theory leads to useful matrix-based approaches.

Primarily for *biaxial weaves*.

We (eventually) figured out how to extend the matrix approach to *triaxial* weaves (see [our notes](https://dosull.github.io/weaving-space/code-junkyard/three-way-matrices.html)).

:::aside
This video by Lea Albaugh provided a nice way into the topic: 

["It's Just Matrix Multiplication": Notation for Weaving](https://www.youtube.com/watch?v=oMOSiag3dxg), presented at the Strange Loop conference, St Louis, 27-28 Sept, 2018. 

And this paper spells out the details: 

Glassner A. 2002. [_Digital weaving 1_](https://dx.doi.org/10.1109/MCG.2002.1046635). IEEE Computer Graphics and Applications **22**(6):108–118.
:::

## Weave units
We make these the same way we make tile units.

```{python}
#| echo: true
#| code-line-numbers: "2,5"
w1 = WeaveUnit(weave_type = "twill", n = 3, aspect = .9, 
               strands = "ab-|cde-")

w2 = WeaveUnit(weave_type = "cube", aspect = .8, 
               strands = "a-c|d-f|g-i")
```

The `strands` parameter specifies which strands in each axis separated by the `"|"` are distinct, and also allows us to 'skip' strands on `"-"` characters  .

##

```{python}
fig, ax = pyplot.subplots(1, 2, figsize = (15, 9))
for a, w in zip(ax, (w1, w2)):
  w.plot(ax = a, show_ids = False).set_axis_off()
  a.set_title(f'strands = "{w.strands}"')
```


# Some maps {background-image="images/vermeer-the-geographer.jpg" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}
Vermeer's _The Geographer_ (&bsim;1675) because geography. Image from [commons.wikimedia.org](https://commons.wikimedia.org/wiki/File:Johannes_Vermeer_-_The_Geographer_-_WGA24687.jpg).

## Making a tiled map
When tiling a map, `TileUnit` and `WeaveUnit` objects are the same.

We have to specify the mapping from tileable unit identifiers (`"a"`, `"b"`, `"c"` ...) to data variable names.

We also have to specify the mapping from variable names to preferred colour palettes. 

It's also possible to export a tiled map out to a geospatial or graphical format  and work in some other preferred tool.

```{python}
region = gpd.read_file("/home/osullid3/Documents/code/weaving-space/data/imd-auckland-2018.gpkg")

cairo_tile.crs = region.crs
cairo_tile = cairo_tile.transform_scale(0.5, 0.5)
```

## The code and a map

Make a `Tiling`.

```{python}
#| echo: true
tiling = Tiling(cairo_tile, region, id_var = "DZ2018")
```

Generate a `TiledMap` from the `Tiling` and configure variables and colour specifications.

```{python}
#| echo: true
tiled_map = tiling.get_tiled_map(prioritise_tiles = True)
tiled_map.variables = dict(a = "Rank_Emplo", b = "Rank_Incom", 
                           c = "Rank_Crime", d = "Rank_Housi")
tiled_map.colourmaps = dict(zip(tiled_map.variables.values(),
                                ("Reds", "Blues", "Greens", "Greys")))
```

Then render the map.

```{python}
#| echo: true
#| output-location: slide
fig = tiled_map.render(use_ellipse = True, figsize = (12, 6),
                        legend_dx = -0.05, legend_dy = 0.05)
```

# Some more examples {background-image="images/imd-escher-clip.png" background-opacity=0.5 style="text-shadow: 2px 2px 5px #ffc;"}

##

::: {.r-stack}

![](images/imd-weave.png){.fragment .fade-out fragment-index=1 width="950"}

![](images/imd-arrows.png){.fragment .fade-in-then-out fragment-index=1 width="950"}

![](images/imd-escher.png){.fragment .fade-in-then-out fragment-index=2 width="950"}

![](images/gwr-example.png){.fragment .fade-in-then-out fragment-index=3 width="950"}

![](images/election-2016-weave.png){.fragment .fade-in fragment-index=4 width="900"}
:::


# Conclusions
