library(dplyr)
library(sf)
library(pracma)


# Returns a function that will generate the x-y coordinates for
# a supplied set of integer coordinates in a particular 'space'
# n_axes = 2 is a conventional Cartesian grid with spacing S
# n_axes = 3 is a Nagy triangular grid with spacing S, and axes in 
# vertical, down 120 SW and down 120 SE directions
# See: Nagy, B. N. 2003. Shortest Paths in Triangular Grids with 
#      Neighbourhood Sequences. Journal of Computing and Information 
#      Technology 11 (2):111.
grid_generator <- function(n_axes = 2, S = 1) {
  if (n_axes == 2) {
    angles <- 0:1 * pi / 2
    dx <- S * cos(angles)
    dy <- S * sin(angles)
  }
  if (n_axes == 3) {
    angles <- seq(3, 11, 4) * pi / 6
    dx <- S * cos(angles) * 2 / 3  # every 3rd site missing from the coordinate space
    dy <- S * sin(angles) * 2 / 3
  }
  basis <- matrix(c(dx, dy), nrow = 2, ncol = n_axes, byrow = TRUE)
  return(function(coords) {
    return(t(basis %*% coords) %>% c())
  })
}

# utility function to rotate sf shape through angle in degrees
# about a centre point as supplied
rotate_shape <- function(shape, angle, centre = c(0, 0)) {
  a <- angle * pi / 180
  m <- t(matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2))
  return((shape - centre) * m + centre)
}

# utility function to translate an sf shape by the 
# supplied displacement vector
translate_shape <- function(shape, dxdy = c(0, 0)) {
  return(shape + dxdy)
}

# Returns a grid cell polygon centred at (0, 0) with
# the number of sides requested. One side of the polygon
# will lie horizontal below the x-axis symmetric about the
# y-axis. This means that radii to the corners of the polygon 
# are arranged as either 
# 
# n even:      or, n odd:
#   \  /            |
# ___\/___       ___|___   
#    /\            / \
#   /  \          /   \
# The parameter L is the face to face distance of the polygon from
# the base edge vertically to the opposite face (or if n is odd to
# the opposite corner). This means L is either: 
# n even: L = 2Rcos(pi/n), or
# n odd:  L = R + Rcos(pi/n)
# where R is the radius of the circumcircle
# 
# The polygon is generated by finding the n points equally spaced
# on this circumcircle
get_grid_cell_polygon <- function(face_to_face_distance = 1, n_sides = 4, parity = 0) {
  # Determine value of R
  if (n_sides %% 2 == 0) {
    R <- face_to_face_distance / (2 * cos(pi / n_sides))
  } else {
    R <- face_to_face_distance / (1 + cos(pi / n_sides))
  }
  # determine angles
  # we start at 6 o'clock (3pi/2), then add (pi/n), then add n more 2pi/n steps
  angles <- (3 * pi / 2) + (pi / n_sides) + (0:n_sides / n_sides) * 2 * pi
  # the corners are the cos and sin of these angles
  corners <- R * c(cos(angles), sin(angles)) %>%
    matrix(nrow = n_sides + 1, ncol = 2) %>%
    round(10) # apparently required to ensure first and last points coincident
  polygon <- corners %>% list() %>% st_polygon()
  if (parity %% 2 == 1) {
    return(polygon)
  } else {
    return(rotate_shape(polygon, 180))
  }
}

# Returns 'slices' across a grid cell (i.e. horizontally) centered vertically
# relative to the cell, ie
#
#            /\
#           /  \
#   +------------------+
#   |     /      \     |
#   +------------------+
#   |   /          \   |
#   +------------------+
#     /              \
#    /________________\
# 
# Horizontal extent is given by L, total width of the strips is W, they are
# 'sliced' horizontally in n_equal slices. An offset should be provided to  
# center the slices vertically on the vertical extent of the cell (not its)
# centroid. This is supplied from get_cell_strands()
get_grid_cell_slices <- function(L = 1, W = 1, n_slices = 1, offset = c(0, 0)) {
  sW <- W / n_slices # slice widths
  # odd numbers from 1 to 2n-1
  odd_numbers <- seq(1, (2 * n_slices - 1), 2)
  slice_offsets <-  sW * odd_numbers / 2 - W / 2
  slices <- list()
  for (i in seq_along(slice_offsets)) {
    slices[[i]] <- (matrix(0.5 * c(-L, -sW, L, -sW, L, sW, -L, sW, -L, -sW), 
                           5, 2, byrow = TRUE) %>%  # L by W rectangle centred at 0,0
                      list() %>% st_polygon()) +    # made into a polygon
      c(0, slice_offsets[i]) +                      # offset depending on number of slices
      offset                                        # offset to centre on the cell   
  }
  return((slices %>% st_sfc()))
}

# Gets the cross grid cell strands running across a cell in the x direction
# optionally rotated by orientation for a grid cell spacing S, total strand
# width width (as a fraction of S), sliced into n_slices along its length
get_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0, 
                             orientation = 0, n_slices = 1) {
  # get the base grid cell polygon
  cell <- get_grid_cell_polygon(face_to_face_distance = S, n = n, parity = parity)
  # determine its x-y centre (which may not be where its centroid is)
  bb <- st_bbox(cell)
  cell_offset <- c(bb$xmin + bb$xmax, bb$ymin + bb$ymax) / 2
  return(get_grid_cell_slices(L = bb$xmax - bb$xmin + 0.1, W = S * width, 
                              n_slices = n_slices, offset = cell_offset) %>%
           st_intersection(cell) %>%   # intersect with the grid cell
           translate_shape() %>%       # probably never needed
           rotate_shape(orientation))  # rotate as requested
}  


add_shapes_to_list <- function(lst, shapes) {
  for (s in shapes) {
    lst <- append(lst, list(s))
  }
  return(lst)
}


# Essentially a wrapper for get_cell_strands that returns the strands in all
# the requested cross directions
get_all_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
                                 orientations = c(0, 90), 
                                 n_slices = rep(1, length(orientations))) {
  polys <- list()
  for (i in seq_along(orientations)) {
    next_strands <- get_cell_strands(n = n, S = S, width = width, parity = parity,
                                     orientation = orientations[i], 
                                     n_slices = n_slices[i])

    polys <- add_shapes_to_list(polys, next_strands)
  }
  return(polys %>% st_sfc())
}


get_visible_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
                                     strand_order = 1:(6-n),
                                     orientations = (0:(n-1)) * 360/n , 
                                     n_slices = rep(1, length(orientations))) {
  all_polys <- list()
  for (i in seq_along(strand_order)) {
    next_polys <- get_cell_strands(n = n, S = S, width = width, parity = parity,
                                   orientation = orientations[strand_order[i]], 
                                   n_slices = n_slices[strand_order[i]])
    if (i == 1) {
      all_polys <- add_shapes_to_list(all_polys, next_polys)
      mask_poly <- next_polys %>% 
        st_set_precision(1e10) %>% 
        st_union()
    } else {
      all_polys <- add_shapes_to_list(all_polys, next_polys %>% 
                                        st_snap(mask_poly, 1e-6) %>%
                                        st_difference(mask_poly))
      mask_poly <- mask_poly %>%
        st_union(next_polys %>% 
                   st_set_precision(1e10) %>%
                   st_union())
    }
    if (width == 1) {break} # for efficiency?
  }
  return(all_polys %>% st_sfc())
}

sfc_from_bbox <- function(bb, crs) {
  return(
    st_polygon(list(matrix(c(bb$xmin, bb$ymin, bb$xmax, bb$ymin,
                             bb$xmax, bb$ymax, bb$xmin, bb$ymax,
                             bb$xmin, bb$ymin), 5, 2, byrow = TRUE))) %>%
      st_sfc(crs = crs))
}

make_sf_from_coded_weave_matrix <- function(n_axes = 2, loom = diag(2) + 4, 
                                            spacing = 1, width = 1, margin = 0,
                                            axis1_threads = letters[1:2], 
                                            axis2_threads = letters[3:4],
                                            axis3_threads = letters[5:6], crs = 3857) {
  gg <- grid_generator(n_axes = n_axes, S = spacing)
  weave_polys <- list()
  strands <- c()
  if (n_axes == 2) {
    orientations <- c(90, 0)
    warp <- rep(axis1_threads, ncol(loom) / length(axis1_threads))
    weft <- rep(axis2_threads, nrow(loom) / length(axis2_threads))
    for (warp_thread in 1:ncol(loom)) {
      for (weft_thread in 1:nrow(loom)) {
        xy <- gg(c(warp_thread - 1, weft_thread - 1))
        warp_id <- warp[warp_thread]
        weft_id <- weft[weft_thread]
        strand_order <- decode_biaxial_to_order(loom[weft_thread, warp_thread])
        n_slices <- c(str_length(warp_id), str_length(weft_id))
        next_polys <- get_visible_cell_strands(S = spacing, width = width, 
                                               strand_order = strand_order,
                                               orientations = orientations, 
                                               n_slices = n_slices) + xy
        n_over <- n_slices[strand_order[1]]
        for (i in seq_along(next_polys)) {
          weave_polys <- append(weave_polys, list(next_polys[[i]]))
          id <- ifelse(i <= n_over, # still doing the one on top
                       ifelse(strand_order[1] == 1, warp_id, weft_id) %>% 
                         substr(i, i),
                       ifelse(strand_order[2] == 1, warp_id, weft_id) %>% 
                         substr(i - n_over, i - n_over))
          strands <- c(strands, id)          
        }
      }
      tile <- weave_polys %>% st_sfc() %>% st_bbox() %>% sfc_from_bbox(crs = crs)
    }
  } else {
    ## code for the triaxial case...
  }
  weave_polys <- weave_polys %>%
    st_as_sfc() %>%
    st_set_precision(1e10) %>%
    st_sf(strand = strands) %>%
    filter(strand != "-") %>%
    group_by(strand) %>%
    summarise() %>%
    st_buffer(-margin) %>%
    st_set_crs(crs)
  return(list(weave_unit = weave_polys, 
              tile = tile))
}
