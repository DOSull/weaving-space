library(dplyr)
library(sf)
library(pracma)
library(stringr)

# Returns a matrix of coordinates and a list of the orderings of axes at those sites
matrices_as_loom <- function(...) {
  matrices <- list(...)
  if (length(matrices) == 1) {
    M <- matrices[[1]]
    indices <- expand.grid(weft = 1:nrow(M), warp = 1:ncol(M)) %>%
      as.matrix()
    orderings <- M[indices] %>% 
      lapply(decode_biaxial_to_order, axis = 0)
    parity <- NULL
    orientations <- c(0, -90)
    dimensions <- c(nrow(M), ncol(M))
  } else {
    M1 <- matrices[[1]]
    M2 <- matrices[[2]]
    M3 <- matrices[[3]]
    
    nA <- max(ncol(M1), nrow(M3))
    nB <- max(ncol(M2), nrow(M1))
    nC <- max(ncol(M3), nrow(M2))
    dimensions <- c(nA, nB, nC)
    
    M_AB <- M1 %>% repmat(n = Lcm(nrow(M1), nA) %/% nrow(M1),
                          m = Lcm(ncol(M1), nA) %/% ncol(M1))
    M_BC <- M2 %>% repmat(n = Lcm(nrow(M2), nB) %/% nrow(M2),
                          m = Lcm(ncol(M2), nB) %/% ncol(M2))
    M_CA <- M3 %>% repmat(n = Lcm(nrow(M3), nC) %/% nrow(M3),
                          m = Lcm(ncol(M3), nC) %/% ncol(M3))
    
    parity <- (3 + nA + nB + nC) %/% 2
    orientations <- c(0, 120, 240)
    indices <- expand.grid(a = 1:nA, b = 1:nB, c = 1:nC) %>% 
      filter((a + b + c) %in% parity:(parity + 1)) %>%
      as.matrix()
    orderings <- 
      mapply(combine_orderings, 
             M_AB[indices[, 2:1]] %>% lapply(decode_biaxial_to_order, axis = 1), 
             M_BC[indices[, 3:2]] %>% lapply(decode_biaxial_to_order, axis = 2), 
             M_CA[indices[, c(1, 3)]] %>% lapply(decode_biaxial_to_order, axis = 3), 
             SIMPLIFY = FALSE)
  }
  return(list(indices = indices, 
              orderings = orderings,
              parity = parity,
              orientations = orientations,
              dimensions = dimensions))
}


# Returns a function that will generate the x-y coordinates for
# a supplied set of integer coordinates in a particular 'space'
# n_axes = 2 is a conventional Cartesian grid with spacing S
# n_axes = 3 is a Nagy triangular grid with spacing S, and axes in 
# vertical, down 120 SW and down 120 SE directions
# See: Nagy, B. N. 2003. Shortest Paths in Triangular Grids with 
#      Neighbourhood Sequences. Journal of Computing and Information 
#      Technology 11 (2):111.
grid_generator <- function(n_axes = 2, S = 1) {
  if (n_axes == 2) {
    angles <- 0:1 * pi / 2
    dx <- S * cos(angles)
    dy <- S * sin(angles)
  }
  if (n_axes == 3) {
    angles <- seq(3, 11, 4) * pi / 6
    dx <- S * cos(angles) * 2 / 3  # every 3rd site missing from the coordinate space
    dy <- S * sin(angles) * 2 / 3
  }
  basis <- matrix(c(dx, dy), nrow = 2, ncol = n_axes, byrow = TRUE)
  return(function(coords) {
    return(t(basis %*% coords) %>% c())
  })
}

# utility function to rotate sf shape through angle in degrees
# about a centre point as supplied
rotate_shape <- function(shape, angle, centre = c(0, 0)) {
  a <- angle * pi / 180
  m <- t(matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2))
  return((shape - centre) * m + centre)
}

# utility function to translate an sf shape by the 
# supplied displacement vector
translate_shape <- function(shape, dxdy = c(0, 0)) {
  return(shape + dxdy)
}

# Returns a grid cell polygon centred at (0, 0) with
# the number of sides requested. One side of the polygon
# will lie horizontal below the x-axis symmetric about the
# y-axis. This means that radii to the corners of the polygon 
# are arranged as either 
# 
# n even:      or, n odd:
#   \  /            |
# ___\/___       ___|___   
#    /\            / \
#   /  \          /   \
# The parameter L is the face to face distance of the polygon from
# the base edge vertically to the opposite face (or if n is odd to
# the opposite corner). This means L is either: 
# n even: L = 2Rcos(pi/n), or
# n odd:  L = R + Rcos(pi/n)
# where R is the radius of the circumcircle
# 
# The polygon is generated by finding the n points equally spaced
# on this circumcircle
get_grid_cell_polygon <- function(face_to_face_distance = 1, n_sides = 4, parity = 0) {
  # Determine value of R
  if (n_sides %% 2 == 0) {
    R <- face_to_face_distance / (2 * cos(pi / n_sides))
  } else {
    R <- face_to_face_distance / (1 + cos(pi / n_sides))
  }
  # determine angles
  # we start at 6 o'clock (3pi/2), then add (pi/n), then add n more 2pi/n steps
  angles <- (3 * pi / 2) + (pi / n_sides) + (0:n_sides / n_sides) * 2 * pi
  # the corners are the cos and sin of these angles
  corners <- R * c(cos(angles), sin(angles)) %>%
    matrix(nrow = n_sides + 1, ncol = 2) %>%
    round(10) # apparently required to ensure first and last points coincident
  polygon <- corners %>% list() %>% st_polygon()
  if (n_sides == 4 || parity %% 2 == 1) {
    return(polygon)
  } else {
    return(rotate_shape(polygon, 180))
  }
}

# Returns 'slices' across a grid cell (i.e. horizontally) centered vertically
# relative to the cell, ie
#
#            /\
#           /  \
#   +------------------+
#   |     /      \     |
#   +------------------+
#   |   /          \   |
#   +------------------+
#     /              \
#    /________________\
# 
# Horizontal extent is given by L, total width of the strips is W, they are
# 'sliced' horizontally in n_equal slices. An offset should be provided to  
# center the slices vertically on the vertical extent of the cell (not its)
# centroid. This is supplied from get_cell_strands()
get_grid_cell_slices <- function(L = 1, W = 1, n_slices = 1, offset = c(0, 0)) {
  sW <- W / n_slices # slice widths
  # odd numbers from 1 to 2n-1
  odd_numbers <- seq(1, (2 * n_slices - 1), 2)
  slice_offsets <-  sW * odd_numbers / 2 - W / 2
  slices <- list()
  for (i in seq_along(slice_offsets)) {
    slices[[i]] <- (matrix(0.5 * c(-L, -sW, L, -sW, L, sW, -L, sW, -L, -sW), 
                           5, 2, byrow = TRUE) %>%  # L by W rectangle centred at 0,0
                      list() %>% st_polygon()) +    # made into a polygon
      c(0, slice_offsets[i]) +                      # offset depending on number of slices
      offset                                        # offset to centre on the cell   
  }
  return((slices %>% st_sfc()))
}

# Gets the cross grid cell strands running across a cell in the x direction
# optionally rotated by orientation for a grid cell spacing S, total strand
# width width (as a fraction of S), sliced into n_slices along its length
get_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0, 
                             orientation = 0, n_slices = 1) {
  # get the base grid cell polygon
  cell <- get_grid_cell_polygon(face_to_face_distance = S, n = n, parity = parity)
  # determine its x-y centre (which may not be where its centroid is)
  bb <- st_bbox(cell)
  cell_offset <- c(bb$xmin + bb$xmax, bb$ymin + bb$ymax) / 2
  return(get_grid_cell_slices(L = bb$xmax - bb$xmin + 0.1, W = S * width, 
                              n_slices = n_slices, offset = cell_offset) %>%
           st_intersection(cell) %>%   # intersect with the grid cell
           translate_shape() %>%       # probably never needed
           rotate_shape(orientation))  # rotate as requested
}  


add_shapes_to_list <- function(lst, shapes) {
  for (s in shapes) {
    lst <- append(lst, list(s))
  }
  return(lst)
}


# Essentially a wrapper for get_cell_strands that returns the strands in all
# the requested cross directions
get_all_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
                                 orientations = c(0, 90), 
                                 n_slices = rep(1, length(orientations))) {
  polys <- list()
  for (i in seq_along(orientations)) {
    next_strands <- get_cell_strands(n = n, S = S, width = width, parity = parity,
                                     orientation = orientations[i], 
                                     n_slices = n_slices[i])

    polys <- add_shapes_to_list(polys, next_strands)
  }
  return(polys %>% st_sfc())
}

# Returns the visible parts of the strands in a grid, given the spacing S
# strand width width, parity (for the triangular case), a vector of strand
# orders and matching vectors of orientations and the desired number of slices
get_visible_cell_strands <- function(n = 4, S = 1, width = 1, parity = 0,
                                     strand_order = 1:(6-n),
                                     orientations = (0:(n-1)) * 360/n , 
                                     n_slices = rep(1, length(orientations))) {
  all_polys <- list()
  for (i in seq_along(strand_order)) {
    next_polys <- get_cell_strands(n = n, S = S, width = width, parity = parity,
                                   orientation = orientations[strand_order[i]], 
                                   n_slices = n_slices[strand_order[i]])
    if (i == 1) {
      all_polys <- add_shapes_to_list(all_polys, next_polys)
      # mask poly progressively builds the union of all polygons 
      # so far, to mask out invisible parts of those underneath
      mask_poly <- next_polys %>% 
        st_set_precision(1e10) %>% 
        st_union()
    } else {
      all_polys <- add_shapes_to_list(all_polys, next_polys %>% 
                                        st_snap(mask_poly, 1e-6) %>%
                                        st_difference(mask_poly))
      mask_poly <- mask_poly %>%
        st_union(next_polys %>% 
                   st_set_precision(1e10) %>%
                   st_union())
    }
    # if the width is 1 then no lower polygons are visible
    if (width == 1) {break} # for efficiency?
  }
  return(all_polys %>% st_sfc())
}

# returns a rectangular polygon matching a provided bounding box
sfc_from_bbox <- function(bb, crs) {
  return(
    st_polygon(list(matrix(c(bb$xmin, bb$ymin, bb$xmax, bb$ymin,
                             bb$xmax, bb$ymax, bb$xmin, bb$ymax,
                             bb$xmin, bb$ymin), 5, 2, byrow = TRUE))) %>%
      st_sfc(crs = crs))
}


# builds the sf associate with a given weave supplied as 'loom' which is a list
# containing the coordinates in an appropriate grid (Cartesian or triangular)
# and the orderings of the strands at each coordinate location
make_sf_from_coded_weave_matrix <- function(loom, spacing = 1, width = 1, margin = 0,
                                            axis1_threads = letters[1:2], 
                                            axis2_threads = letters[3:4],
                                            axis3_threads = letters[5:6], crs = 3857) {
  # we need the number of axes, which we can use to make a grid generator function 
  n_axes <- length(loom$dimensions)
  n_sides <- if_else(n_axes == 2, 4, 3)
  gg <- grid_generator(n_axes = n_axes, S = spacing)
  # the labels for axis1 and 2 are required in both cases and we repeat 
  # them if required by the size of the grid relative to the number of ids
  ids1 <- rep(axis1_threads, loom$dimensions[1] / length(axis1_threads))
  ids2 <- rep(axis2_threads, loom$dimensions[2] / length(axis2_threads))
  parity <- 1
  # setup empty lists and vectors for the outputs
  weave_polys <- list()
  bb_polys <- list()
  strands <- c()
  # step through the loom index coordinates
  for(i in 1:nrow(loom$indices)) {
    if (n_axes == 2) { # biaxial case
      # confusingly the row-column ordering of R means the index needs to be reversed
      coords <- rev(loom$indices[i, ])    # note row,column, ie y,x or weft,warp
      # list of strand labels at this location (again note coordinate reversal)
      labels <- c(ids1[coords[2]], ids2[coords[1]])
    } else { # triaxial
      # there is an additional set of thread labels
      ids3 <- rep(axis3_threads, loom$dimensions[3] / length(axis3_threads))
      coords <- loom$indices[i, ]     # coordinates are in the correct order!
      labels <- c(axis1[coords[1]], axis2[coords[2]], axis3[coords[3]]) # as are labels
      # additional rotation required at alternate sites in triangular grid
      parity <- (sum(coords) - loom$parity) %% 2 
    }
    # get the offset vector
    xy <- gg(coords)
    # the strand order as a vector
    strand_order <- loom$orderings[[i]]    # order in which strands appear
    bb_polys <- append( # get a grid cell polygon at every site
      bb_polys, list(get_grid_cell_polygon(face_to_face_distance = spacing,
                                           n_sides = n_sides, parity = parity) + xy))
    if (is.null(strand_order)) { next } # nothing here so move on
    n_slices <- str_length(labels) # numbers of slices required in each direction
    n <- cumsum(n_slices[strand_order]) # cumulative count of strands in each direction
    # now get the polygons
    next_polys <- get_visible_cell_strands(n = ifelse(n_axes == 2, 4, 3),
      S = spacing, width = width, strand_order = strand_order,
      parity = parity, orientations = loom$orientations, n_slices = n_slices) + xy
    # add the polygons to the list we are assembling
    # we do this one at a time because it simplifies later conversion to sfc
    for (p in seq_along(next_polys)) {
      weave_polys <- append(weave_polys, list(next_polys[[p]]))
      if (p <= n[1]) { # top layer
        id <- labels[strand_order[1]] %>% str_sub(p, p)
      } else if (p <= n[2]) { # middle layer (bottom layer if there are 2)
        id <- labels[strand_order[2]] %>% str_sub(p - n[1], p - n[1])
      } else { # bottom layer (if there are 3)
        id <- labels[strand_order[3]] %>% str_sub(p - n[2], p - n[2])
      }
      strands <- c(strands, id)          
    }
  }
  return(list(weave_unit = weave_polys %>%
                st_as_sfc() %>%                # convert to sfc
                st_set_precision(1e10) %>%     # to ensure they dissolve nicely
                st_sf(strand = strands) %>%    # add the strands information
                filter(strand != "-") %>%      # remove any tagged missing
                group_by(strand) %>%           # dissolve
                summarise() %>%
                st_buffer(-margin) %>%         # include a negative margin
                st_set_crs(crs),               # set CRS
              tile = bb_polys %>%
                st_sfc() %>%                   # convert to sfc
                st_set_precision(1e10) %>%     # to ensure clean dissolve
                st_union() %>%                 # union   
                st_set_crs(crs)))              # set CRS
}
