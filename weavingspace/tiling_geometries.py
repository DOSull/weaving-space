#!/usr/bin/env python
# coding: utf-8

"""Functions for setting up a `weavingspace.tile_unit.TileUnit` with various
tile geometries. Some care is required in adding new functions that use
existing ones to get the sequence of setup operations right. Modify with care!

Many of the available tilings can be viewed at

https://dosull.github.io/weaving-space/tiling-explorer/

These tilings (and many many more!) are discussed in

Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H. Freeman and
Company, New York)

A more accessible introduction is

Kaplan C S, 2002 _Computer Graphics and Geometric Ornamental Design_, PhD
thesis, University of Washington, Seattle, WA, 
https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf

and a more 'polished' version of that work focused on computer graphics is also
available

Kaplan C S, 2009 _Introductory Tiling Theory for Computer Graphics_ (Morgan &
Claypool)
"""

from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
  from weavingspace import TileUnit
import itertools
import string
import math

import geopandas as gpd
import numpy as np
import shapely.geometry as geom
import shapely.affinity as affine
from shapely import line_interpolate_point

from weavingspace import TileShape
from weavingspace import tiling_utils

sqrt2 = np.sqrt(2)
sqrt3 = np.sqrt(3)

def setup_cairo(unit:TileUnit) -> None:
  """Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.

  The pattern in this function shows how any new setup function should be
  organised:

    + Make the geometries and put them in a GeoDataFrame with the
      appropriate number of tile_id codes
    + Set the translation vectors
    + Return None (THIS IS IMPORTANT)

  This example shows this for a 'handcoded' set of geometries can be applied.

  Note that it is advisable to avoid intersection and union operations where
  possible, as it often yields floating point mismatches that can be hard to 
  repair! (This tiling could be relatively conveniently generated by dissecting
  a square in 4 quarters at a 30 degree angle to the sides and then reflecting
  and rotating copies and joing them back together. But floating point issues
  make that very messy indeed. Much better to make the geometries 'pure'.)

  To design new tilings, you have to get out pencil and paper and do the
  trigonometry.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  # MAKE GEOMETRIES
  d = unit.spacing
  x = d/2 / (np.cos(np.pi/12) + np.cos(5*np.pi/12))
  # the following is just the geometry, it is what it is...
  # points are (more or less)
  #
  #         3
  #     2
  #            4
  #     1    0
  #
  # then rotate -15 and make 4 copies at 90 degree rotations
  p1 = geom.Polygon([(x, 0), (0, 0), (0, x),
                     (x * sqrt3/2, x + x/2),
                     (x * (1 + sqrt3) / 2, x * (3 - sqrt3) / 2)])
  p1 = affine.rotate(p1, -15, (0, 0))
  p2 = affine.rotate(p1, 90, (0, 0))
  p3 = affine.rotate(p1, 180, (0, 0))
  p4 = affine.rotate(p1, 270, (0, 0))
  # now move them so they are arranged as a hexagon centered on the tile
  p1 = affine.translate(p1, -unit.spacing / 2, 0)
  p2 = affine.translate(p2, unit.spacing / 2, 0)
  p3 = affine.translate(p3, unit.spacing / 2, 0)
  p4 = affine.translate(p4, -unit.spacing / 2, 0)
  polys = [affine.rotate(p, 45, origin = (0, 0)) for p in [p1, p2, p3, p4]]
  # MAKE THE GEODATAFRAME
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcd")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys))
  
  # SET THE TRANSLATION VECTORS
  unit.setup_vectors((unit.spacing / sqrt2,  unit.spacing/sqrt2),
                     (unit.spacing / sqrt2, -unit.spacing/sqrt2))
  
  # RETURN NONE
  return None

def setup_hex_slice(unit:TileUnit) -> None:
  """Arbitrary number of radial slices of a hexagon, with an optional
  offset starting point.

  The supplied unit should have offset and n set.

  Places unit.n points equally spaced around the perimeter of the hexagon.
  Slices are formed by connecting some sequence of these points (and any
  intervening hexagon corners) and the hexagon centre to form a pie slice.
  unit.offset = 0 starts from corner 0. unit.offset = 1 starts half way between
  corner 0 and corner 1. Other values of unit.offset scale linearly between
  these.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["n", "offset"]]):
    return (f"""Hex slice tiling requires both n and offset values
            to be supplied.""")
  hexagon = tiling_utils.get_regular_polygon(unit.spacing, 6)
  slices = _get_radially_sliced_polygon(hexagon, unit.n, unit.offset)
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(slices))
  unit.setup_vectors((                       0,  unit.spacing    ), 
                     (unit.spacing * sqrt3/2,  unit.spacing / 2),
                     (unit.spacing * sqrt3/2, -unit.spacing / 2))
  return None

def setup_square_slice(unit:TileUnit) -> None:
  """Arbitrary number of radial slices of a square, with an optional
  offset starting point.

  The supplied unit should have offset and n set.

  Places unit.n points equally spaced around the perimeter of the square.
  Slices are formed by connecting some sequence of these points (and any
  intervening squares corners) and the square centre to form a pie slice.
  unit.offset = 0 starts from corner 0. unit.offset starts half way between
  corner 0 and corner 1. Other values of unit.offset scale linear between
  these.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["n", "offset"]]):
    return (f"""Square slice tiling requires both n and offset values
            to be supplied.""")
  square = tiling_utils.get_regular_polygon(unit.spacing, 4)
  slices = _get_radially_sliced_polygon(square, unit.n, unit.offset)
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(slices))
  unit.setup_vectors((0, unit.spacing), (unit.spacing, 0))
  return None

def _get_radially_sliced_polygon(
  shape:geom.Polygon, 
  n_slices:int, 
  offset:float) -> gpd.GeoSeries:
  """Returns a number of 'pie slices' of the supplied polygon as a GeoSeries.

  Args:
    shape (geom.Polygon): the polygon to slice up.
    n_slices (int): the desired number of slices.
    offset (float): a linearly scaled positional offset for the starting 
      point of the slices. 0 is at the first vertex. 1 is halfway between
      that and the next vertex.

  Returns:
      gpd.GeoSeries: a set of slice polygons.
  """
  n_sides = len(shape.exterior.coords) - 1
  boundary = geom.LineString(shape.exterior.coords)
  offset = (offset % 1 
            if offset < 0 or offset > 1 
            else offset)
  offset = (offset * n_sides / n_slices / 2 
            if n_slices >= n_sides
            else offset / 2)
  # the values in along are denominated in 'side counts' i.e. they run from
  # 0 to the number of sides, with e.g., 2,5 halfway along the 3rd side
  along = [n_sides * i / n_slices + offset for i in range(n_slices)]
  along = along + [n_sides + along[0]]
  # the cut points
  points = [line_interpolate_point(
    boundary, (a % n_sides) / n_sides, normalized = True) for a in along]
  # the corners of the original polygon
  corners = tiling_utils.get_corners(shape)
  slices = []
  # now we iterate over the list of values in along and in points in parallel
  # checking if any cut point has 'skipped' a corner when the integer part
  # of the values from the along list will be different
  for a1, a2, p1, p2 in zip(along[:-1], along[1:], points[:-1], points[1:]):
    if math.floor(a1) == math.floor(a2):
      # two cut points on same polygon edge, so make the slice
      slices.append(geom.Polygon([p1, p2, (0, 0)]))
    else:
      # there is at least one corner between the cut points so get them
      skipped_corners = corners[math.ceil(a1):math.ceil(a2)]
      # but discard any that are close to the cut points...
      skipped_corners = [
        c for c in skipped_corners
        if not (np.isclose(c.distance(p1), 0, rtol = 1e-6, atol = 1e-6) 
             or np.isclose(c.distance(p2), 0, rtol = 1e-6, atol = 1e-6))]
      slices.append(geom.Polygon([p1] + skipped_corners + [p2, (0, 0)]))
  return gpd.GeoSeries(slices)

def setup_crosses(unit:TileUnit) -> None:
  """Tilings by varying numbers of crosses.

  The supplied unit should have n set. The specific arrangements used are
  more or less arbitrary, worked out on inkscape and/or with pencil and paper.
  There is probably an algorithmic way to relate the arrangement of crosses
  and the tiling translation vectors, but this is fine for present purposes.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["n"]]):
    return (f"""Crosses tiling requires n to be supplied.""")
  square = tiling_utils.get_regular_polygon(unit.spacing, 4)
  x = unit.spacing / np.sqrt(unit.n * 5)
  cross = geom.Polygon([
      (-x/2, -x/2), (-3*x/2,   -x/2), (-3*x/2,    x/2), 
      (-x/2,  x/2), (  -x/2,  3*x/2), (   x/2,  3*x/2), 
      ( x/2,  x/2), ( 3*x/2,    x/2), ( 3*x/2,   -x/2), 
      ( x/2, -x/2), (   x/2, -3*x/2), (  -x/2, -3*x/2)])
  match unit.n:
    case 2:
      trans = [(-x/2, -x), (x/2, x)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-3*x, -x), (-x, 3*x))
    case 3:
      trans = [(-3*x/2, -x), (-x/2, x), (3*x/2, 0)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-4*x, -3*x), (-5*x, 0), (-x,  3*x))
    case 4:
      trans = [(3*x/2, x/2), (x/2, -3*x/2), (-3*x/2, -x/2), (-x/2, 3*x/2)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-4*x, -3*x), (-4*x,  2*x), (0,  5*x))
    case 5:
      trans = [(0, 0), (x, 2*x), (2*x, -x), (-x, -2*x), (-2*x, x)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-5*x, 0), (0,  5*x))
    case 6:
      trans = [(-2*x, -3*x/2), (-x,  x/2), (0,  5*x/2), 
               ( 2*x,  3*x/2), ( x, -x/2), (0, -5*x/2)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-3*x, -6*x), (-5*x, 0), (-2*x,  6*x))
    case 7:
      trans = [(0, 0), (-x, -2*x), (-2*x,  x), (-x,  3*x), 
                       ( x,  2*x), ( 2*x, -x), ( x, -3*x)]
      parts = [affine.translate(cross, dx, dy) for dx, dy in trans]
      unit.setup_vectors((-4*x, -3*x), (-5*x,  5*x), (-x,  8*x))
    case _:
      return (f"""a {unit.n} crosses tiling is not implemented. 
              Try a number between 2 and 7.""")
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(parts))
  return None

def setup_laves(unit:TileUnit) -> None:
  """The Laves tilings. See 
  
  https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.

  These are all isohedral, but mostly not regular polygons. We prioritise them
  over the Archimedean tilings because being isohedral all tiles are the same
  size and shape which makes code to generate them a lot easier to write. 
  Several are hex dissections and setup is delegated accordingly.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["code"]]):
    return (f"""Laves tiling requires vertex degree code to be supplied.""")
  match unit.code:
    case "3.3.3.3.3.3":
      # this is the regular hexagons
      unit.base_shape = TileShape.HEXAGON
      return (f"""Laves 6.6.6 is a basic hexagonal tiling. Perhaps you want a 
              hex-colouring, hex-slice or hex-dissection tiling?""")
    case "3.3.3.3.6":
      # this one needs its own code
      _setup_laves_3_3_3_3_6(unit)
    case "3.3.3.4.4":
      # this is a boring tiling...
      setup_archimedean_3_3_3_4_4(unit)
      unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    case "3.3.4.3.4":
      # king of tilings!
      print(f"A fine choice!")
      setup_cairo(unit)
    case "3.4.6.4":
      # the hex 6-dissection
      unit.n = 6
      unit.offset = 1
      setup_hex_slice(unit)
    case "3.6.3.6":
      # hex 3-dissection (also a cube weave!)
      unit.n = 3
      unit.offset = 0
      setup_hex_slice(unit)
    case "3.12.12":
      # again this one needs its own
      _setup_laves_3_12_12(unit)
    case "4.4.4.4":
      # square grid
      unit.base_shape = TileShape.RECTANGLE
      return (f"""Laves 4.4.4.4 is a basic square tiling. Perhaps you want a 
              square-colouring or square-slice tiling?""")
    case "4.6.12":
      # hex 12-dissection
      unit.n = 12
      unit.offset = 0
      setup_hex_slice(unit)
    case "4.8.8":
      # this one needs its own (a 4-dissection of the square)
      # perhaps to be added as a category later...
      unit.n = 4
      unit.offset = 0.0
      setup_square_slice(unit)
    case "6.6.6":
      # triangles
      unit.base_shape = TileShape.TRIANGLE
      return f"""Note that Laves 3.3.3.3.3.3 is a basic triangle tiling."""
    case _:
      return  "[{unit.code}] is not a valid Laves code."
  return None

def _setup_laves_3_3_3_3_6(unit:TileUnit) -> None:
  """Sets up Laves [3.3.3.3.6] which is like a 6 petal flower.

  Similar to the H3 7 hexagon group with the central hex removed and each
  hex 'taking' a 1/6 share of the central hex.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  sf = 1 / np.sqrt(7)
  tile = tiling_utils.get_regular_polygon(unit.spacing, 6)
  hexagon = affine.scale(tile, sf, sf)
  # translate it up by its own height
  hexagon = affine.translate(hexagon, 0, hexagon.bounds[3] - hexagon.bounds[1])
  hex_p = [p for p in hexagon.exterior.coords]
  # now replace first and last points by (0, 0)
  # (note shapely doesn't require closure of the polygon)
  petal = geom.Polygon([(0, 0)] + hex_p[1:5])
  offset_a = np.degrees(np.arctan(1 / 3 / sqrt3))
  petals = [
    tiling_utils.gridify(affine.rotate(petal, a + offset_a, origin = (0, 0)))
    for a in range(30, 360, 60)]
  unit.setup_vectors((                            0,  unit.spacing    ), 
                     (unit.spacing * sqrt3/2,  unit.spacing / 2),
                     (unit.spacing * sqrt3/2, -unit.spacing / 2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")},
    crs = unit.crs,
    geometry = gpd.GeoSeries(petals))
  return None

def _setup_laves_3_12_12(unit:TileUnit) -> None:
  """This is also a hexagon dissection... like 3.6.3.6 with each rhombus
  sliced in half along its long diagonal.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  hexagon = tiling_utils.get_regular_polygon(unit.spacing, 6)
  pts = [p for p in hexagon.exterior.coords]
  tri1 = geom.Polygon([pts[0], pts[2], [0, 0]])
  tri2 = geom.Polygon([pts[0], pts[1], pts[2]])
  tris1 = [affine.rotate(tri1, a, origin = (0, 0))
       for a in range(0, 360, 120)]
  tris2 = [affine.rotate(tri2, a, origin = (0, 0))
       for a in range(0, 360, 120)]
  # reorder so the 'inner' and 'outer' triangles are labelled alternately
  tris = itertools.chain(*zip(tris1, tris2))
  unit.setup_vectors((                            0,  unit.spacing    ), 
                     (unit.spacing * sqrt3/2,  unit.spacing / 2),
                     (unit.spacing * sqrt3/2, -unit.spacing / 2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")}, crs = unit.crs,
    geometry = gpd.GeoSeries(tris)
  )
  return None

def setup_archimedean(unit:TileUnit) -> None:
  r"""The Archimedean 'regular tilings. See 
  
  https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane

  Many of these are easily constructed as duals of the Laves tilings. However,
  inaccuracies in the `tiling_utils.get_dual_tiling()` function yield tiles
  can't sustain reliable Topology detection... ¯\_(ツ)_/¯

  Some are not implemented: (3.3.3.4.4) is kind of weird (stripes of triangles 
  and squares) so can't be bothered with it.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["code"]]):
    return (f"""Archimedean tiling requires vertex degree code to be supplied.
            """)
  match unit.code:
    case "3.3.3.3.3.3":
      unit.base_shape = TileShape.TRIANGLE
      return (f"""Note that Archimedean 3.3.3.3.3.3 is a basic 
              triangle tiling?""")
    case "3.3.3.3.6":
      setup_archimedean_3_3_3_3_6(unit)
    case "3.3.3.4.4":
      setup_archimedean_3_3_3_4_4(unit)
    case "3.3.4.3.4":
      setup_archimedean_3_3_4_3_4(unit)
    case "3.4.6.4":
      setup_archimedean_3_4_6_4(unit)
    case "3.6.3.6":
      setup_archimedean_3_6_3_6(unit)
    case "3.12.12":
      setup_archimedean_3_12_12(unit)
    case "4.4.4.4":
      unit.base_shape = TileShape.RECTANGLE
      return (f"""Archimedean 4.4.4.4 is a basic square tiling. Perhaps you
              want a square-colouring or square-slice tiling?""") 
    case "4.6.12":
      setup_archimedean_4_6_12(unit)
    case "4.8.8":
      setup_archimedean_4_8_8(unit)
    case "6.6.6":
      unit.base_shape = TileShape.HEXAGON
      return (f"""Archimedean 6.6.6 is a basic hexagonal tiling. Perhaps you
              want a hex-colouring, hex-slice or hex-dissection tiling?""")
    case _:
      unit.base_shape = TileShape.RECTANGLE
      return  f"({unit.code}) is not a valid Archimedean code."
  return None

# Note that where possible in the functions that follow the following short
# variable names are used:
#  t for height of triangles
#  s for height of squares
#  h for height of hexagons
#  o for height of octagons
#  d for height of dodecagons
# rescaling so that the resulting tile unit meets the unit.spacing request is
# in most cases exact, but where the tile unit departs from a plain square or
# hexagon it's approximate.
def setup_archimedean_3_3_3_3_6(unit:TileUnit) -> None:
  h = unit.spacing * np.sqrt(3/7)
  t = h / 2
  hexagon = tiling_utils.get_regular_polygon(h, 6)
  tri = tiling_utils.get_regular_polygon(t, 3)
  tri_up = affine.translate(tri, 0, -tri.bounds[3])
  tri_dn = affine.rotate(tri_up, 180, origin = (0, 0))
  wdth, hght = tri.bounds[2] - tri.bounds[0], tri.bounds[3] - tri.bounds[1]
  triangles = [affine.translate(tri_up,        0,  2*hght),
               affine.translate(tri_up,   wdth  ,  2*hght),
               affine.translate(tri_dn,   wdth  ,       0),
               affine.translate(tri_up, 3*wdth/2,    hght),
               affine.translate(tri_dn, 3*wdth/2,   -hght),
               affine.translate(tri_up,   wdth  ,       0),
               affine.translate(tri_dn,   wdth  , -2*hght),
               affine.translate(tri_dn,        0, -2*hght)]
  polys = [hexagon] + triangles
  unit.setup_vectors((-wdth/2, 3*hght), (2*wdth, 2*hght), (5*wdth/2, -hght))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdefghi")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_3_3_3_4_4(unit:TileUnit) -> None:
  s = unit.spacing / np.sqrt(1 + sqrt3)
  t = s * sqrt3/2
  square = tiling_utils.get_regular_polygon(s, 4)
  tri = tiling_utils.get_regular_polygon(t, 3)
  tri_up = affine.translate(tri, 0, -tri.bounds[1] + s/2)
  tri_dn = affine.rotate(tri_up, 180, origin = (0, 0))
  polys = [square, tri_up, tri_dn]
  unit.setup_vectors((s/2, s+t), (s, 0), (s/2, -s-t))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abc")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_3_3_4_3_4(unit:TileUnit) -> None:
  s = unit.spacing/2/np.cos(np.pi/12)
  t = s * sqrt3/2
  square = tiling_utils.get_regular_polygon(s, 4)
  tri = tiling_utils.get_regular_polygon(t, 3)
  tri1 = affine.translate(tri, 0, -tri.bounds[3])
  tri2 = affine.rotate(tri1,  180, origin = (0, -t))
  tri3 = affine.rotate(tri1,  150, origin = (0,  0))
  tri4 = affine.rotate(tri1, -150, origin = (0,  0))
  sq1 = affine.translate(square, s/2, -s/2)
  sq1 = affine.rotate(sq1,   30, origin = (0, 0))
  sq2 = affine.rotate(sq1, -150, origin = (0, 0))
  polys = [tri2, tri1, sq2, tri4, tri3, sq1]
  polys = [affine.translate(p, 0, t - s/2) for p in polys]
  unit.setup_vectors((t + s/2,  t + s/2), (t + s/2, -t - s/2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_3_4_6_4(unit:TileUnit) -> None:
  h = unit.spacing / (1 + sqrt3) * sqrt3
  s = h / sqrt3
  t = h / 2
  hex    = tiling_utils.get_regular_polygon(h, 6)
  square = tiling_utils.get_regular_polygon(s, 4)
  tri    = tiling_utils.get_regular_polygon(t, 3)
  sq1 = affine.translate(square, 0, s / 2 + t)
  sq2 = affine.rotate(sq1,  60, origin = (0, 0))
  sq3 = affine.rotate(sq1, -60, origin = (0, 0))
  tri1 = affine.translate(tri, 0, t - tri.bounds[1])
  tri2 = affine.translate(tri, 0, t - tri.bounds[1])
  tri1 = affine.rotate(tri1, 90, origin = (-s / 2, t))
  tri2 = affine.rotate(tri2, -90, origin = (s / 2, t))
  polys = [hex, sq2, tri1, sq1, tri2, sq3]
  unit.setup_vectors((0, h + s), (t + 3*s/2,  t + s/2), (t + 3*s/2, -t - s/2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_3_6_3_6(unit:TileUnit) -> None:
  h = unit.spacing * sqrt3/2
  t = h / 2
  hex = tiling_utils.get_regular_polygon(h, 6)
  tri = tiling_utils.get_regular_polygon(t, 3)
  tri1 = affine.translate(tri, 0, t - tri.bounds[1])
  tri2 = affine.rotate(tri, 180)
  tri2 = affine.translate(tri2, 0, -t - tri.bounds[3])
  polys = [hex, tri1, tri2]
  unit.setup_vectors((t*2/sqrt3,  h), (t*2/sqrt3, -h))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abc")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_3_12_12(unit:TileUnit) -> None:
  d = unit.spacing
  t = d * sqrt3/2 / (2 + sqrt3)
  dodecagon = tiling_utils.get_regular_polygon(d, 12)
  tri = tiling_utils.get_regular_polygon(t, 3)
  tri = affine.translate(tri, 0, unit.spacing / 2 - tri.bounds[1])
  tri_1 = affine.rotate(tri,  30, origin = (0, 0))
  tri_2 = affine.rotate(tri, -30, origin = (0, 0))
  polys = [dodecagon, tri_1, tri_2]
  unit.setup_vectors((0, d), (d * sqrt3/2,  d/2), (d * sqrt3/2, -d/2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abc")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_4_6_12(unit:TileUnit) -> None:
  d = unit.spacing * (2 + sqrt3) / (3 + sqrt3)
  s = d / (2 + sqrt3)
  h = s * sqrt3
  dodecagon = tiling_utils.get_regular_polygon(d, 12)
  hex = tiling_utils.get_regular_polygon(h, 6)
  square = tiling_utils.get_regular_polygon(s, 4)
  sq1 = affine.translate(square, 0, (s + d) / 2)
  sq2 = affine.rotate(sq1,  60, origin = (0, 0))
  sq3 = affine.rotate(sq1, -60, origin = (0, 0))
  hex1 = affine.translate(hex, 0, (h + d) / 2)
  hex1 = affine.rotate(hex1,  30, origin = (0, 0))
  hex2 = affine.rotate(hex1, -60, origin = (0, 0))
  polys = [dodecagon, sq2, hex1, sq1, hex2, sq3]  
  unit.setup_vectors((                       0,   d + s), 
                     ((d + s) * sqrt3/2,  (d + s) / 2),
                     ((d + s) * sqrt3/2, -(d + s) / 2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_archimedean_4_8_8(unit:TileUnit) -> None:
  o = unit.spacing
  s = o / (1 + sqrt2)
  octagon = tiling_utils.get_regular_polygon(o, 8)
  square = tiling_utils.get_regular_polygon(s, 4)
  square = affine.translate(square, 0, (o + s) / 2)
  square = affine.rotate(square, 45, origin = (0, 0))
  polys = [octagon, square]
  unit.setup_vectors((0, o), (o, 0))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("ab")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_square_trisection(unit:TileUnit) -> None:
  s1 = unit.spacing / sqrt2
  p1 = geom.Point(  0,  s1)
  p2 = geom.Point( s1,   0)
  p3 = geom.Point(  0, -s1)
  p4 = geom.Point(-s1,   0)
  p5 = geom.Point( s1 / sqrt3,  s1 - s1 / sqrt3)
  p6 = geom.Point(               0,  s1 - (2 * s1) / sqrt3)
  p7 = geom.Point(-s1 / sqrt3,  s1 - s1 / sqrt3)
  sq = geom.Polygon([p6, p7, p1, p5])
  shp1 = geom.Polygon([p6, p5, p2, p3])
  shp2 = geom.Polygon([p6, p3, p4, p7])
  polys = [sq, shp1, shp2]
  unit.setup_vectors((s1,  s1), (s1, -s1))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abc")}, crs = unit.crs,
    geometry = gpd.GeoSeries(polys)
  )
  return None

def setup_hex_colouring(unit:TileUnit) -> None:
  """2 through 9 colourings of a regular array of hexagons. The supplied unit
  must have unit.n set.

  Args:
    unit (TileUnit): the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["n"]]):
    return (f"""Hex colouring tiling requires n to be supplied.""")
  hexagon = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 6)
  bounds = hexagon.bounds
  w = bounds[2] - bounds[0]
  h = bounds[3] - bounds[1]
  match unit.n:
    case 2:
      # Pair of point up hexes sideways displaced by width of a hex
      # Vectors are rectangular
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      hexes = [affine.translate(hexagon, dx, 0) for dx in [-w/2, w/2]]
      unit.setup_vectors((w/2, 3*h/4), (2*w, 0))
    case 3:
      # Point up hex at '*' displaced to 3 positions:
      #      2
      #      *
      #    3   1
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      # Copy and translate to alternate corners
      corners = [p for i, p in enumerate(hexagon.exterior.coords)
                 if i in (0, 2, 4)]
      hexes = [affine.translate(hexagon, p[0], p[1]) for p in corners]
      unit.setup_vectors((0  ,  3*h/2), (3*w/2,  3*h/4), (3*w/2, -3*h/4))
    case 4:
      # Point up hex at '*' displaced to 4 positions:
      #      2
      #     3*1
      #      4
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      hex1 = affine.translate(hexagon, unit.spacing / 4, 0)
      hex2 = affine.translate(hexagon, 0, unit.spacing * sqrt3 / 4)
      hex3 = affine.translate(hexagon, -unit.spacing / 4, 0)
      hex4 = affine.translate(hexagon, 0, -unit.spacing * sqrt3 / 4)
      hexes = [hex1, hex2, hex3, hex4]
      unit.setup_vectors((w,  3*h/2), (w, -3*h/2))
    case 4:
      # Point up hex at '*' displaced to 4 positions:
      #      2
      #     3*1
      #      4
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      hex1 = affine.translate(hexagon, unit.spacing / 4, 0)
      hex2 = affine.translate(hexagon, 0, unit.spacing * sqrt3 / 4)
      hex3 = affine.translate(hexagon, -unit.spacing / 4, 0)
      hex4 = affine.translate(hexagon, 0, -unit.spacing * sqrt3 / 4)
      hexes = [hex1, hex2, hex3, hex4]
      unit.setup_vectors((w,  3*h/2), (w, -3*h/2))
    case 5:
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      tr = [(-w,  h/4), (0,  h/4), ( w, h/4), (-w/2, -h/2), (w/2, -h/2)]
      hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
      unit.setup_vectors((0,  3*h/2), (5*w/2,  3*h/4), (5*w/2, -3*h/4))
    case 6:
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      tr = [(-5*w/4,  3*h/8), (-w/4,  3*h/8), (3*w/4,  3*h/8), 
            (-3*w/4, -3*h/8), ( w/4, -3*h/8), (5*w/4, -3*h/8)]
      hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
      unit.setup_vectors((0,  3*h/2), (3*w, 0))
    case 7:  # the 'H3' tile
      # Make a hexagon and displace in the direction of its
      # own 6 corners, scaled as needed
      base_hex = tiling_utils.get_regular_polygon(unit.spacing, 6)
      bounds = base_hex.bounds
      w = bounds[2] - bounds[0]
      h = bounds[3] - bounds[1]
      rotation = np.degrees(np.arctan(1 / 3 / sqrt3))
      corners = [p for p in hexagon.exterior.coords][:-1]
      hexagon = affine.rotate(hexagon, 30)
      hexes = [hexagon] + [affine.translate(
        hexagon, x * sqrt3, y * sqrt3) for x, y in corners]
      hexes = [affine.rotate(h, rotation, origin = (0, 0))
              for h in hexes]
      unit.setup_vectors((0,  h), (3*w/4,  h/2), (3*w/4, -h/2))
    case 8:
      hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
      w, h = h, w
      tr = [(-w,  3*h/4), (0,  3*h/4), ( w,  3*h/4), 
                    (-w/2, 0), ( w/2, 0),
            (-w, -3*h/4), (0, -3*h/4), ( w, -3*h/4)]
      hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
      unit.setup_vectors((w/2,  9*h/4), (3*w  ,  3*h/2), (5*w/2, -3*h/4)) 
    case 9:
      offsets = [
        (-3*w/4, -5*h/4), (0, -3*h/4), ( 3*w/4, -5*h/4),
        (-3*w/4,   -h/4), (0,    h/4), ( 3*w/4,   -h/4),
        (-3*w/4,  3*h/4), (0,  5*h/4), ( 3*w/4,  3*h/4)
      ]
      hexes = [affine.translate(hexagon, dx, dy) for dx, dy in offsets]
      unit.setup_vectors((0, 3*h), (9*w/4,  3*h/2), (9*w/4, -3*h/2)) 
    case _:
      return (f"""{unit.n}-colouring of hexes is not supported. 
              Try a number between 2 and 9.""")
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(hexes))
  return None

def setup_square_colouring(unit:TileUnit) -> None:
  """2 through 9 colourings of a regular array of squares. The supplied unit
  must have unit.n set.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if any([k not in unit.__dict__ for k in ["n"]]):
    return (f"""Square colouring tiling requires n to be supplied.""")
  sq = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 4)
  s = sq.bounds[2] - sq.bounds[0]
  match unit.n:
    case 2:
      # Copy and translate square
      tr = [(-s/2, 0), (s/2, 0)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      unit.setup_vectors((0, s), (2*s, 0)) 
    case 3:
      # Copy and translate square
      tr = [(-s/2, -s/2), (s/2, -s/2), (-s/2, s/2)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      squares = [affine.rotate(sq, 45, (0, 0)) for sq in squares]
      x = s * sqrt2
      unit.setup_vectors((0,  x), (3*x/2,  x/2), (3*x/2, -x/2)) 
    case 4:
      # Copy and translate square
      tr = [(-s/2, -s/2), (-s/2,  s/2), 
            ( s/2,  s/2), ( s/2, -s/2)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      unit.setup_vectors((0, unit.spacing), (unit.spacing, 0)) 
    case 5:
      # Copy and translate square
      tr = [( 0, 0), 
            ( s, 0), (0,  s),
            (-s, 0), (0, -s)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      rotation = np.degrees(np.arctan2(1, 2))
      squares = [affine.rotate(sq, rotation, origin = (0, 0))
                 for sq in squares]
      unit.setup_vectors((0, unit.spacing), (unit.spacing, 0)) 
    case 6:
      # Copy and translate square
      tr = [(-s, -s), (0, -s),
            (-s,  0), (0,  0), ( s,  0),
                      (0,  s)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      squares = [affine.rotate(sq, -45, origin = (0, 0)) for sq in squares]
      x = s * sqrt2
      unit.setup_vectors(( x/2,  3*x/2), (2*x,  0), (3*x/2, -3*x/2)) 
    case 7:
      # Copy and translate square
      tr = [(-s, -s), (0, -s),
            (-s,  0), (0,  0), ( s,  0),
                      (0,  s), ( s,  s)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      squares = [affine.rotate(sq, -45, (0, 0)) for sq in squares]
      x = s * sqrt2
      unit.setup_vectors(( x/2,  3*x/2), (5*x/2,  x/2), (2*x, -x)) 
    case 8:
      # Copy and translate square
      tr = [(-s, -s), (0, -s), ( s, -s),
            (-s,  0), (0,  0), ( s,  0),
            (-s,  s), (0,  s)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      squares = [affine.rotate(sq, 45, origin = (0, 0)) for sq in squares]
      x  = s * sqrt2
      unit.setup_vectors((0, 2*x), (2*x,  x), (2*x,  -x)) 
    case 9:
      # Copy and translate square
      tr = [(-s, -s), (0, -s), ( s, -s),
            (-s,  0), (0,  0), ( s,  0),
            (-s,  s), (0,  s), ( s,  s)]
      squares = [affine.translate(sq, v[0], v[1]) for v in tr]
      unit.setup_vectors((0, unit.spacing), (unit.spacing, 0)) 
    case _:
      return (f"""{unit.n}-colouring of squares is not supported. 
              Try a number between 2 and 9.""")

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(squares))
  return None

def get_corners_and_mid_points(shape:geom.Polygon, offset:float = 0.5):
  corners = [geom.Point(p) for p in shape.exterior.coords]
  midpoints = [ls.interpolate(offset, True) for ls in tiling_utils.get_sides(shape)]
  return list(itertools.chain(*[[a, b] for a, b in zip(corners, midpoints)]))

def setup_square_dissection(unit:TileUnit) -> None:
  if any(not k in unit.__dict__ for k in ["n", "offset", "offset_angle"]):
    return (f"""Square dissection tiling requires n, offset, and offset_angle
            to be be supplied.""")
  outer = tiling_utils.get_regular_polygon(unit.spacing, 4)
  inner = affine.scale(outer, 1 / np.sqrt(unit.n), 1 / np.sqrt(unit.n))
  inner = affine.rotate(inner, unit.offset_angle)
  outer_pts = get_corners_and_mid_points(outer)
  inner_pts = get_corners_and_mid_points(inner)
  outer_pts = outer_pts + outer_pts[:1]
  inner_pts = inner_pts + inner_pts[:1]
  inner_pts = inner_pts[::-1]
  match unit.n:
    case 3:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:3] + outer_pts[4:6] + inner_pts[4:9:2]),
                      #  inner_pts[3:5] + inner_pts[6:8]),
          geom.Polygon(outer_pts[5:7] + outer_pts[0:2] + inner_pts[0:5:2])]
                      #  inner_pts[7:9] + inner_pts[2:4])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:5:2] + inner_pts[4:9:2]),          
          geom.Polygon(outer_pts[4:9:2] + inner_pts[0:5:2])]
    case 5:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:4] + inner_pts[6:9:2]), #inner_pts[5:8]),
          geom.Polygon(outer_pts[3:6] + inner_pts[4:7:2]), #inner_pts[3:6]),
          geom.Polygon(outer_pts[5:8] + inner_pts[2:5:2]), #inner_pts[1:4]),
          geom.Polygon(outer_pts[7:9] + outer_pts[1:2] + inner_pts[0:3:2])] 
                      #  inner_pts[7:9] + inner_pts[1:2])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:3:2] + inner_pts[6:9:2]),
          geom.Polygon(outer_pts[2:5:2] + inner_pts[4:7:2]),
          geom.Polygon(outer_pts[4:7:2] + inner_pts[2:5:2]),
          geom.Polygon(outer_pts[6:9:2] + inner_pts[0:3:2])]
    case 9:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:3] + inner_pts[7:9]), # + inner_pts[7:9]),
          geom.Polygon(outer_pts[2:4] + inner_pts[6:8]), # + inner_pts[6:8]),
          geom.Polygon(outer_pts[3:5] + inner_pts[5:7]), # + inner_pts[5:7]),
          geom.Polygon(outer_pts[4:6] + inner_pts[3:6]), # + inner_pts[4:6]),
          geom.Polygon(outer_pts[5:7] + inner_pts[3:5]), # + inner_pts[3:5]),
          geom.Polygon(outer_pts[6:8] + inner_pts[2:4]), # + inner_pts[2:4]),
          geom.Polygon(outer_pts[7:9] + inner_pts[1:3]), # + inner_pts[1:3]),
          geom.Polygon(outer_pts[0:2] + inner_pts[0:2])] # + inner_pts[0:2])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:2] + inner_pts[7:9]),
          geom.Polygon(outer_pts[1:3] + inner_pts[6:8]),
          geom.Polygon(outer_pts[2:4] + inner_pts[5:7]),
          geom.Polygon(outer_pts[3:5] + inner_pts[4:6]),
          geom.Polygon(outer_pts[4:6] + inner_pts[3:5]),
          geom.Polygon(outer_pts[5:7] + inner_pts[2:4]),
          geom.Polygon(outer_pts[6:8] + inner_pts[1:3]),
          geom.Polygon(outer_pts[7:9] + inner_pts[0:2])]
    case _:
      unit.base_shape = TileShape.RECTANGLE
      return f"{unit.n} dissection of square not available"
  unit.setup_vectors((0, unit.spacing), (unit.spacing, 0))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(polys))
  return None

def setup_hex_dissection(unit:TileUnit):
  if any(not k in unit.__dict__ for k in ["n", "offset", "offset_angle"]):
    return (f"""Hex dissection tiling requires n, offset, and offset_angle
            to be be supplied.""")
  outer = tiling_utils.get_regular_polygon(unit.spacing, 6)
  if unit.n == 9:
    inner = affine.scale(outer, 1/np.sqrt(3), 1/np.sqrt(3))
  else:
    inner = affine.scale(outer, 1 / np.sqrt(unit.n), 1 / np.sqrt(unit.n))
  inner = affine.rotate(inner, unit.offset_angle)
  outer_pts = get_corners_and_mid_points(outer)
  inner_pts = get_corners_and_mid_points(inner)
  outer_pts = outer_pts + outer_pts[:1]
  inner_pts = inner_pts + inner_pts[:1]
  inner_pts = inner_pts[::-1]
  match unit.n:
    case 3:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:3] + outer_pts[2:7:2] + 
                       outer_pts[7:8] + inner_pts[6::2]),
          geom.Polygon(outer_pts[7:9] + outer_pts[8::2] + 
                       outer_pts[0:2] + inner_pts[0:7:2])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:7:2] + inner_pts[6::2]),          
          geom.Polygon(outer_pts[6::2]  + inner_pts[0:7:2])]
    case 4:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:3]  + outer_pts[2:5:2] + 
                       outer_pts[4:6]  + inner_pts[8::2]),
          geom.Polygon(outer_pts[5:7]  + outer_pts[6:11:2] + 
                       outer_pts[8:10] + inner_pts[4:9:2]),
          geom.Polygon(outer_pts[9:11] + outer_pts[10::2] + 
                       outer_pts[0:2]  + inner_pts[0:5:2])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:5:2] + inner_pts[8::2]),
          geom.Polygon(outer_pts[4:9:2] + inner_pts[4:9:2]),
          geom.Polygon(outer_pts[8::2]  + inner_pts[0:5:2])]
    case 7:
      polys = [inner]
      if unit.offset == 1:
        polys = polys + [
          geom.Polygon(outer_pts[1:3]  + outer_pts[2:4]   + inner_pts[10::2]),
          geom.Polygon(outer_pts[3:5]  + outer_pts[4:6]   + inner_pts[8:11:2]),
          geom.Polygon(outer_pts[5:7]  + outer_pts[6:8]   + inner_pts[6:9:2]),
          geom.Polygon(outer_pts[7:9]  + outer_pts[8:10]  + inner_pts[4:7:2]),
          geom.Polygon(outer_pts[9:11] + outer_pts[10:12] + inner_pts[2:5:2]),
          geom.Polygon(outer_pts[11:]  + outer_pts[:2]    + inner_pts[0:3:2])]
      else:
        polys = polys + [
          geom.Polygon(outer_pts[0:3:2]  + inner_pts[10::2]),
          geom.Polygon(outer_pts[2:5:2]  + inner_pts[8:11:2]),
          geom.Polygon(outer_pts[4:7:2]  + inner_pts[6:9:2]),
          geom.Polygon(outer_pts[6:9:2]  + inner_pts[4:7:2]),
          geom.Polygon(outer_pts[8:11:2] + inner_pts[2:5:2]),
          geom.Polygon(outer_pts[10::2]  + inner_pts[0:3:2])]
    case 9:
      if unit.offset == 1:
        polys = [
          geom.Polygon(inner_pts[1:3]  + inner_pts[2:5:2] + 
                       inner_pts[4:6]  + [(0, 0)]), 
          geom.Polygon(inner_pts[5:7]  + inner_pts[6:9:2] + 
                       inner_pts[8:10] + [(0, 0)]),
          geom.Polygon(inner_pts[9:11] + inner_pts[10::2] +
                       inner_pts[0:2]  + [(0, 0)]),
          geom.Polygon(outer_pts[1:3]  + outer_pts[2:4]   + inner_pts[10::2]),
          geom.Polygon(outer_pts[3:5]  + outer_pts[4:6]   + inner_pts[8:11:2]),
          geom.Polygon(outer_pts[5:7]  + outer_pts[6:8]   + inner_pts[6:9:2]),
          geom.Polygon(outer_pts[7:9]  + outer_pts[8:10]  + inner_pts[4:7:2]),
          geom.Polygon(outer_pts[9:11] + outer_pts[10:12] + inner_pts[2:5:2]),
          geom.Polygon(outer_pts[11:]  + outer_pts[:2]    + inner_pts[0:3:2])]
      else:
        polys = [
          geom.Polygon(inner_pts[0:5:2] + [(0, 0)]),
          geom.Polygon(inner_pts[4:9:2] + [(0, 0)]),
          geom.Polygon(inner_pts[8::2]  + [(0, 0)]),
          geom.Polygon(outer_pts[0:3:2]  + inner_pts[10::2]),
          geom.Polygon(outer_pts[2:5:2]  + inner_pts[8:11:2]),
          geom.Polygon(outer_pts[4:7:2]  + inner_pts[6:9:2]),
          geom.Polygon(outer_pts[6:9:2]  + inner_pts[4:7:2]),
          geom.Polygon(outer_pts[8:11:2] + inner_pts[2:5:2]),
          geom.Polygon(outer_pts[10::2]  + inner_pts[0:3:2])]
    case _:
      unit.base_shape = TileShape.HEXAGON
      return f"{unit.n} dissection of hexagon not available"
  unit.setup_vectors((0, unit.spacing), 
                     (unit.spacing * sqrt3/2, unit.spacing / 2),
                     (unit.spacing * sqrt3/2, -unit.spacing / 2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(polys))
  return None

def get_regular_polygon_from_one_side(
    side:geom.LineString, 
    n:int):
  points = list(side.coords)
  turn_angle = np.pi - 2 * np.pi / n
  for i in range(1, n):
    points.append(
      affine.rotate(geom.Point(points[-2]), 
                    turn_angle, origin = points[-1], 
                    use_radians = True))
  return geom.Polygon(points[1:])

def get_n_star_n_poly(
    spacing:float, 
    n_star:int, 
    n_poly:int,
    point_angle:float):
  pt_angle = np.radians(point_angle)
  hp = spacing * (np.cos(pt_angle / 2) + 
                  np.sin(pt_angle / 2) / np.tan(np.pi / n_star))
  hd = spacing * np.sin(pt_angle / 2) / np.sin(np.pi / n_star)
  interior_angles = np.linspace(0, 2 * np.pi, 
                                2 * n_star, endpoint = False)
  tips = [geom.Point(hp * np.cos(a), hp * np.sin(a)) 
          for a in interior_angles[::2]]
  dents = [geom.Point(hd * np.cos(a), hd * np.sin(a)) 
             for a in interior_angles[1::2]]
  star = geom.Polygon(
    [p for p in itertools.chain(*zip(tips, dents))])
  star_sides = tiling_utils.get_sides(star)
  polys = [get_regular_polygon_from_one_side(star_sides[0], n_poly)]
  if n_poly == 3 and n_star == 3:
    polys.append(get_regular_polygon_from_one_side(star_sides[5], n_poly))
  elif n_poly == 3 and n_star == 6:
    polys.append(get_regular_polygon_from_one_side(star_sides[6], n_poly))
  stars = [star]
  if n_poly == 6 and n_star == 3:
    c = polys[0].centroid
    stars.append(affine.rotate(star, 180, origin = c))
    polys = [affine.translate(p, -c.x, -c.y) for p in polys]
    stars = [affine.translate(p, -c.x, -c.y) for p in stars]
  return stars + polys          

def setup_star_polygon(unit:TileUnit):
  if any(not k in unit.__dict__ for k in ["code", "point_angle"]):
    return (f"""Star tiling requires code and point_angle
            to be be supplied.""")
  match unit.code:
    case "33":
      unit.base_shape = TileShape.HEXAGON
      polys = get_n_star_n_poly(unit.spacing, 3, 3, unit.point_angle)
    case "36":
      unit.base_shape = TileShape.HEXAGON
      polys = get_n_star_n_poly(unit.spacing, 3, 6, unit.point_angle)
    case "44":
      unit.base_shape = TileShape.RECTANGLE
      polys = get_n_star_n_poly(unit.spacing, 4, 4, unit.point_angle)
    case "63":
      unit.base_shape = TileShape.HEXAGON
      polys = get_n_star_n_poly(unit.spacing, 6, 3, unit.point_angle)
    case _:
      return f"Invalid code supplied for star tiling"
  star = polys[0]
  tips = [p for p in star.exterior.coords][0::2]
  dents = [p for p in star.exterior.coords][1::2]
  match unit.code:
    case "33":
      v1 = geom.Point(dents[0][0] - tips[2][0], dents[0][1] - tips[2][1])
      v2 = affine.rotate(v1, -60, (0, 0))
      v3 = affine.rotate(v2, -60, (0, 0))
      unit.setup_vectors((v1.x, v1.y), (v2.x, v2.y), (v3.x, v3.y))
    case "36":
      pts = [p for p in polys[2].exterior.coords]
      dents2 = [p for p in polys[1].exterior.coords][1::2]
      v1 = geom.Point(dents2[2][0] - tips[0][0], dents2[2][1] - tips[0][1])
      v2 = affine.rotate(v1, -60, (0, 0))
      v3 = affine.rotate(v2, -60, (0, 0))
      unit.setup_vectors((v1.x, v1.y), (v2.x, v2.y), (v3.x, v3.y))
    case "44":
      v1 = geom.Point(tips[0][0] - dents[1][0], tips[0][1] - dents[1][1])
      v2 = affine.rotate(v1, -90, (0, 0))
      unit.setup_vectors((v1.x, v1.y), (v2.x, v2.y))
    case "63":
      hex = polys[2]
      pts = [p for p in hex.exterior.coords]
      dents2 = [p for p in polys[1].exterior.coords][1::2]
      v1 = geom.Point(dents[0][0] - tips[4][0], dents[0][1] - tips[4][1])
      v2 = affine.rotate(v1, -60, (0, 0))
      v3 = affine.rotate(v2, -60, (0, 0))
      unit.setup_vectors((v1.x, v1.y), (v2.x, v2.y), (v3.x, v3.y))

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:len(polys)]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(polys))
  return None


# def setup_hex_dissection(unit:TileUnit) -> None:
#   """Tilings from dissection of a hexagon into parts. Only 3 options are
#   supported, 4, 7, and 9, and each is handled in its own function.

#   The supplied unit should have offset and n set. In this case offset is an
#   int either 0 or 1

#   unit.offset == 1 starts at midpoints, 0 at hexagon corners
#   unit.n is the number of parts to the dissection and should be 4, 7, or 9.

#   Args:
#     unit (TileUnit):  the TileUnit to setup.
#   """
#   if any([k not in unit.__dict__ for k in ["n", "offset"]]):
#     return (f"""Hex dissection tiling requires n and offset to be supplied.""")
#   match unit.n:
#     case 4:
#       parts = get_4_parts_of_hexagon(unit)
#     case 7:
#       parts = get_7_parts_of_hexagon(unit)
#     case 9:
#       parts = get_9_parts_of_hexagon(unit)
#     case _:
#       unit.base_shape = TileShape.HEXAGON
#       return  (f"""a {unit.n} hex-dissection is not implemented. 
#                Try 4, 7, or 9 elements instead.""")
#   unit.setup_vectors((                            0,  unit.spacing    ), 
#                      (unit.spacing * sqrt3/2,  unit.spacing / 2),
#                      (unit.spacing * sqrt3/2, -unit.spacing / 2))
#   unit.tiles = gpd.GeoDataFrame(
#     data = {"tile_id": list(string.ascii_letters)[:unit.n]},
#     crs = unit.crs,
#     geometry = gpd.GeoSeries(parts))
#   return None

# def get_4_parts_of_hexagon(unit: TileUnit) -> list[geom.Polygon]:
#   """Returns 4 pieces that together compose the hexagon in the supplied 
#   TileUnit.

#   Args:
#     unit (TileUnit): the TileUnit containing the hexagon.

#   Returns:
#     list[geom.Polygon]: a list of 4 geom.Polygon parts of the original
#       hexagon
#   """
#   outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
#   inner_h = affine.scale(outer_h, 0.5, 0.5)
#   if unit.offset == 1:
#     inner_h = affine.rotate(inner_h, 30, (0, 0))
#   o_hx = tiling_utils.get_corners(outer_h)
#   i_hx = tiling_utils.get_corners(inner_h)
#   if unit.offset == 1:
#     o = []
#     for p1, p2 in zip(o_hx[:-1], o_hx[1:]):
#       o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
#     return [
#       inner_h,
#       geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o[11], o[0], o[2], o[3]]),
#       geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o[3], o[4], o[6], o[7]]),
#       geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o[7], o[8], o[10], o[11]])
#     ]
#   else:
#     return [
#       inner_h,
#       geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o_hx[0], o_hx[1], o_hx[2]]),
#       geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o_hx[2], o_hx[3], o_hx[4]]),
#       geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o_hx[4], o_hx[5], o_hx[0]])
#     ]

# def get_7_parts_of_hexagon(unit: TileUnit) -> list[geom.Polygon]:
#   """Returns 7 pieces that together compose the hexagon in the supplied 
#   TileUnit.

#   Args:
#     unit (TileUnit): the TileUnit containing the hexagon.

#   Returns:
#     list[geom.Polygon]: a list of 7 geom.Polygon parts of the original
#       hexagon
#   """
#   outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
#   inner_h = affine.scale(outer_h, 1/np.sqrt(7), 1/np.sqrt(7))
#   if unit.offset == 1:
#     inner_h = affine.rotate(inner_h, 30, (0, 0))
#   outer = tiling_utils.get_corners(outer_h)
#   inner = tiling_utils.get_corners(inner_h)
#   if unit.offset == 1:
#     o = []
#     for p1, p2 in zip(outer[:-1], outer[1:]):
#       o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
#     i = []
#     for p1, p2 in zip(inner[:-1], inner[1:]):
#       i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
#     return [
#       inner_h,
#       geom.Polygon([i[2], i[0], o[11], o[0], o[1]]),
#       geom.Polygon([i[4], i[2]] + o[1:4]),
#       geom.Polygon([i[6], i[4]] + o[3:6]),
#       geom.Polygon([i[8], i[6]] + o[5:8]),
#       geom.Polygon([i[10], i[8]] + o[7:10]),
#       geom.Polygon([i[0], i[10]] + o[9:])
#     ]
#   else:
#     return [
#       inner_h,
#       geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
#       geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
#       geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
#       geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
#       geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
#       geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
#     ]

# def get_9_parts_of_hexagon(unit: TileUnit) -> list[geom.Polygon]:
#   """Returns 9 pieces that together compose the hexagon in the supplied 
#   TileUnit.

#   Args:
#     unit (TileUnit): the TileUnit containing the hexagon.

#   Returns:
#     list[geom.Polygon]: a list of 9 geom.Polygon parts of the original
#       hexagon
#   """
#   c = geom.Point(0, 0)
#   outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
#   inner_h = affine.scale(outer_h, 1/sqrt3, 1/sqrt3)
#   # if unit.offset == 1:
#   #   inner_h = tiling_utils.rotate_preserving_order(inner_h, 30, (0, 0))
#   inner_h = tiling_utils.rotate_preserving_order(inner_h, 
#                                                  30 * unit.offset, (0, 0))
#   outer = tiling_utils.get_corners(outer_h)
#   inner = tiling_utils.get_corners(inner_h)
#   if unit.offset == 1:
#     o = []
#     for p1, p2 in zip(outer[:-1], outer[1:]):
#       o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
#     i = []
#     for p1, p2 in zip(inner[:-1], inner[1:]):
#       i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
#     return [
#       geom.Polygon([c, i[1], i[2], i[4], i[5]]),
#       geom.Polygon([c, i[5], i[6], i[8], i[9]]),
#       geom.Polygon([c, i[9], i[10], i[0], i[1]]),
#       geom.Polygon([o[0], o[1], i[2], i[0], o[11]]),
#       geom.Polygon([o[2], o[3], i[4], i[2], o[1]]),
#       geom.Polygon([o[4], o[5], i[6], i[4], o[3]]),
#       geom.Polygon([o[6], o[7], i[8], i[6], o[5]]),
#       geom.Polygon([o[8], o[9], i[10], i[8], o[7]]),
#       geom.Polygon([o[10], o[11], i[0], i[10], o[9]])
#     ]
#   else:
#     return [
#       geom.Polygon([c, inner[0], inner[1], inner[2]]),
#       geom.Polygon([c, inner[2], inner[3], inner[4]]),
#       geom.Polygon([c, inner[4], inner[5], inner[0]]),
#       geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
#       geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
#       geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
#       geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
#       geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
#       geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
#     ]
