#!/usr/bin/env python
# coding: utf-8

"""Functions for setting up a `weavingspace.tile_unit.TileUnit` with various
tile geometries. Some care is required in adding new functions that use
exisitng ones to get the sequence of setup operations right. Modify with care!

The available tilings can be viewed on [this page](https://dosull.github.io/weaving-space/tiling-explorer/).

These tilings (and many many more!) are discussed in

Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H. Freeman and
Company, New York)

A more accessible introduction is

Kaplan C S, 2002 _Computer Graphics and Geometric Ornamental Design_, PhD
thesis, University of Washington, Seattle, WA, 
https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf

and a more 'polished' version of that work focused on computer graphics is also
available

Kaplan C S, 2009 _Introductory tiling theory for computer graphics_ (Morgan &
Claypool)
"""

from typing import TYPE_CHECKING
import copy
import itertools
import string
import math

import geopandas as gpd
import numpy as np
import shapely.geometry as geom
import shapely.affinity as affine
from shapely import line_interpolate_point

# from weavingspace.tileable import TileShape
# import weavingspace.tiling_utils as tiling_utils

from weavingspace import TileShape
from weavingspace import tiling_utils

def _setup_none_tile(unit:"TileUnit") -> None:
  """Setups a 'null' tile unit with one tile and one tile_id.

  Args:
    unit (TileUnit): the TileUnit to setup.
  """
  _setup_base_tile(unit, unit.base_shape)
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": ["a"]}, crs = unit.crs,
    geometry = copy.deepcopy(unit.prototile.geometry))
  return


def _setup_base_tile(unit:"TileUnit", shape:TileShape) -> None:
  """_summary_

  Args:
    unit (TileUnit):  the TileUnit to setup.
    shape (TileShape): the TileShape to apply.
  """
  unit.base_shape = shape
  if unit.base_shape == TileShape.DIAMOND:
    tile = tiling_utils.gridify(geom.Polygon([
      (unit.spacing / 2, 0), (0, unit.spacing * np.sqrt(3) / 2),
      (-unit.spacing / 2, 0), (0, -unit.spacing * np.sqrt(3) / 2)]))
  else:
    tile = tiling_utils.get_regular_polygon(
      unit.spacing, n = (4
              if unit.base_shape in (TileShape.RECTANGLE, )
              else (6
                if unit.base_shape in (TileShape.HEXAGON, )
                else 3)))
  unit.prototile = gpd.GeoDataFrame(
    geometry = gpd.GeoSeries([tile]), crs = unit.crs)
  unit.setup_vectors()
  return


def setup_cairo(unit:"TileUnit") -> None:
  """Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.
  This code shows how a 'handcoded' set of geometries can be applied.

  Note that it is advisable to avoid intersection and union operations where
  possible, as it often yields floating point mismatches that can be hard
  to repair! (This tiling can be relatively conveniently generated by
  dissecting a square in 4 quarters at a 30 degree angle to the sides and
  then reflecting and rotating copies and joing them back together. But
  floating point issues make that very messy indeed. Much better to make
  the geometries 'pure'.)

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.RECTANGLE)  # a square
  d = unit.spacing
  x = d/2 / (np.cos(np.radians(15)) + np.cos(np.radians(75)))
  # the following is just the geometry, it is what it is...
  # points are (more or less)
  #
  #         3
  #     2
  #            4
  #     1    0
  #
  # then rotate -15 and make 4 copies at 90 degree rotations
  p1 = geom.Polygon([(x, 0), (0, 0), (0, x),
             (x * np.sqrt(3) / 2, x + x/2),
             (x * (1 + np.sqrt(3)) / 2, x * (3 - np.sqrt(3)) / 2)])
  p1 = affine.rotate(p1, -15, (0, 0))
  p2 = affine.rotate(p1, 90, (0, 0))
  p3 = affine.rotate(p1, 180, (0, 0))
  p4 = affine.rotate(p1, 270, (0, 0))

  # now move them so they are arranged as a hexagon centered on the tile
  p1 = affine.translate(p1, -unit.spacing / 2, 0)
  p2 = affine.translate(p2, unit.spacing / 2, 0)
  p3 = affine.translate(p3, unit.spacing / 2, 0)
  p4 = affine.translate(p4, -unit.spacing / 2, 0)

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcd")}, crs = unit.crs,
    geometry = gpd.GeoSeries([p1, p2, p3, p4]))
  unit.setup_regularised_prototile_from_tiles()


def setup_hex_slice(unit:"TileUnit") -> None:
  """Arbitrary number of radial slices of a hexagon, with an optional
  offset starting point.

  The supplied unit should have offset and n set.

  Places unit.n points equally spaced around the perimeter of the hexagon.
  Slices are formed by connecting some sequence of these points (and any
  intervening hexagon corners) and the hexagon centre to form a pie slice.
  unit.offset = 0 starts from corner 0. unit.offset starts half way between
  corner 0 and corner 1. Other values of unit.offset scale linear between
  these.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.HEXAGON)
  hexagon = tiling_utils.get_regular_polygon(unit.spacing, 6)
  slices = _get_radially_sliced_polygon(hexagon, 6, unit.n, unit.offset)
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(slices))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)


def setup_square_slice(unit:"TileUnit") -> None:
  """Arbitrary number of radial slices of a square, with an optional
  offset starting point.

  The supplied unit should have offset and n set.

  Places unit.n points equally spaced around the perimeter of the square.
  Slices are formed by connecting some sequence of these points (and any
  intervening squares corners) and the square centre to form a pie slice.
  unit.offset = 0 starts from corner 0. unit.offset starts half way between
  corner 0 and corner 1. Other values of unit.offset scale linear between
  these.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.RECTANGLE)
  square = tiling_utils.get_regular_polygon(unit.spacing, 4)
  slices = _get_radially_sliced_polygon(square, 4, unit.n, unit.offset)
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(slices))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)


def _get_radially_sliced_polygon(shape:geom.Polygon, n_sides:int,
                                 n_slices:int, offset:float):
  boundary = geom.LineString(shape.exterior.coords)
  print(f'{n_sides=} {n_slices=} {offset=}')
  offset = (offset % 1 
            if offset < 0 or offset > 1 
            else offset)
  offset = (offset * n_sides / n_slices / 2 
            if n_slices >= n_sides
            else offset / 2)
  along = [n_sides * _ / n_slices + offset for _ in range(n_slices)]
  along = along + [n_sides + along[0]]
  points = [line_interpolate_point(boundary, (a % n_sides) / n_sides, 
                                    normalized = True) for a in along]
  corners = [line_interpolate_point(boundary, i / n_sides, normalized = True) 
              for i in range(n_sides + 1)]  
  slices = []
  for a1, a2, p1, p2 in zip(along[:-1], along[1:], points[:-1], points[1:]):
    if math.floor(a1) == math.floor(a2):
      slices.append(geom.Polygon([p1, p2, (0, 0)]))
    else:
      missed_corners = corners[math.ceil(a1):math.ceil(a2)]
      slices.append(geom.Polygon([p1] + missed_corners + [p2, (0, 0)]))
  return gpd.GeoSeries(slices)


def setup_hex_dissection(unit:"TileUnit") -> None:
  """Tilings from dissection of a hexagon into parts.

  The supplied unit should have offset and n set.

  self.offset == 1 starts at midpoints, 0 at hexagon corners
  self.n is the number of slices and should be 2, 3, 4, 6 or 12.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.HEXAGON)
  if unit.n == 4:
    parts = get_4_parts_of_hexagon(unit)
  elif unit.n == 7:
    parts = get_7_parts_of_hexagon(unit)
  elif unit.n == 9:
    parts = get_9_parts_of_hexagon(unit)
  else:
    print(f"a [{unit.n}] hex-dissection is not implemented.")
    _setup_none_tile(unit)
    return
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(parts))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)


def get_4_parts_of_hexagon(unit: "TileUnit") -> list[geom.Polygon]:
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(3), 1/np.sqrt(3))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  o_hx = tiling_utils.get_corners(outer_h)
  i_hx = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(o_hx[:-1], o_hx[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      inner_h,
      geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o[11], o[0], o[2], o[3]]),
      geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o[3], o[4], o[6], o[7]]),
      geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o[7], o[8], o[10], o[11]])
    ]
  else:
    return [
      inner_h,
      geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o_hx[0], o_hx[1], o_hx[2]]),
      geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o_hx[2], o_hx[3], o_hx[4]]),
      geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o_hx[4], o_hx[5], o_hx[0]])
    ]


def get_7_parts_of_hexagon(unit: "TileUnit") -> list[geom.Polygon]:
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(7), 1/np.sqrt(7))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  outer = tiling_utils.get_corners(outer_h)
  inner = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(outer[:-1], outer[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    i = []
    for p1, p2 in zip(inner[:-1], inner[1:]):
      i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      inner_h,
      geom.Polygon([i[2], i[0], o[11], o[0], o[1]]),
      geom.Polygon([i[4], i[2]] + o[1:4]),
      geom.Polygon([i[6], i[4]] + o[3:6]),
      geom.Polygon([i[8], i[6]] + o[5:8]),
      geom.Polygon([i[10], i[8]] + o[7:10]),
      geom.Polygon([i[0], i[10]] + o[9:])
    ]
  else:
    return [
      inner_h,
      geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
      geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
      geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
      geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
      geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
      geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
    ]


def get_9_parts_of_hexagon(unit: "TileUnit") -> list[geom.Polygon]:
  c = geom.Point(0, 0)
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(3), 1/np.sqrt(3))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  outer = tiling_utils.get_corners(outer_h)
  inner = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(outer[:-1], outer[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    i = []
    for p1, p2 in zip(inner[:-1], inner[1:]):
      i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      geom.Polygon([c, i[1], i[2], i[4], i[5]]),
      geom.Polygon([c, i[5], i[6], i[8], i[9]]),
      geom.Polygon([c, i[9], i[10], i[0], i[1]]),
      geom.Polygon([o[0], o[1], i[2], i[0], o[11]]),
      geom.Polygon([o[2], o[3], i[4], i[2], o[1]]),
      geom.Polygon([o[4], o[5], i[6], i[4], o[3]]),
      geom.Polygon([o[6], o[7], i[8], i[6], o[5]]),
      geom.Polygon([o[8], o[9], i[10], i[8], o[7]]),
      geom.Polygon([o[10], o[11], i[0], i[10], o[9]])
    ]
  else:
    return [
      geom.Polygon([c, inner[0], inner[1], inner[2]]),
      geom.Polygon([c, inner[2], inner[3], inner[4]]),
      geom.Polygon([c, inner[4], inner[5], inner[0]]),
      geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
      geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
      geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
      geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
      geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
      geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
    ]


def setup_crosses(unit:"TileUnit") -> None:
  """Tilings by varying numbers of crosses.

  The supplied unit should have n set.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.RECTANGLE)
  square = tiling_utils.get_regular_polygon(unit.spacing, 4)
  x = unit.spacing / unit.n
  cross = geom.Polygon([
      (-x/2, -x/2), (-3 * x/2, -x/2), (-3 * x/2,  x/2), 
      (-x/2,  x/2), (-x/2,  3 * x/2), ( x/2,  3 * x/2), 
      ( x/2,  x/2), ( 3 * x/2,  x/2), ( 3 * x/2, -x/2), 
      ( x/2, -x/2), ( x/2, -3 * x/2), (-x/2, -3 * x/2)])
  if unit.n == 2:
    tr = [(-x/2, -x), (x/2, x)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-3 * x, -x), (-x, 3 * x)])]
  elif unit.n == 3:
    tr = [(-3 * x/2, -x), (-x/2, x), (3 * x/2, 0)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-4 * x, -3 * x), (-5 * x, 0), (-x,  3 * x)])]
  elif unit.n == 4:
    tr = [(3 * x/2, x/2), (x/2, -3 * x/2), (-3 * x/2, -x/2), (-x/2, 3 * x/2)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-4 * x, -3 * x), (-4 * x,  2 * x), (0,  5 * x)])]
  elif unit.n == 5:
    tr = [(0, 0), (x, 2 * x), (2 * x, -x), (-x, -2 * x), (-2 * x, x)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-5 * x, 0), (0,  5 * x)])]
  elif unit.n == 6:
    tr = [(-2 * x, -3 * x/2), (-x,  x/2), (0,  5 * x/2), 
          ( 2 * x,  3 * x/2), ( x, -x/2), (0, -5 * x/2)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-3 * x, -6 * x), (-5 * x, 0), (-2 * x,  6 * x)])]
  elif unit.n == 7:
    tr = [(0, 0), (-x, -2 * x), (-2 * x,  x), (-x,  3 * x), 
                  ( x,  2 * x), ( 2 * x, -x), ( x, -3 * x)]
    parts = [affine.translate(cross, dx, dy) for dx, dy in tr]
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-4 * x, -3 * x), (-5 * x,  5 * x), (-x,  8 * x)])]
  else:
    print(f"a [{unit.n}] square-dissection is not implemented.")
    _setup_none_tile(unit)
    return
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(parts))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)


def setup_laves(unit:"TileUnit") -> None:
  """The Laves tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.

  These are all isohedral, but mostly not regular polygons. We
  prioritise them over the Archimedean tilings because being
  isohedral all tiles are the same size. Several are hex
  dissections and setup is delegated accordingly.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if unit.code == "3.3.3.3.3.3":
    # this is the regular hexagons
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return
  if unit.code == "3.3.3.3.6":
    # this one needs its own code
    _setup_laves_33336(unit)
    return
  elif unit.code == "3.3.3.4.4":
    print(f"The code [{unit.code}] is unsupported.")
  elif unit.code == "3.3.4.3.4":
    # king of tilings!
    setup_cairo(unit)
    return
  elif unit.code == "3.4.6.4":
    # the hex 6-dissection
    unit.n = 6
    unit.offset = 1
    setup_hex_slice(unit)
    return
  elif unit.code == "3.6.3.6":
    # hex 3-dissection (also a cube weave!)
    unit.n = 3
    unit.offset = 0
    setup_hex_slice(unit)
    return
  elif unit.code == "3.12.12":
    # again this one needs its own
    _setup_laves_31212(unit)
    return
  elif unit.code == "4.4.4.4":
    # square grid
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return
  elif unit.code == "4.6.12":
    # hex 12-dissection
    unit.n = 12
    unit.offset = 0
    setup_hex_slice(unit)
    return
  elif unit.code == "4.8.8":
    # this one needs its own (a 4-dissection of the square)
    # perhaps to be added as a category later...
    _setup_laves_488(unit)
    return
  elif unit.code == "6.6.6":
    # triangles
    _setup_base_tile(unit, TileShape.TRIANGLE)
    _setup_none_tile(unit)
  else:
    print(f"[{unit.code}] is not a valid Laves code.")

  unit.tiling_type = None
  _setup_none_tile(unit)
  return


def _setup_laves_33336(unit:"TileUnit") -> None:
  """Sets up Laves [3.3.3.3.6] which is like a 6 petal flower.

  Similar to the H3 7 hexagon group with the central hex removed and each
  hex 'taking' a 1/6 share of the central hex.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.HEXAGON)
  offset_a = np.degrees(np.arctan(1 / 3 / np.sqrt(3)))
  sf = 1 / np.sqrt(7)
  tile = tiling_utils.get_regular_polygon(unit.spacing, 6)
  hexagon = affine.scale(tile, sf, sf)
  # translate it up by its own height
  hexagon = affine.translate(hexagon, 0, hexagon.bounds[3] - hexagon.bounds[1])
  hex_p = [p for p in hexagon.exterior.coords]
  # now replace first and last points by (0, 0)
  # (note shapely doesn't require closure of the polygon)
  petal = geom.Polygon([(0, 0)] + hex_p[1:5])
  petals = [
    tiling_utils.gridify(affine.rotate(petal, a + offset_a, origin = (0, 0)))
    for a in range(30, 360, 60)]
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")},
    crs = unit.crs,
    geometry = gpd.GeoSeries(petals))
  unit.setup_regularised_prototile_from_tiles()


def _setup_laves_488(unit:"TileUnit") -> None:
  """The 4-dissection of the square by its diagonals.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.RECTANGLE)
  tile = tiling_utils.get_regular_polygon(unit.spacing, 4)
  pts = [p for p in tile.exterior.coords]
  tris = [geom.Polygon([pts[i], pts[i+1], (0, 0)]) for i in range(4)]
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcd")},
    crs = unit.crs,
    geometry = gpd.GeoSeries(tris))
  unit.setup_regularised_prototile_from_tiles()


def _setup_laves_31212(unit:"TileUnit") -> None:
  """This is also a hexagon dissection... like 3.6.3.6 with each rhombus
  sliced in half along its long diagonal.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.HEXAGON)
  hexagon = tiling_utils.get_regular_polygon(unit.spacing, 6)
  pts = [p for p in hexagon.exterior.coords]
  tri1 = geom.Polygon([pts[0], pts[2], [0, 0]])
  tri2 = geom.Polygon([pts[0], pts[1], pts[2]])
  tris1 = [affine.rotate(tri1, a, origin = (0, 0))
       for a in range(0, 360, 120)]
  tris2 = [affine.rotate(tri2, a, origin = (0, 0))
       for a in range(0, 360, 120)]
  # reorder so the 'inner' and 'outer' triangles are labelled alternately
  tris = itertools.chain(*zip(tris1, tris2))
  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")}, crs = unit.crs,
    geometry = gpd.GeoSeries(tris)
  )
  unit.regularised_prototile = copy.deepcopy(unit.prototile)


def setup_archimedean(unit:"TileUnit") -> None:
  """The Archimedean 'regular tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane

  Many of these are most easily constructed as duals of the Laves tilings.

  Some are not yet implemented:

  (3.3.3.4.4) is kind of weird (stripes of triangles and squares) so can't be
  bothered with it. Perhaps as a 5-variable option we'll get to it in time.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  if unit.code == "3.3.3.3.3.3":
    _setup_base_tile(unit, TileShape.TRIANGLE)
    _setup_none_tile(unit)
    return
  if unit.code == "3.3.3.3.6":
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "3.3.3.4.4":
    print(f"The code [{unit.code}] is unsupported.")
  elif unit.code == "3.3.4.3.4":
    # this is an attractive 6-colourable triangles and squares tiling
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "3.4.6.4":
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "3.6.3.6":
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "3.12.12":
    # nice! we can make dodecagons without having to think too hard
    # simply use the dual code. (Although really... it probably
    # would've been easier to make the dodecagon... other than
    # calculating the scale relative to the hexagon base tile!)
    setup_laves(unit)
    unit.setup_vectors()
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "4.4.4.4":
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return
  elif unit.code == "4.6.12":
    # more dodecagons for free!
    setup_laves(unit)
    unit.setup_vectors()
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "4.8.8":
    # this is the octagon and square tiling
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == "6.6.6":
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return
  else:
    print(f"[{unit.code}] is not a valid Laves code.")

  unit.tiling_type = None
  _setup_none_tile(unit)
  return


def _setup_archimedean_3464(unit:"TileUnit") -> None:
  """The dual of Laves 3.4.6.4 is not accurately rendered
  by our code, so we do this one by hand.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  _setup_base_tile(unit, TileShape.HEXAGON)
  sf = np.sqrt(3) / (1 + np.sqrt(3))
  hexagon = tiling_utils.get_regular_polygon(unit.spacing * sf, 6)
  corners = [p for p in hexagon.exterior.coords]
  p1 = corners[1]
  p2 = corners[0]
  #   HEX   p1
  #        /    p4
  #    ---p2   /
  #           p3
  dx, dy = p2[0] - p1[0], p2[1] - p1[1]
  p3 = (p2[0] - dy, p2[1] + dx)
  p4 = (p3[0] - dx, p3[1] - dy)
  square1 = geom.Polygon([p1, p2, p3, p4])
  square2 = affine.rotate(square1, 60, (0, 0))
  square3 = affine.rotate(square2, 60, (0, 0))
  p5 = [pt for pt in square2.exterior.coords][2]
  tri1 = geom.Polygon([p1, p4, p5])
  tri2 = affine.rotate(tri1, 60, (0, 0))

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list("abcdef")},
    crs = unit.crs,
    geometry = gpd.GeoSeries([hexagon, square1, square2, square3, tri1, tri2]))
  unit.setup_regularised_prototile_from_tiles()


def setup_hex_colouring(unit:"TileUnit") -> None:
  """2 through 9 colourings of a regular array of hexagons.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  hexagon = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 6)
  w = hexagon.bounds[2] - hexagon.bounds[0]
  h = hexagon.bounds[3] - hexagon.bounds[1]
  if unit.n == 2:
    # Pair of point up hexes sideways displace by width of a hex
    # Vectors are rectangular
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    w, h = h, w
    hexes = [affine.translate(hexagon, dx, 0) for dx in [-w/2, w/2]]
    _setup_base_tile(unit, TileShape.RECTANGLE)
    unit.prototile.geometry = [geom.Polygon([
      (-5 * w/4, -3 * h/8), (-3 * w/4,  3 * h/8), 
      ( 5 * w/4,  3 * h/8), ( 3 * w/4, -3 * h/8)
    ])]
  elif unit.n == 3:
    # Point up hex at '*' displaced to 3 positions:
    #      2
    #      *
    #    3   1
    _setup_base_tile(unit, TileShape.HEXAGON)
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    # Copy and translate to alternate corners
    corners = [p for i, p in enumerate(hexagon.exterior.coords)
           if i in (0, 2, 4)]
    hexes = [affine.translate(hexagon, p[0], p[1]) for p in corners]
  elif unit.n == 4:
    # Point up hex at '*' displaced to 4 positions:
    #      2
    #     3*1
    #      4
    _setup_base_tile(unit, TileShape.DIAMOND)
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    hex1 = affine.translate(hexagon, unit.spacing / 4, 0)
    hex2 = affine.translate(hexagon, 0, unit.spacing * np.sqrt(3) / 4)
    hex3 = affine.translate(hexagon, -unit.spacing / 4, 0)
    hex4 = affine.translate(hexagon, 0, -unit.spacing * np.sqrt(3) / 4)
    hexes = [hex1, hex2, hex3, hex4]
  elif unit.n == 4:
    # Point up hex at '*' displaced to 4 positions:
    #      2
    #     3*1
    #      4
    _setup_base_tile(unit, TileShape.DIAMOND)
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    hex1 = affine.translate(hexagon, unit.spacing / 4, 0)
    hex2 = affine.translate(hexagon, 0, unit.spacing * np.sqrt(3) / 4)
    hex3 = affine.translate(hexagon, -unit.spacing / 4, 0)
    hex4 = affine.translate(hexagon, 0, -unit.spacing * np.sqrt(3) / 4)
    hexes = [hex1, hex2, hex3, hex4]
  elif unit.n == 5:
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    w, h = h, w
    tr = [(-w, h/4), (0, h/4), ( w, h/4), 
          (-w/2, -h/2), (w/2, -h/2)]
    hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.HEXAGON)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(0,  3 *  h/2), ( 5 * w/2,  3 * h/4), ( 5 * w/2, -3 * h/4)])]
  elif unit.n == 6:
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    w, h = h, w
    tr = [(-5 * w/4,  3 * h/8), (-w/4,  3 * h/8), (3 * w/4,  3 * h/8), 
          (-3 * w/4, -3 * h/8), ( w/4, -3 * h/8), (5 * w/4, -3 * h/8)]
    hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.RECTANGLE)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-3 * w,  0), (0, -3 * h/2)])]
  elif unit.n == 7:  # the 'H3' tile
    # Make a hexagon and displace in the direction of its
    # own 6 corners, scaled as needed
    _setup_base_tile(unit, TileShape.HEXAGON)
    rotation = np.degrees(np.arctan(1 / 3 / np.sqrt(3)))
    corners = [p for p in hexagon.exterior.coords][:-1]
    hexagon = affine.rotate(hexagon, 30)
    hexes = [hexagon] + [affine.translate(
      hexagon, x * np.sqrt(3), y * np.sqrt(3)) for x, y in corners]
    hexes = [affine.rotate(h, rotation, origin = (0, 0))
             for h in hexes]
  elif unit.n == 8:
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    w, h = h, w
    tr = [(-w,  3 * h/4), (0,  3 * h/4), ( w,  3 * h/4), 
                       (-w/2, 0), ( w/2, 0),
          (-w, -3 * h/4), (0, -3 * h/4), ( w, -3 * h/4)]
    hexes = [affine.translate(hexagon, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.HEXAGON)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-w/2, -9 *  h/4), (-3 * w, -3 * h/2), (-5 * w/2,  3 * h/4)])]
  elif unit.n == 9:
    _setup_base_tile(unit, TileShape.HEXAGON)
    offsets = [
      (-3 * w/4, -5 * h/4), (0, -3 * h/4), ( 3 * w/4, -5 * h/4),
      (-3 * w/4,     -h/4), (0,      h/4), ( 3 * w/4,     -h/4),
      (-3 * w/4,  3 * h/4), (0,  5 * h/4), ( 3 * w/4,  3 * h/4)
    ]
    hexes = [affine.translate(hexagon, dx, dy) for dx, dy in offsets]
  else:
    print(f"{unit.n}-colouring of hexes is not supported.\nTry 2, 3, 4, 7, or 9.")
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(hexes))
  unit.setup_regularised_prototile_from_tiles()


def setup_square_colouring(unit:"TileUnit") -> None:
  """2 through 9 colourings of a regular array of squares.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  """
  sq = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 4)
  s = sq.bounds[2] - sq.bounds[0]
  if unit.n == 2:
    # Copy and translate square
    tr = [(-s/2, 0), (s/2, 0)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.RECTANGLE)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-2 * s, 0), (0, -s)])]
  elif unit.n == 3:
    # Copy and translate square
    tr = [(-s/2, -s/2), (s/2, -s/2), (-s/2, s/2)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    squares = [affine.rotate(sq, 45, (0, 0)) for sq in squares]
    _setup_base_tile(unit, TileShape.HEXAGON)
    x = s * np.sqrt(2)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(0, -x), (-3 * x/2, -x/2), (-3 * x/2,  x/2)])]
  elif unit.n == 4:
    # Copy and translate square
    tr = [(-s/2, -s/2), (-s/2,  s/2), 
          ( s/2,  s/2), ( s/2, -s/2)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.RECTANGLE)
  elif unit.n == 5:
    _setup_base_tile(unit, TileShape.RECTANGLE)
    # Copy and translate square
    tr = [( 0, 0), 
          ( s, 0), (0,  s),
          (-s, 0), (0, -s)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    rotation = np.degrees(np.arctan2(1, 2))
    squares = [affine.rotate(sq, rotation, origin = (0, 0))
           for sq in squares]
    _setup_base_tile(unit, TileShape.RECTANGLE)
    unit.prototile.geometry = [affine.rotate(
      tiling_utils.get_prototile_from_vectors(
      [(-s, -2 * s), (-2 * s,  s)]), rotation)]
  elif unit.n == 6:
    # Copy and translate square
    tr = [(-s, -s), (0, -s),
          (-s,  0), (0,  0), ( s,  0),
                    (0,  s)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    squares = [affine.rotate(sq, -45, origin = (0, 0)) for sq in squares]
    x  = s * np.sqrt(2)
    _setup_base_tile(unit, TileShape.HEXAGON)
    unit.prototile.geometry = [tiling_utils.get_prototile_from_vectors(
      [(-3 * x/2, -3 * x/2), (-2 * x, 0), (-x/2, 3 * x/2)])]
  elif unit.n == 7:
    # Copy and translate square
    tr = [(-s, -s), (0, -s),
          (-s,  0), (0,  0), ( s,  0),
                    (0,  s), ( s,  s)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    squares = [affine.rotate(sq, -45, (0, 0)) for sq in squares]
    _setup_base_tile(unit, TileShape.HEXAGON)
    x = s * np.sqrt(2)
    # this is a nicer prototile than the one generated by tiling_utils
    unit.prototile.geometry = [geom.Polygon([
      (-x, -x/2), (-3 * x/2, 0), (-x/2,  x),
      ( x,  x/2), ( 3 * x/2, 0), ( x/2, -x)
    ])]
  elif unit.n == 8:
    # Copy and translate square
    tr = [(-s, -s), (0, -s), ( s, -s),
          (-s,  0), (0,  0), ( s,  0),
          (-s,  s), (0,  s)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    squares = [affine.rotate(sq, 45, origin = (0, 0)) for sq in squares]
    _setup_base_tile(unit, TileShape.HEXAGON)
    x  = s * np.sqrt(2)
    # this is a nicer prototile than the one generated by tiling_utils
    unit.prototile.geometry = [geom.Polygon([
      (-x/2, -x), ( x/2, -x), ( 3 * x/2, 0),
      ( x/2,  x), (-x/2,  x), (-3 * x/2, 0)
    ])]
  elif unit.n == 9:
    # Copy and translate square
    tr = [(-s, -s), (0, -s), ( s, -s),
          (-s,  0), (0,  0), ( s,  0),
          (-s,  s), (0,  s), ( s,  s)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    _setup_base_tile(unit, TileShape.RECTANGLE)
    unit.prototile.geometry = [geom.Polygon([
      (-3 * s/2, -3 * s/2), (-3 * s/2,  3 * s/2), 
      ( 3 * s/2,  3 * s/2), ( 3 * s/2, -3 * s/2)
    ])]
  else:
    print(f"{unit.n}-colouring of squares is not supported. Try 2, 3, 4, 5, 7, or 9")
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return

  unit.tiles = gpd.GeoDataFrame(
    data = {"tile_id": list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(squares))
  unit.setup_regularised_prototile_from_tiles()

