#!/usr/bin/env python
# coding: utf-8

"""Functions for setting up a `weavingspace.tile_unit.TileUnit` with various 
element geometries. Some care is required in adding new functions that use 
exisitng ones to get the sequence of setup operations right. Modify with care!

The available tilings can be viewed in [this notebook](https://github.com/DOSull/weaving-space/blob/main/all-the-tiles.ipynb).

These tilings (and many many more!) are discussed in 

Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H. Freeman and 
Company, New York)

A more accessible introduction is

Kaplan C S, 2002 _Computer Graphics and Geometric Ornamental Design_, PhD 
thesis, University of Washington, Seattle, WA, https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf

and a more 'polished' version of that work focused on computer graphics is also 
available

Kaplan C S, 2009 _Introductory tiling theory for computer graphics_ (Morgan & 
Claypool)
"""

from typing import TYPE_CHECKING
import copy
import itertools
import string

import geopandas as gpd
import numpy as np
import shapely.geometry as geom
import shapely.affinity as affine

from weavingspace.tileable import TileShape
from weavingspace.tile_unit import TileUnit
import weavingspace.tiling_utils as tiling_utils

def _setup_none_tile(unit:TileUnit) -> None:
    """Setups a 'null' tile with one element and one element_id.

    Args:
        unit (TileUnit): the TileUnit to setup.
    """
    _setup_base_tile(unit, unit.tile_shape)
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": ["a"]}, crs = unit.crs,
        geometry = copy.deepcopy(unit.tile.geometry))
    return


def _setup_base_tile(unit:TileUnit, shape:TileShape) -> None:
    """_summary_

    Args:
        unit (TileUnit):  the TileUnit to setup.
        shape (TileShape): the TileShape to apply.
    """
    unit.tile_shape = shape
    if unit.tile_shape == TileShape.DIAMOND:
        tile = geom.Polygon([
            (unit.spacing / 2, 0), (0, unit.spacing * np.sqrt(3) / 2), 
            (-unit.spacing / 2, 0), (0, -unit.spacing * np.sqrt(3) / 2)])
    else:
        tile = tiling_utils.get_regular_polygon(
            unit.spacing, n = (4 
                            if unit.tile_shape in (TileShape.RECTANGLE, )
                            else (6 
                                if unit.tile_shape in (TileShape.HEXAGON, )
                                else 3)))
    unit.tile = gpd.GeoDataFrame(
        geometry = gpd.GeoSeries([tile]), crs = unit.crs)
    return


def setup_cairo(unit:TileUnit) -> None:
    """Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.
    This code shows how a 'handcoded' set of geometries can be applied.
    
    Note that it is advisable to avoid intersection and union operations where
    possible, as it often yields floating point mismatches that can be hard
    to repair! (This tiling can be relatively conveniently generated by 
    dissecting a square in 4 quarters at a 30 degree angle to the sides and
    then reflecting and rotating copies and joing them back together. But 
    floating point issues make that very messy indeed. Much better to make
    the geometries 'pure'.)

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """ 
    _setup_base_tile(unit, TileShape.RECTANGLE)  # a square
    d = unit.spacing        
    x = d / 2 / (np.cos(np.radians(15)) + np.cos(np.radians(75)))
    # the following is just the geometry, it is what it is...
    # points are (more or less)
    # 
    #         3
    #     2
    #            4
    #     1    0
    #
    # then rotate -15 and make 4 copies at 90 degree rotations
    p1 = geom.Polygon([(x, 0), (0, 0), (0, x),
                       (x * np.sqrt(3) / 2, x + x / 2),
                       (x * (1 + np.sqrt(3)) / 2, x * (3 - np.sqrt(3)) / 2)])
    p1 = affine.rotate(p1, -15, (0, 0))
    p2 = affine.rotate(p1, 90, (0, 0))
    p3 = affine.rotate(p2, 90, (0, 0))
    p4 = affine.rotate(p3, 90, (0, 0))
    
    # now move them so they are arranged as a hexagon centered on the tile
    p1 = affine.translate(p1, -unit.spacing / 2, 0)
    p2 = affine.translate(p2, unit.spacing / 2, 0)
    p3 = affine.translate(p3, unit.spacing / 2, 0)
    p4 = affine.translate(p4, -unit.spacing / 2, 0)

    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list("abcd")}, crs = unit.crs,
        geometry = gpd.GeoSeries([p1, p2, p3, p4]))
    unit.setup_regularised_tile_from_elements()
        
    
def setup_hex_dissection(unit:TileUnit) -> None:
    """Tilings from radial dissection of a hexagon into 2, 3, 4, 6 or 12 slices.
    
    The supplied unit should have dissection_offset and n set.
    
    self.dissection_offset == 1 starts at midpoints, 0 at hexagon corners
    self.n is the number of slices and should be 2, 3, 4, 6 or 12.
    
    Again, construction avoids intersection operations where possible.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    _setup_base_tile(unit, TileShape.HEXAGON)
    hex = tiling_utils.get_regular_polygon(unit.spacing, 6)
    # note that shapely coords includes the first point at beginning
    # and end - very convenient!
    v = list(hex.exterior.coords)
    # midpoints
    m = [((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)
                    for p1, p2 in zip(v[:-1], v[1:])]
    # chain into a list of corner, midpoint, corner, midpoint..., i.e.
    #
    #           6  5  4
    #          7       3
    #         8         2
    #          9       1
    #           10 11 0
    #
    # then depending on number of slices and offset pick out points
    # and copy and rotate as needed
    p = list(itertools.chain(*zip(v[:-1], m)))
    if unit.n == 2:
        s = (geom.Polygon([p[0], p[2], p[4], p[6]])
                if unit.dissection_offset == 0
                else geom.Polygon(p[1:8]))
        slices = [affine.rotate(s, a, origin = (0, 0)) 
                    for a in range(0, 360, 180)]
    elif unit.n == 3:
        s = (geom.Polygon([p[0], p[2], p[4], (0, 0)])
                if unit.dissection_offset == 0
                else geom.Polygon([p[1], p[2], p[4], p[5], (0, 0)]))
        slices = [affine.rotate(s, a, origin = (0, 0)) 
                    for a in range(0, 360, 120)]
    elif unit.n == 4:  
        # a bit different because they are not rotationally symmetric
        s1 = (geom.Polygon([p[0], p[2], p[3], (0, 0)])
                if unit.dissection_offset == 0
                else geom.Polygon([p[1], p[2], p[4], (0, 0)]))
        s2 = (geom.Polygon([p[3], p[4], p[6], (0, 0)])
                if unit.dissection_offset == 0
                else geom.Polygon([p[4], p[6], p[7], (0, 0)]))
        slices = [s1, s2, 
                    affine.rotate(s1, 180, (0, 0)),
                    affine.rotate(s2, 180, (0, 0))]
    elif unit.n == 6:
        s = (geom.Polygon([p[0], p[2], (0, 0)])
                if unit.dissection_offset == 0
                else geom.Polygon([p[1], p[2], p[3], (0, 0)]))
        slices = [affine.rotate(s, a, origin = (0, 0)) 
                    for a in range(0, 360, 60)]
    elif unit.n == 12:
        if unit.dissection_offset == 0:
            # like 4 they are not rotationally symmetric
            s1 = geom.Polygon([p[0], p[1], (0, 0)])
            s2 = geom.Polygon([p[1], p[2], (0, 0)])
            slices1 = [affine.rotate(s1, a, origin = (0, 0)) 
                        for a in range(0, 360, 60)]
            slices2 = [affine.rotate(s2, a, origin = (0, 0)) 
                        for a in range(0, 360, 60)]
            # interleave the slices so they are labelled in CCW order 
            slices = itertools.chain(*zip(slices1, slices2))
        else:
            steps = np.linspace(0, 1, unit.n + 1) - (1 / 24)
            slices = [tiling_utils.get_polygon_sector(hex, p1, p2)
                    for p1, p2 in zip(steps[:-1], steps[1:])]    
    
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list(string.ascii_letters)[:unit.n]}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries(slices))
    unit.regularised_tile = copy.deepcopy(unit.tile)


def setup_laves(unit:TileUnit) -> None:
    """The Laves tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.
    
    These are all isohedral, but mostly not regular polygons. We 
    prioritise them over the Archimedean tilings because being
    isohedral all tiles are the same size. Several are hex
    dissections and setup is delegated accordingly.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    if unit.code == "3.3.3.3.3.3":
        # this is the regular hexagons
        _setup_base_tile(unit, TileShape.HEXAGON)
        _setup_none_tile()
        return
    if unit.code == "3.3.3.3.6":
        # this one needs its own code
        _setup_laves_33336(unit)
        return
    elif unit.code == "3.3.3.4.4":
        print(f"The code [{unit.code}] is unsupported.")
    elif unit.code == "3.3.4.3.4":
        # king of tilings!
        setup_cairo(unit)
        return
    elif unit.code == "3.4.6.4":
        # the hex 6-dissection
        unit.n = 6
        unit.dissection_offset = 1
        setup_hex_dissection(unit)
        return
    elif unit.code == "3.6.3.6":
        # hex 3-dissection (also a cube weave!)
        unit.n = 3
        unit.dissection_offset = 0
        setup_hex_dissection(unit)
        return
    elif unit.code == "3.12.12":
        # again this one needs its own
        _setup_laves_31212(unit)
        return
    elif unit.code == "4.4.4":
        # square grid
        _setup_base_tile(unit, TileShape.RECTANGLE)
        _setup_none_tile()
        return
    elif unit.code == "4.6.12":
        # hex 12-dissection 
        unit.n = 12
        unit.dissection_offset = 0
        setup_hex_dissection(unit)
        return
    elif unit.code == "4.8.8":
        # this one needs its own (a 4-dissection of the square)
        # perhaps to be added as a category later...
        _setup_laves_488(unit)
        return
    elif unit.code == "6.6.6":
        # triangles
        _setup_base_tile(unit, TileShape.TRIANGLE)
        _setup_none_tile()
    else:
        print(f"[{unit.code}] is not a valid Laves code.")

    unit.tiling_type = None
    unit.setup_none_tile()
    return


def _setup_laves_33336(unit:TileUnit) -> None:
    """Sets up Laves [3.3.3.3.6] which is like a 6 petal flower.
    
    Similar to the H3 7 hexagon group with the central hex removed and each
    hex 'taking' a 1/6 share of the central hex.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    _setup_base_tile(unit, TileShape.HEXAGON)
    offset_a = np.degrees(np.arctan(1 / 3 / np.sqrt(3)))
    sf = 1 / np.sqrt(7)
    tile = tiling_utils.get_regular_polygon(unit.spacing, 6)
    hex = affine.scale(tile, sf, sf)
    # translate it up by its own height
    hex = affine.translate(hex, 0, hex.bounds[3] - hex.bounds[1])
    hex_p = [p for p in hex.exterior.coords]
    # now replace first and last points by (0, 0) 
    # (note shapely doesn't require closure of the polygon)
    petal = geom.Polygon([(0, 0)] + hex_p[1:5])
    petals = [affine.rotate(petal, a + offset_a, origin = (0, 0))
                    for a in range(30, 360, 60)]
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list("abcdef")}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries(petals))
    unit.setup_regularised_tile_from_elements()
        

def _setup_laves_488(unit:TileUnit) -> None:
    """The 4-dissection of the square by its diagonals.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    _setup_base_tile(unit, TileShape.RECTANGLE)
    tile = tiling_utils.get_regular_polygon(unit.spacing, 4)
    pts = [p for p in tile.exterior.coords]
    tri1 = geom.Polygon([pts[0], pts[1], geom.Point(0, 0)])
    tris = [affine.rotate(tri1, a, (0, 0)) for a in range(0, 360, 90)]
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list("abcd")}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries(tris))
    unit.setup_regularised_tile_from_elements()
        
        
def _setup_laves_31212(unit:TileUnit) -> None:
    """This is also a hexagon dissection... like 3.6.3.6 with each rhombus
    sliced in half along its long diagonal.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    _setup_base_tile(unit, TileShape.HEXAGON)
    hex = tiling_utils.get_regular_polygon(unit.spacing, 6)
    pts = [p for p in hex.exterior.coords]
    tri1 = geom.Polygon([pts[0], pts[2], [0, 0]])
    tri2 = geom.Polygon([pts[0], pts[1], pts[2]])
    tris1 = [affine.rotate(tri1, a, origin = (0, 0)) 
             for a in range(0, 360, 120)]
    tris2 = [affine.rotate(tri2, a, origin = (0, 0)) 
             for a in range(0, 360, 120)]
    # reorder so the 'inner' and 'outer' triangles are labelled alternately 
    tris = itertools.chain(*zip(tris1, tris2))
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list("abcdef")}, crs = unit.crs,
        geometry = gpd.GeoSeries(tris)
    )
    unit.regularised_tile = copy.deepcopy(unit.tile)


def setup_archimedean(unit:TileUnit) -> None:
    """The Archimedean 'regular tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane

    Many of these are most easily constructed as duals of the Laves tilings.
    
    Some are not yet implemented:
    
    (3.3.3.4.4) is kind of weird (stripes of triangles and squares) so can't be 
    bothered with it. Perhaps as a 5-element option we'll get to it in time.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    if unit.code == "3.3.3.3.3.3":
        _setup_base_tile(unit, TileShape.TRIANGLE)
        _setup_none_tile(unit)
    if unit.code == "3.3.3.3.6":
        setup_laves(unit)
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "3.3.3.4.4":
        print(f"The code [{unit.code}] is unsupported.")
    elif unit.code == "3.3.4.3.4":
        # this is an attractive 6-colourable triangles and squares tiling
        setup_laves(unit)
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "3.4.6.4":
        setup_laves(unit)
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "3.6.3.6":
        setup_laves(unit)
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "3.12.12":
        # nice! we can make dodecagons without having to think too hard
        # simply use the dual code. (Although really... it probably
        # would've been easier to make the dodecagon... other than
        # calculating the scale relative to the hexagon base tile!)
        setup_laves(unit)
        unit.setup_vectors()
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "4.4.4":
        _setup_base_tile(unit, TileShape.RECTANGLE)
        _setup_none_tile(unit)
        return
    elif unit.code == "4.6.12":
        # more dodecagons for free!
        setup_laves(unit)
        unit.setup_vectors()
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "4.8.8":
        # this is the octagon and square tiling
        setup_laves(unit)
        unit.elements = tiling_utils.get_dual_tile_unit(unit)
        unit.setup_regularised_tile_from_elements()
        return
    elif unit.code == "6.6.6":
        _setup_base_tile(unit, TileShape.HEXAGON)
        _setup_none_tile(unit)
        return
    else:
        print(f"[{unit.code}] is not a valid Laves code.")

    unit.tiling_type = None
    _setup_none_tile(unit)
    return


def _setup_archimedean_3464(unit:TileUnit) -> None:
    """The dual of Laves 3.4.6.4 is not accurately rendered
    by our code, so we do this one by hand. 

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    _setup_base_tile(unit, TileShape.HEXAGON)
    sf = np.sqrt(3) / (1 + np.sqrt(3))
    hex = tiling_utils.get_regular_polygon(unit.spacing * sf, 6)
    corners = [p for p in hex.exterior.coords]
    p1 = corners[1]
    p2 = corners[0]
    #   HEX   p1
    #        /    p4
    #    ---p2   /
    #           p3
    dx, dy = p2[0] - p1[0], p2[1] - p1[1]
    p3 = (p2[0] - dy, p2[1] + dx)
    p4 = (p3[0] - dx, p3[1] - dy)
    square1 = geom.Polygon([p1, p2, p3, p4])
    square2 = affine.rotate(square1, 60, (0, 0))
    square3 = affine.rotate(square2, 60, (0, 0))
    p5 = [pt for pt in square2.exterior.coords][2]
    tri1 = geom.Polygon([p1, p4, p5])
    tri2 = affine.rotate(tri1, 60, (0, 0))

    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list("abcdef")}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries([hex, square1, square2, square3, tri1, tri2]))
    unit.setup_regularised_tile_from_elements()


def setup_hex_colouring(unit:TileUnit) -> None:
    """3, 4, and 7 colourings of a regular array of hexagons.

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    hex = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 6)
    if unit.n == 3:
        # Point up hex at '*' displaced to 3 positions:
        #      2
        #      *
        #    3   1
        _setup_base_tile(unit, TileShape.HEXAGON)
        hex = affine.rotate(hex, 30, origin = (0, 0))
        # Copy and translate to alternate corners
        corners = [p for i, p in enumerate(hex.exterior.coords) 
                   if i in (0, 2, 4)]
        hexes = [affine.translate(hex, p[0], p[1]) for p in corners]
    elif unit.n == 4:
        # Point up hex at '*' displaced to 4 positions:
        #      2
        #     3*1
        #      4
        _setup_base_tile(unit, TileShape.DIAMOND)
        hex = affine.rotate(hex, 30, origin = (0, 0))
        hex1 = affine.translate(hex, unit.spacing / 4, 0)
        hex2 = affine.translate(
            hex1, -unit.spacing / 4, unit.spacing * np.sqrt(3) / 4)
        hex3 = affine.translate(hex, -unit.spacing / 4, 0)
        hex4 = affine.translate(
            hex3, unit.spacing / 4, -unit.spacing * np.sqrt(3) / 4)
        hexes = [hex1, hex2, hex3, hex4]
    elif unit.n == 7:  # the 'H3' tile
        # Make a hexagon and displace in the direction of its
        # own 6 corners, scaled as needed
        _setup_base_tile(unit, TileShape.HEXAGON)
        rotation = np.degrees(np.arctan(1 / 3 / np.sqrt(3)))
        corners = [p for p in hex.exterior.coords][:-1]
        hex = affine.rotate(hex, 30)
        hexes = [hex] + [affine.translate(
            hex, x * np.sqrt(3), y * np.sqrt(3)) for x, y in corners]
        hexes = [affine.rotate(h, rotation, origin = (0, 0))
                 for h in hexes]
    else:
        _setup_base_tile(unit, TileShape.HEXAGON)
        _setup_none_tile(unit)
        return
    
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list(string.ascii_letters)[:unit.n]}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries(hexes))
    unit.setup_regularised_tile_from_elements()


def setup_square_colouring(unit:TileUnit) -> None:
    """Colourings of a regular array of squares. Only supports n = 5 at present
    but we need a n=5 option

    Args:
        unit (TileUnit):  the TileUnit to setup.
    """
    sq = tiling_utils.get_regular_polygon(unit.spacing, 4)
    if unit.n == 5:
        _setup_base_tile(unit, TileShape.RECTANGLE)
        
        # Copy and translate square
        tr = [(0, 0), (unit.spacing, 0), (0, unit.spacing), 
              (-unit.spacing, 0), (0, -unit.spacing)]
        squares = [affine.translate(sq, v[0], v[1]) for v in tr]
        squares = [affine.scale(sq, 1 / np.sqrt(5), 1 / np.sqrt(5),
                                origin = (0, 0)) for sq in squares]
        rotation = np.degrees(np.arctan2(1, 2))
        squares = [affine.rotate(sq, rotation, origin = (0, 0)) 
                   for sq in squares]
    else:
        _setup_base_tile(unit, TileShape.RECTANGLE)
        _setup_none_tile(unit)
        return
    
    unit.elements = gpd.GeoDataFrame(
        data = {"element_id": list(string.ascii_letters)[:unit.n]}, 
        crs = unit.crs,
        geometry = gpd.GeoSeries(squares))
    unit.setup_regularised_tile_from_elements()

