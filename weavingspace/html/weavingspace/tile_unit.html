<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weavingspace.tile_unit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tile_unit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

import copy
from dataclasses import dataclass
import string

import geopandas as gpd
import numpy as np
import shapely.geometry as geom
import shapely.affinity as affine

from tileable import Tileable
from tileable import TileShape

import tiling_utils
import _tiling_geometries


@dataclass
class TileUnit(Tileable):
    &#34;&#34;&#34;Class to represent the tileable elements of a &#39;conventional&#39; tiling.
    
    A `TileUnit` is initialised like this
    
        tile_unit = TileUnit(tiling_type = &#34;cairo&#34;)
        
    The `tiling_type` may be one of the following
    
    + &#34;cairo&#34; the Cairo tiling more formally known as the Laves 
    [3&lt;sup&gt;2&lt;/sup&gt;.4.3.4] tiling. The author&#39;s favourite tiling, hence it has 
    its own tiling_type.
    + &#34;hex-dissection&#34; a range of dissections of the regular hexagon into, 2, 3
    4, 6, or 12 &#39;pie slices&#39;. The number of slices is set by specifying an
    additional argument `n`. Slices are cut either starting at the corners of 
    the hexagon or from the midpoints of hexagon edges, by specifying an
    additional argument `dissection_offset` set to either 0 or 1 respectively.
    + &#34;laves&#34; a range of isohedral tilings. See [this article](https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings). The 
    desired tiling is specified by the additional argument `code` which is a 
    string like &#34;3.3.4.3.4&#34;.
    + &#34;archimedean&#34; a range of tilings by regular polygons. See [this article](https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons#Archimedean,_uniform_or_semiregular_tilings). Many of these are the dual tilings of the 
    Laves tilings. The desired tiling is specified by the additional argument 
    `code` which is a string like &#34;3.3.4.3.4&#34;. Not all the possible Archimedean 
    tilings are implemented.
    + &#34;hex-colouring&#34; three colourings of the regular hexagon tiling, of either 
    3, 4, or 7 colours, as specified by the argument `n`.
    + &#34;square-colouring&#34; one colouring of the regular square tiling, of 5 
    colours as specified by the argument `n = 5`.
    
    See [this notebook](https://github.com/DOSull/weaving-space/blob/main/weavingspace/all-the-tiles.ipynb) for exact usage, and illustrations of 
    each tiling. 
    
    Spacing and coordinate reference of the tile unit are specified by the
    `weavingspace.tileable.Tileable` superclass variables 
    `weavingspace.tileable.Tileable.spacing` and 
    `weavingspace.tileable.Tileable.crs`.

    Base tilings by squares, hexagons or triangles can also be requested using
    
        tile_unit = TileUnit()  # square tiling, the default
        tile_unit = TileUnit(tile_shape = TileShape.HEXAGON)
        tile_unit = TileUnit(tile_shape = TileShape.TRIANGLE)
        
    The first two of these have only one element_id value, and so cannot be 
    used for multivariate mapping. The triangle case has two element_id values
    so may be useful in its base form.
    
    To create custom tilings start from one of the base tiles above, and 
    explicitly set the `weavingspace.Tileable.elements` variable by geometric 
    construction of suitable shapely.geometry.Polygons. 
    
    TODO: A detailed example of this usage can be found in this notebook.
    
    Args:
        tiling_type (str): tiling type as detailed above.
        dissection_offset (int): offset for &#34;hex-dissection&#34; tilings. See above 
            for details. Defaults to 1. 
        n (int): number of dissections or colours in &#34;hex-dissection&#34;, 
            &#34;hex-colouring&#34;, or &#34;square-colouring&#34; tiling types. Defaults to 3.
        code (str): the code for &#34;laves&#34; or &#34;archimedean&#34; tiling types. 
        Defaults to &#34;3.3.4.3.4&#34;.

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    tiling_type:str = None
    dissection_offset:int = 1
    n:int = 3
    code:str = &#34;3.3.4.3.4&#34;
        
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        if not self.tiling_type is None:
            self.tiling_type = self.tiling_type.lower()
        if self.tile_shape == TileShape.TRIANGLE:
            self._modify_tile()
            self._modify_elements()
            self.setup_vectors()
            self.setup_regularised_tile_from_elements()
        if self.regularised_tile is None:
            self.setup_regularised_tile_from_elements()


    def setup_tile_and_elements(self) -&gt; None:
        &#34;&#34;&#34;Delegates setup of the unit to various functions depending
        on self.tiling_type.
        &#34;&#34;&#34;
        if self.tiling_type == &#34;cairo&#34;:
            _tiling_geometries.setup_cairo(self)
        elif self.tiling_type == &#34;hex-dissection&#34;:
            _tiling_geometries.setup_hex_dissection(self)
        elif self.tiling_type == &#34;laves&#34;:
            _tiling_geometries.setup_laves(self)
        elif self.tiling_type == &#34;archimedean&#34;:
            _tiling_geometries.setup_archimedean(self)
        elif self.tiling_type in (&#34;hex-colouring&#34;, &#34;hex-coloring&#34;):
            _tiling_geometries.setup_hex_colouring(self)
        elif self.tiling_type in (&#34;square-colouring&#34;, &#34;square-coloring&#34;):
            _tiling_geometries.setup_square_colouring(self)
        else:
            _tiling_geometries.setup_none_tile(self)
        return

    
    def _modify_elements(self) -&gt; None:
        &#34;&#34;&#34;It is not trivial to tile a triangle, so this function augments
        augments the elements of a triangular tile to a diamond by 180 degree 
        rotation. Operation is &#39;in place&#39;.
        &#34;&#34;&#34;
        elements = self.elements.geometry
        ids = list(self.elements.element_id)
        
        new_ids = list(string.ascii_letters[:(len(ids) * 2)])
        elements = elements.translate(0, -elements.total_bounds[1])
        twins = [affine.rotate(element, a, origin = (0, 0)) 
                 for element in elements
                 for a in range(0, 360, 180)]
        self.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: new_ids},
            geometry = gpd.GeoSeries(twins), crs = self.elements.crs)
        return None


    def _modify_tile(self) -&gt; None:
        &#34;&#34;&#34;It is not trivial to tile a triangular tile so this function 
        changes the tile to a diamond by copying and joining a 180 degree
        rotated copy. Operation is &#39;in-place&#39;.
        &#34;&#34;&#34;
        tile = self.tile.geometry[0]
        # translate to sit on x-axis
        tile = affine.translate(tile, 0, -tile.bounds[1])
        # make rotated copies
        # buffering applied to ensure union &#39;sticks&#39;
        twins = [affine.rotate(tile, a, origin = (0, 0)) \
                    .buffer(self.fudge_factor, resolution = 1, join_style = 2) 
                 for a in range(0, 360, 180)]
        # and here we undo the buffer
        merged_tile = gpd.GeoSeries(twins).unary_union.buffer(
                -self.fudge_factor, resolution = 1, join_style = 2)
        self.tile_shape = TileShape.DIAMOND
        self.tile.geometry = gpd.GeoSeries([merged_tile])
        return None

    
    def _get_legend_key_shapes(self, polygon:geom.Polygon, 
                               counts:int = 25, angle:float = 0, 
                               radial:bool = False) -&gt; list[geom.Polygon]:
        &#34;&#34;&#34;Returns a set of shapes that can be used to make a legend key 
        symbol for the supplied polygon. In TileUnit this is a set of &#39;nested
        polygons.

        Args:
            polygon (geom.Polygon): the polygon to symbolise.
            n (int, optional): number of steps. Defaults to 25.
            rot (float, optional): rotation that may have to be applied.  
                Not used in the TileUnit case. Defaults to 0.

        Returns:
            list[geom.Polygon]: a list of nested polygons.
        &#34;&#34;&#34;
        if not radial:
            n = sum(counts)
            # bandwidths = list(np.cumsum(counts))
            bandwidths = [c / n for c in counts]
            bandwidths = [bw if bw &gt; 0.05 or bw == 0 else 0.05 
                          for bw in bandwidths]
            n = sum(bandwidths)
            bandwidths = [0] + [bw / n for bw in bandwidths]
            # # make buffer widths that will yield approx equal area &#39;annuli&#39;
            # bandwidths = range(n_steps + 1)
            # sqrt exaggerates outermost annuli, which can otherwise disappear
            bandwidths = [np.sqrt(bw) for bw in bandwidths]
            distances = np.cumsum(bandwidths)
            # get the negative buffer distance that will &#39;collapse&#39; the polygon
            radius = tiling_utils.get_collapse_distance(polygon)
            distances = distances * radius / distances[-1]
            nested_polys = [polygon.buffer(-d, resolution = 1, 
                                           join_style = 2) for d in distances]
            # return converted to annuli (who knows someone might set alpha &lt; 1)
            nested_polys = [g1.difference(g2) for g1, g2 in 
                            zip(nested_polys[:-1], nested_polys[1:])]
            return [p for c, p in zip(counts, nested_polys) if c &gt; 0]      
        else:
            n = sum(counts)
            slice_posns = list(np.cumsum(counts))
            slice_posns = [0] + [p / n for p in slice_posns]
            return [tiling_utils.get_polygon_sector(polygon, i, j) 
                    for i, j in zip(slice_posns[:-1], slice_posns[1:])]


    # Note that geopandas clip is not order preserving hence we do this
    # one polygon at a time...
    def inset_tile(self, d:float = 0) -&gt; &#34;TileUnit&#34;:
        &#34;&#34;&#34;Returns a new TileUnit clipped by `self.regularised_tile` after
        a negative buffer d has been applied.

        Args:
            d (float, optional): the inset distance. Defaults to 0.

        Returns:
            TileUnit: the new TileUnit with inset applied.
        &#34;&#34;&#34;
        inset_tile = self.regularised_tile.geometry.buffer(
                -d, resolution = 1, join_style = 2)[0]
        # the clean_geometry seems needed to stop proliferation of vertices
        new_elements = [tiling_utils.clean_polygon(inset_tile.intersection(e))
                        for e in self.elements.geometry]
        result = copy.deepcopy(self)
        result.elements.geometry = gpd.GeoSeries(new_elements)
        return result
    
    
    def scale_elements(self, sf:float = 1) -&gt; &#34;TileUnit&#34;:
        &#34;&#34;&#34;Scales the elements by the specified factor, centred on (0, 0).

        Args:
            sf (float, optional): scale factor to apply. Defaults to 1.

        Returns:
            TileUnit: the scaled TileUnit.
        &#34;&#34;&#34;
        result = copy.deepcopy(self)
        result.elements.geometry = self.elements.geometry.scale(
            sf, sf, origin = (0, 0))
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.tile_unit.TileUnit"><code class="flex name class">
<span>class <span class="ident">TileUnit</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent the tileable elements of a 'conventional' tiling.</p>
<p>A <code><a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></code> is initialised like this</p>
<pre><code>tile_unit = TileUnit(tiling_type = "cairo")
</code></pre>
<p>The <code>tiling_type</code> may be one of the following</p>
<ul>
<li>"cairo" the Cairo tiling more formally known as the Laves
[3<sup>2</sup>.4.3.4] tiling. The author's favourite tiling, hence it has
its own tiling_type.</li>
<li>"hex-dissection" a range of dissections of the regular hexagon into, 2, 3
4, 6, or 12 'pie slices'. The number of slices is set by specifying an
additional argument <code>n</code>. Slices are cut either starting at the corners of
the hexagon or from the midpoints of hexagon edges, by specifying an
additional argument <code>dissection_offset</code> set to either 0 or 1 respectively.</li>
<li>"laves" a range of isohedral tilings. See <a href="https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings">this article</a>. The
desired tiling is specified by the additional argument <code>code</code> which is a
string like "3.3.4.3.4".</li>
<li>"archimedean" a range of tilings by regular polygons. See <a href="https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons#Archimedean,_uniform_or_semiregular_tilings">this article</a>. Many of these are the dual tilings of the
Laves tilings. The desired tiling is specified by the additional argument
<code>code</code> which is a string like "3.3.4.3.4". Not all the possible Archimedean
tilings are implemented.</li>
<li>"hex-colouring" three colourings of the regular hexagon tiling, of either
3, 4, or 7 colours, as specified by the argument <code>n</code>.</li>
<li>"square-colouring" one colouring of the regular square tiling, of 5
colours as specified by the argument <code>n = 5</code>.</li>
</ul>
<p>See <a href="https://github.com/DOSull/weaving-space/blob/main/weavingspace/all-the-tiles.ipynb">this notebook</a> for exact usage, and illustrations of
each tiling. </p>
<p>Spacing and coordinate reference of the tile unit are specified by the
<code><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></code> superclass variables
<code><a title="weavingspace.tileable.Tileable.spacing" href="tileable.html#weavingspace.tileable.Tileable.spacing">Tileable.spacing</a></code> and
<code><a title="weavingspace.tileable.Tileable.crs" href="tileable.html#weavingspace.tileable.Tileable.crs">Tileable.crs</a></code>.</p>
<p>Base tilings by squares, hexagons or triangles can also be requested using</p>
<pre><code>tile_unit = TileUnit()  # square tiling, the default
tile_unit = TileUnit(tile_shape = TileShape.HEXAGON)
tile_unit = TileUnit(tile_shape = TileShape.TRIANGLE)
</code></pre>
<p>The first two of these have only one element_id value, and so cannot be
used for multivariate mapping. The triangle case has two element_id values
so may be useful in its base form.</p>
<p>To create custom tilings start from one of the base tiles above, and
explicitly set the <code>weavingspace.Tileable.elements</code> variable by geometric
construction of suitable shapely.geometry.Polygons. </p>
<p>TODO: A detailed example of this usage can be found in this notebook.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tiling_type</code></strong> :&ensp;<code>str</code></dt>
<dd>tiling type as detailed above.</dd>
<dt><strong><code>dissection_offset</code></strong> :&ensp;<code>int</code></dt>
<dd>offset for "hex-dissection" tilings. See above
for details. Defaults to 1. </dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of dissections or colours in "hex-dissection",
"hex-colouring", or "square-colouring" tiling types. Defaults to 3.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>the code for "laves" or "archimedean" tiling types. </dd>
</dl>
<p>Defaults to "3.3.4.3.4".</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<p>Stores any supplied attributes, sets up the tile, its elements,
vectors and regularised tile.</p>
<p>The <code>Tileable</code> constructor should not be called directly, but is
instead accessed from the <code><a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></code> or
<code><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code> constructor. These can accept as
arguments any of the arguments below.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the strand geometries with associated
element_id attribute encoding their different colouring.</dd>
<dt><strong><code>tile</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the tileable polygon (either a
rectangle or a hexagon).</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code></dt>
<dd>the tile spacing &ndash; effectively the 'resolution' of
the tiling. Defaults to 1000.</dd>
<dt><strong><code>tile_shape</code></strong> :&ensp;<code>TileShape</code></dt>
<dd>the tile shape. Defaults to </dd>
<dt><code>TileShape.RECTANGLE</code>.</dt>
<dt><strong><code>vectors</code></strong> :&ensp;<code>list[tuple[float]]</code></dt>
<dd>translation vector symmetries of the
tiling.</dd>
<dt><strong><code>regularised_tile</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>a polygon containing all the
elements of self.tile &ndash; most often a union of those polygons.</dd>
<dt><strong><code>crs</code></strong> :&ensp;<code>int</code></dt>
<dd>the coordinate reference system of the tile. Most often
an EPSG code. Any valid geopandas CRS is valid. Defaults to
3857 (i.e. Web Mercator).</dd>
<dt><strong><code>fudge_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>a distance in units of self.crs to be used in
geometry clean ups (for example this buffer distance is applied
before unioning polygons.) Defaults to 1e-3.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TileUnit(Tileable):
    &#34;&#34;&#34;Class to represent the tileable elements of a &#39;conventional&#39; tiling.
    
    A `TileUnit` is initialised like this
    
        tile_unit = TileUnit(tiling_type = &#34;cairo&#34;)
        
    The `tiling_type` may be one of the following
    
    + &#34;cairo&#34; the Cairo tiling more formally known as the Laves 
    [3&lt;sup&gt;2&lt;/sup&gt;.4.3.4] tiling. The author&#39;s favourite tiling, hence it has 
    its own tiling_type.
    + &#34;hex-dissection&#34; a range of dissections of the regular hexagon into, 2, 3
    4, 6, or 12 &#39;pie slices&#39;. The number of slices is set by specifying an
    additional argument `n`. Slices are cut either starting at the corners of 
    the hexagon or from the midpoints of hexagon edges, by specifying an
    additional argument `dissection_offset` set to either 0 or 1 respectively.
    + &#34;laves&#34; a range of isohedral tilings. See [this article](https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings). The 
    desired tiling is specified by the additional argument `code` which is a 
    string like &#34;3.3.4.3.4&#34;.
    + &#34;archimedean&#34; a range of tilings by regular polygons. See [this article](https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons#Archimedean,_uniform_or_semiregular_tilings). Many of these are the dual tilings of the 
    Laves tilings. The desired tiling is specified by the additional argument 
    `code` which is a string like &#34;3.3.4.3.4&#34;. Not all the possible Archimedean 
    tilings are implemented.
    + &#34;hex-colouring&#34; three colourings of the regular hexagon tiling, of either 
    3, 4, or 7 colours, as specified by the argument `n`.
    + &#34;square-colouring&#34; one colouring of the regular square tiling, of 5 
    colours as specified by the argument `n = 5`.
    
    See [this notebook](https://github.com/DOSull/weaving-space/blob/main/weavingspace/all-the-tiles.ipynb) for exact usage, and illustrations of 
    each tiling. 
    
    Spacing and coordinate reference of the tile unit are specified by the
    `weavingspace.tileable.Tileable` superclass variables 
    `weavingspace.tileable.Tileable.spacing` and 
    `weavingspace.tileable.Tileable.crs`.

    Base tilings by squares, hexagons or triangles can also be requested using
    
        tile_unit = TileUnit()  # square tiling, the default
        tile_unit = TileUnit(tile_shape = TileShape.HEXAGON)
        tile_unit = TileUnit(tile_shape = TileShape.TRIANGLE)
        
    The first two of these have only one element_id value, and so cannot be 
    used for multivariate mapping. The triangle case has two element_id values
    so may be useful in its base form.
    
    To create custom tilings start from one of the base tiles above, and 
    explicitly set the `weavingspace.Tileable.elements` variable by geometric 
    construction of suitable shapely.geometry.Polygons. 
    
    TODO: A detailed example of this usage can be found in this notebook.
    
    Args:
        tiling_type (str): tiling type as detailed above.
        dissection_offset (int): offset for &#34;hex-dissection&#34; tilings. See above 
            for details. Defaults to 1. 
        n (int): number of dissections or colours in &#34;hex-dissection&#34;, 
            &#34;hex-colouring&#34;, or &#34;square-colouring&#34; tiling types. Defaults to 3.
        code (str): the code for &#34;laves&#34; or &#34;archimedean&#34; tiling types. 
        Defaults to &#34;3.3.4.3.4&#34;.

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    tiling_type:str = None
    dissection_offset:int = 1
    n:int = 3
    code:str = &#34;3.3.4.3.4&#34;
        
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        if not self.tiling_type is None:
            self.tiling_type = self.tiling_type.lower()
        if self.tile_shape == TileShape.TRIANGLE:
            self._modify_tile()
            self._modify_elements()
            self.setup_vectors()
            self.setup_regularised_tile_from_elements()
        if self.regularised_tile is None:
            self.setup_regularised_tile_from_elements()


    def setup_tile_and_elements(self) -&gt; None:
        &#34;&#34;&#34;Delegates setup of the unit to various functions depending
        on self.tiling_type.
        &#34;&#34;&#34;
        if self.tiling_type == &#34;cairo&#34;:
            _tiling_geometries.setup_cairo(self)
        elif self.tiling_type == &#34;hex-dissection&#34;:
            _tiling_geometries.setup_hex_dissection(self)
        elif self.tiling_type == &#34;laves&#34;:
            _tiling_geometries.setup_laves(self)
        elif self.tiling_type == &#34;archimedean&#34;:
            _tiling_geometries.setup_archimedean(self)
        elif self.tiling_type in (&#34;hex-colouring&#34;, &#34;hex-coloring&#34;):
            _tiling_geometries.setup_hex_colouring(self)
        elif self.tiling_type in (&#34;square-colouring&#34;, &#34;square-coloring&#34;):
            _tiling_geometries.setup_square_colouring(self)
        else:
            _tiling_geometries.setup_none_tile(self)
        return

    
    def _modify_elements(self) -&gt; None:
        &#34;&#34;&#34;It is not trivial to tile a triangle, so this function augments
        augments the elements of a triangular tile to a diamond by 180 degree 
        rotation. Operation is &#39;in place&#39;.
        &#34;&#34;&#34;
        elements = self.elements.geometry
        ids = list(self.elements.element_id)
        
        new_ids = list(string.ascii_letters[:(len(ids) * 2)])
        elements = elements.translate(0, -elements.total_bounds[1])
        twins = [affine.rotate(element, a, origin = (0, 0)) 
                 for element in elements
                 for a in range(0, 360, 180)]
        self.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: new_ids},
            geometry = gpd.GeoSeries(twins), crs = self.elements.crs)
        return None


    def _modify_tile(self) -&gt; None:
        &#34;&#34;&#34;It is not trivial to tile a triangular tile so this function 
        changes the tile to a diamond by copying and joining a 180 degree
        rotated copy. Operation is &#39;in-place&#39;.
        &#34;&#34;&#34;
        tile = self.tile.geometry[0]
        # translate to sit on x-axis
        tile = affine.translate(tile, 0, -tile.bounds[1])
        # make rotated copies
        # buffering applied to ensure union &#39;sticks&#39;
        twins = [affine.rotate(tile, a, origin = (0, 0)) \
                    .buffer(self.fudge_factor, resolution = 1, join_style = 2) 
                 for a in range(0, 360, 180)]
        # and here we undo the buffer
        merged_tile = gpd.GeoSeries(twins).unary_union.buffer(
                -self.fudge_factor, resolution = 1, join_style = 2)
        self.tile_shape = TileShape.DIAMOND
        self.tile.geometry = gpd.GeoSeries([merged_tile])
        return None

    
    def _get_legend_key_shapes(self, polygon:geom.Polygon, 
                               counts:int = 25, angle:float = 0, 
                               radial:bool = False) -&gt; list[geom.Polygon]:
        &#34;&#34;&#34;Returns a set of shapes that can be used to make a legend key 
        symbol for the supplied polygon. In TileUnit this is a set of &#39;nested
        polygons.

        Args:
            polygon (geom.Polygon): the polygon to symbolise.
            n (int, optional): number of steps. Defaults to 25.
            rot (float, optional): rotation that may have to be applied.  
                Not used in the TileUnit case. Defaults to 0.

        Returns:
            list[geom.Polygon]: a list of nested polygons.
        &#34;&#34;&#34;
        if not radial:
            n = sum(counts)
            # bandwidths = list(np.cumsum(counts))
            bandwidths = [c / n for c in counts]
            bandwidths = [bw if bw &gt; 0.05 or bw == 0 else 0.05 
                          for bw in bandwidths]
            n = sum(bandwidths)
            bandwidths = [0] + [bw / n for bw in bandwidths]
            # # make buffer widths that will yield approx equal area &#39;annuli&#39;
            # bandwidths = range(n_steps + 1)
            # sqrt exaggerates outermost annuli, which can otherwise disappear
            bandwidths = [np.sqrt(bw) for bw in bandwidths]
            distances = np.cumsum(bandwidths)
            # get the negative buffer distance that will &#39;collapse&#39; the polygon
            radius = tiling_utils.get_collapse_distance(polygon)
            distances = distances * radius / distances[-1]
            nested_polys = [polygon.buffer(-d, resolution = 1, 
                                           join_style = 2) for d in distances]
            # return converted to annuli (who knows someone might set alpha &lt; 1)
            nested_polys = [g1.difference(g2) for g1, g2 in 
                            zip(nested_polys[:-1], nested_polys[1:])]
            return [p for c, p in zip(counts, nested_polys) if c &gt; 0]      
        else:
            n = sum(counts)
            slice_posns = list(np.cumsum(counts))
            slice_posns = [0] + [p / n for p in slice_posns]
            return [tiling_utils.get_polygon_sector(polygon, i, j) 
                    for i, j in zip(slice_posns[:-1], slice_posns[1:])]


    # Note that geopandas clip is not order preserving hence we do this
    # one polygon at a time...
    def inset_tile(self, d:float = 0) -&gt; &#34;TileUnit&#34;:
        &#34;&#34;&#34;Returns a new TileUnit clipped by `self.regularised_tile` after
        a negative buffer d has been applied.

        Args:
            d (float, optional): the inset distance. Defaults to 0.

        Returns:
            TileUnit: the new TileUnit with inset applied.
        &#34;&#34;&#34;
        inset_tile = self.regularised_tile.geometry.buffer(
                -d, resolution = 1, join_style = 2)[0]
        # the clean_geometry seems needed to stop proliferation of vertices
        new_elements = [tiling_utils.clean_polygon(inset_tile.intersection(e))
                        for e in self.elements.geometry]
        result = copy.deepcopy(self)
        result.elements.geometry = gpd.GeoSeries(new_elements)
        return result
    
    
    def scale_elements(self, sf:float = 1) -&gt; &#34;TileUnit&#34;:
        &#34;&#34;&#34;Scales the elements by the specified factor, centred on (0, 0).

        Args:
            sf (float, optional): scale factor to apply. Defaults to 1.

        Returns:
            TileUnit: the scaled TileUnit.
        &#34;&#34;&#34;
        result = copy.deepcopy(self)
        result.elements.geometry = self.elements.geometry.scale(
            sf, sf, origin = (0, 0))
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tileable.Tileable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tile_unit.TileUnit.code"><code class="name">var <span class="ident">code</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tile_unit.TileUnit.dissection_offset"><code class="name">var <span class="ident">dissection_offset</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tile_unit.TileUnit.n"><code class="name">var <span class="ident">n</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tile_unit.TileUnit.tiling_type"><code class="name">var <span class="ident">tiling_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.tile_unit.TileUnit.inset_tile"><code class="name flex">
<span>def <span class="ident">inset_tile</span></span>(<span>self, d: float = 0) ‑> <a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new TileUnit clipped by <code>self.regularised_tile</code> after
a negative buffer d has been applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>the inset distance. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></code></dt>
<dd>the new TileUnit with inset applied.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inset_tile(self, d:float = 0) -&gt; &#34;TileUnit&#34;:
    &#34;&#34;&#34;Returns a new TileUnit clipped by `self.regularised_tile` after
    a negative buffer d has been applied.

    Args:
        d (float, optional): the inset distance. Defaults to 0.

    Returns:
        TileUnit: the new TileUnit with inset applied.
    &#34;&#34;&#34;
    inset_tile = self.regularised_tile.geometry.buffer(
            -d, resolution = 1, join_style = 2)[0]
    # the clean_geometry seems needed to stop proliferation of vertices
    new_elements = [tiling_utils.clean_polygon(inset_tile.intersection(e))
                    for e in self.elements.geometry]
    result = copy.deepcopy(self)
    result.elements.geometry = gpd.GeoSeries(new_elements)
    return result</code></pre>
</details>
</dd>
<dt id="weavingspace.tile_unit.TileUnit.scale_elements"><code class="name flex">
<span>def <span class="ident">scale_elements</span></span>(<span>self, sf: float = 1) ‑> <a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></span>
</code></dt>
<dd>
<div class="desc"><p>Scales the elements by the specified factor, centred on (0, 0).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sf</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>scale factor to apply. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></code></dt>
<dd>the scaled TileUnit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_elements(self, sf:float = 1) -&gt; &#34;TileUnit&#34;:
    &#34;&#34;&#34;Scales the elements by the specified factor, centred on (0, 0).

    Args:
        sf (float, optional): scale factor to apply. Defaults to 1.

    Returns:
        TileUnit: the scaled TileUnit.
    &#34;&#34;&#34;
    result = copy.deepcopy(self)
    result.elements.geometry = self.elements.geometry.scale(
        sf, sf, origin = (0, 0))
    return result</code></pre>
</details>
</dd>
<dt id="weavingspace.tile_unit.TileUnit.setup_tile_and_elements"><code class="name flex">
<span>def <span class="ident">setup_tile_and_elements</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delegates setup of the unit to various functions depending
on self.tiling_type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_tile_and_elements(self) -&gt; None:
    &#34;&#34;&#34;Delegates setup of the unit to various functions depending
    on self.tiling_type.
    &#34;&#34;&#34;
    if self.tiling_type == &#34;cairo&#34;:
        _tiling_geometries.setup_cairo(self)
    elif self.tiling_type == &#34;hex-dissection&#34;:
        _tiling_geometries.setup_hex_dissection(self)
    elif self.tiling_type == &#34;laves&#34;:
        _tiling_geometries.setup_laves(self)
    elif self.tiling_type == &#34;archimedean&#34;:
        _tiling_geometries.setup_archimedean(self)
    elif self.tiling_type in (&#34;hex-colouring&#34;, &#34;hex-coloring&#34;):
        _tiling_geometries.setup_hex_colouring(self)
    elif self.tiling_type in (&#34;square-colouring&#34;, &#34;square-coloring&#34;):
        _tiling_geometries.setup_square_colouring(self)
    else:
        _tiling_geometries.setup_none_tile(self)
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.tile_unit.TileUnit" href="#weavingspace.tile_unit.TileUnit">TileUnit</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tile_unit.TileUnit.code" href="#weavingspace.tile_unit.TileUnit.code">code</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.dissection_offset" href="#weavingspace.tile_unit.TileUnit.dissection_offset">dissection_offset</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.inset_tile" href="#weavingspace.tile_unit.TileUnit.inset_tile">inset_tile</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.n" href="#weavingspace.tile_unit.TileUnit.n">n</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.scale_elements" href="#weavingspace.tile_unit.TileUnit.scale_elements">scale_elements</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.setup_tile_and_elements" href="#weavingspace.tile_unit.TileUnit.setup_tile_and_elements">setup_tile_and_elements</a></code></li>
<li><code><a title="weavingspace.tile_unit.TileUnit.tiling_type" href="#weavingspace.tile_unit.TileUnit.tiling_type">tiling_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>