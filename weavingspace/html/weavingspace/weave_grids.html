<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weavingspace.weave_grids API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.weave_grids</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

from typing import Union
from dataclasses import dataclass

import numpy as np

from shapely.affinity import translate
from shapely.affinity import rotate
from shapely.affinity import scale
from shapely.geometry import Polygon
from shapely.geometry import MultiPolygon
from shapely.ops import unary_union
from shapely.wkt import dumps
from shapely.wkt import loads
import shapely.ops

@dataclass
class WeaveGrid:
    &#34;&#34;&#34;Class to encapsulate generation of sites where strands intersect.
    
    Can generate both triangular and square grid &#39;cells&#39; as visual 
    representation of overlaps of two or three strands at a site.

    Atrributes:
        basis (np.ndarray): matrix to calculate x,y coordinates of a
            site from its (integer) grid coordinates,
        orientations (tuple[float]: orientations of the two or three
            axes either (0, -90) or (0, 120, 240).
        grid_cell (Polygon): the base triangle or square of the grid.
        n_axes (int): the number of axes in the weave, 2 or 3. 
            Defaults to 2.
        spacing (float): spacing of the strands. Defaults to 10_000.
    &#34;&#34;&#34;    
    basis: np.ndarray
    orientations: tuple[float]
    grid_cell: Polygon = None
    n_axes: int = None
    spacing: float = 10000
    
    def __init__(self, n_axes, orientations, spacing = 10000):
        &#34;&#34;&#34;Initialises _WeaveGrid.
        &#34;&#34;&#34;        
        self.n_axes = n_axes
        self.orientations = orientations
        self.spacing = spacing
        self.basis = self.setup_basis()
        self.grid_cell = self._make_grid_cell()
        
        
    def setup_basis(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Sets up the basis of the grid coordinate generation matrix.

        Returns:
            np.nd.array: self.n_axes x 2 matrix to generate float coordinates
                of cells in Cartesian space from integer grid coordinates of
                cells.
        &#34;&#34;&#34;        
        # angles are perpendicular to the direction of their respective strands
        # so e.g. 2nd strand in 3 axis case is at 120, and perpendicular is 210
        if self.n_axes == 2:
            angles = (np.pi / 2, 0)
            dx = [self.spacing * np.cos(a) for a in angles]  # [0, 1]
            dy = [self.spacing * np.sin(a) for a in angles]  # [1, 0]
        elif self.n_axes == 3:
            angles = [np.pi / 6 * x for x in range(3, 12, 4)]  # [90, 210, 330]
            dx = [self.spacing * 2 / 3 * np.cos(a) for a in angles]
            dy = [self.spacing * 2 / 3 * np.sin(a) for a in angles]
        return np.array(dx + dy).reshape(2, self.n_axes)
    
        
    def get_coordinates(self, coords: tuple) -&gt; np.ndarray:
        &#34;&#34;&#34;Uses self.basis to determine Cartesian coordinates of cell centroid
        from grid coordinates.

        Args:
            coords (tuple[int]): integer coordinate pair of grid location.

        Returns:
            np.ndarray: float coordinate pair of grid cell centroid.
        &#34;&#34;&#34;        
        return self.basis @ coords
        

    def get_grid_cell_at(self, coords: tuple[int] = None) -&gt; Polygon:
        &#34;&#34;&#34;Returns grid cell polygon centred on coords.

        Args:
            coords (tuple[int], optional): _description_. Defaults to None.

        Returns:
            Polygon: square or triangle centred at the specified coordinates.
        &#34;&#34;&#34;        
        if coords is None:
            coords = tuple([0] * self.n_axes)
        if self.grid_cell is None:
            polygon = self.make_grid_cell()
        else:
            polygon = self.grid_cell
            xy = self.get_coordinates(coords)
            polygon = translate(polygon, xy[0], xy[1])
        if self.n_axes == 2 or sum(coords) %2 == 0:
            return polygon
        else:
            return rotate(polygon, 180, origin = polygon.centroid)

        
    def _make_grid_cell(self) -&gt; Polygon:
        &#34;&#34;&#34;Returns base cell polygon for this _WeaveGrid

        Grid cell is centred at (0, 0) with  number of sides dependent
        on self.n_axes. One side of polygon will be horizontal below the 
        x-axis symmetric about the y-axis. Radii to corners are either
        
        n_axes=2:   n_axes=3:
          \  /          |
           \/           |   
           /\          / \
          /  \        /   \
        
        face to face distance of cell from base vertically to the opposite face 
        or corner is (square) L = 2 Rcos(45), or (triangle) L = R + Rcos(60) where R is the radius of the circumcircle.
        
        Polygon is generated by finding points equally spaced on the 
        circumcircle. Note that the code could easily be altered to return a 
        hexagon, if the need arises (this would require a change to the basis
        calculation also).
        
        Returns:
            Polygon: square or triangular cell of appropriate size i.e. spacing
                centred at (0, 0).
        &#34;&#34;&#34;        
        n_sides = 4 if self.n_axes == 2 else 3
        if n_sides == 4:
            R = self.spacing / (2 * np.cos(np.pi / n_sides))
        else:
            R = self.spacing / (1 + np.cos(np.pi / n_sides))
        angles = self.__get_angles(n_sides)
        corners = [(R * np.cos(a), R * np.sin(a)) for a in angles]
        # return Polygon(corners)
        return self._gridify(Polygon(corners), precision = 6)


    def __get_angles(self, n: int = 4) -&gt; list[float]:
        &#34;&#34;&#34;Returns angles to corners of n sides polygon, assuming one side is horizontal parallel to x-axis.

        To determine angles start at 6 o&#39;clock (3pi/2) and add (pi/n), then
        add n - 1 more 2pi/n steps.

        Args:
            n (int, optional): Number of sides. Defaults to 4.

        Returns:
            list[float]: angles in radians.
        &#34;&#34;&#34;        
        return [(3 * np.pi / 2) + 
                (np.pi / n) + 
                (i / n * 2 * np.pi) for i in range(n)]


    def _gridify(self, shape: Polygon, precision = 3) -&gt; Polygon:
        &#34;&#34;&#34;Returns polygon with coordinates at specified precision. 

        Args:
            shape (Polygon): polygon to gridify.
            precision (int): digits of precision. Defaults to 3.

        Returns:
            Polygon: gridified polygon.
        &#34;&#34;&#34;        
        return loads(dumps(shape, rounding_precision = precision))


    def _get_grid_cell_slices(self, L:float = 0.0, W:float = 1, 
                              n_slices:int = 1) -&gt; list[Polygon]:
        &#34;&#34;&#34;Gets list of rectangular polygons represneting &#39;slices&#39; across cell.
        
        Returns &#39;slices&#39; across grid cell (i.e. horizontally) centred vertically
        relative to the cell, ie
        
                 /\
                /  \
        +------------------+
        |     /      \     |
        +------------------+
        |   /          \   |
        +------------------+
          /              \
         /________________\
        
        Horizontal extent is L, total width of the strips is W * self.spacing,
        they are &#39;sliced&#39; horizontally in n_slices slices of equal width.

        Args:
            L (float, optional): length of slices. Defaults to 0.
            W (float, optional): width of slices relative to grid spacing.    
                Defaults to 1.
            n_slices (int, optional): number of slices to divide strands into
                along their length. Defaults to 1.

        Returns:
            list[Polygon]: _description_
        &#34;&#34;&#34;        
        L = self.spacing if L == 0 else L
        # note that strand width is based on self.spacing, not L because L
        # may be larger if generating slices for aspect &lt; 1 when strands
        # will extend outside grid cell.
        strand_w = self.spacing * W
        slice_w = strand_w / n_slices
        odd_numbers = [x for x in range(1, 2 * n_slices, 2)]
        slice_offsets = [(slice_w * o / 2) - 
                         (strand_w / 2) for o in odd_numbers] 
        base_slice = Polygon([(-L/2, -slice_w/2), ( L/2, -slice_w/2), 
                              ( L/2,  slice_w/2), (-L/2,  slice_w/2)])
        return [translate(base_slice, 0, offset) for offset in slice_offsets]


    def _get_cell_strands(
            self, width:float = 1.0, coords:tuple[int] = None, 
            orientation:int = 0, n_slices:int = 1
        ) -&gt; list[Union[Polygon, MultiPolygon]]:
        &#34;&#34;&#34;Gets n_slices cells strands with specified total width across the
        grid cell at coords at orientation.

        Args:
            width (float, optional): total width of strands relative to 
                self.spacing. Defaults to 1.0.
            coords (tuple[int], optional): integer grid coordinates of 
                cell. Defaults to None.
            orientation (int, optional): orientation of the strands. 
                Defaults to 0.
            n_slices (int, optional): number of length-wise slices to cut
                strands into. Defaults to 1.

        Returns:
            list[Polygon|MultiPolygon]: polygons representing the strands.
        &#34;&#34;&#34;        
        cell = self.get_grid_cell_at(coords)
        # when aspect is &lt;1 strands extend outside cell by some scale factor
        sf = 2 - width if self.n_axes == 2 else (5 - 3 * width) / 2
        expanded_cell = scale(cell, sf, sf, origin = cell.centroid)
        big_l = (sf * self.spacing      ## rectangular case is simple
                 if self.n_axes == 2    ## triangular less so!
                 else sf * self.spacing * 2 / np.sqrt(3) * (3 - width) / 2)
        strands = MultiPolygon(self._get_grid_cell_slices(L = big_l, W = width,
                                                          n_slices = n_slices))
        # we need centre of cell bounding box to shift strands to 
        # vertical center of triangular cells. In rectangular case
        # this will be (0, 0).
        cell_offset = cell.envelope.centroid.coords[0]
        strands = translate(strands, cell_offset[0], cell_offset[1])
        strands = MultiPolygon([expanded_cell.intersection(s)
                                for s in strands.geoms])
        strands = rotate(strands, orientation, origin = cell.centroid)
        # return [s for s in strands.geoms]
        return [self._gridify(s) for s in strands.geoms]


    def get_visible_cell_strands(
            self, width:float= 1.0, coords:tuple[int] = None, 
            strand_order:tuple[int] = (0, 1, 2), n_slices:tuple[int] = (1, 1, 1)
        ) -&gt; list[Union[Polygon, MultiPolygon]]:
        &#34;&#34;&#34;Returns visible strands in grid cell based on layer order.

        Returns visible parts of the strands in a grid cell, given strand width, strand layer order and the number of slices in each direction.

        Args:
            width (float): total width of strands relative to self.spacing.
                Defaults to 1.0.
            coords (tuple[int], optional): grid cell coordinates. Defaults 
                to None.
            strand_order (tuple[int], optional): order of the layers from top,  
                at this cell site. Defaults to (0, 1, 2).
            n_slices (tuple[int], optional): number of slices in each layer 
                at this cell site. Defaults to (1, 1, 1).

        Returns:
            list[Polygon|MultiPolygon]: those polygons that will be visible at
                this site given requested strand order from the top.
        &#34;&#34;&#34;        
        all_polys = []
        for order in strand_order[:self.n_axes]:
            next_polys = self._get_cell_strands(width, coords, 
                                                self.orientations[order], 
                                                n_slices[order])
            if all_polys == []:
                all_polys.extend(next_polys)
                mask = unary_union(next_polys)
            else:
                all_polys.extend([p.difference(mask) for p in next_polys])
                mask = mask.union(unary_union(next_polys))
        return all_polys


    def get_tile_from_cells(self, approx_tile:Polygon) -&gt; Polygon:
        &#34;&#34;&#34;Returns a rectangle or hexagon derived from the bounds of the
        supplied approximation to a tile.
        
        This is required because we know the required tile is an exact 4 or
        6 cornered polygon, but the MultiPolygon formed by unary_union is likely
        to have many more corners than this (for some reason...).

        Args:
            approx_tile (Polygon): MultiPolygon formed from the cells of the
                tile.

        Returns:
            Polygon (geom.Polygon): rectangle of hexagon Polygon.
        &#34;&#34;&#34;
        xmin, ymin, xmax, ymax = approx_tile.bounds
        if self.n_axes == 2:
            w = np.round((xmax - xmin) / self.spacing) * self.spacing
        else:
            h_spacing = self.spacing * 2 / np.sqrt(3)
            w = np.round((xmax - xmin) / h_spacing) * h_spacing
        h = np.round((ymax - ymin) / self.spacing) * self.spacing
        if self.n_axes == 2:
            return Polygon([(-w/2, -h/2), (w/2, -h/2), (w/2, h/2), (-w/2, h/2)])
        else:
            return Polygon([( w/4, -h/2), ( w/2,    0), ( w/4,  h/2), 
                            (-w/4,  h/2), (-w/2,    0), (-w/4, -h/2)])
            
        
        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.weave_grids.WeaveGrid"><code class="flex name class">
<span>class <span class="ident">WeaveGrid</span></span>
<span>(</span><span>n_axes, orientations, spacing=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to encapsulate generation of sites where strands intersect.</p>
<p>Can generate both triangular and square grid 'cells' as visual
representation of overlaps of two or three strands at a site.</p>
<h2 id="atrributes">Atrributes</h2>
<p>basis (np.ndarray): matrix to calculate x,y coordinates of a
site from its (integer) grid coordinates,
orientations (tuple[float]: orientations of the two or three
axes either (0, -90) or (0, 120, 240).
grid_cell (Polygon): the base triangle or square of the grid.
n_axes (int): the number of axes in the weave, 2 or 3.
Defaults to 2.
spacing (float): spacing of the strands. Defaults to 10_000.</p>
<p>Initialises _WeaveGrid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class WeaveGrid:
    &#34;&#34;&#34;Class to encapsulate generation of sites where strands intersect.
    
    Can generate both triangular and square grid &#39;cells&#39; as visual 
    representation of overlaps of two or three strands at a site.

    Atrributes:
        basis (np.ndarray): matrix to calculate x,y coordinates of a
            site from its (integer) grid coordinates,
        orientations (tuple[float]: orientations of the two or three
            axes either (0, -90) or (0, 120, 240).
        grid_cell (Polygon): the base triangle or square of the grid.
        n_axes (int): the number of axes in the weave, 2 or 3. 
            Defaults to 2.
        spacing (float): spacing of the strands. Defaults to 10_000.
    &#34;&#34;&#34;    
    basis: np.ndarray
    orientations: tuple[float]
    grid_cell: Polygon = None
    n_axes: int = None
    spacing: float = 10000
    
    def __init__(self, n_axes, orientations, spacing = 10000):
        &#34;&#34;&#34;Initialises _WeaveGrid.
        &#34;&#34;&#34;        
        self.n_axes = n_axes
        self.orientations = orientations
        self.spacing = spacing
        self.basis = self.setup_basis()
        self.grid_cell = self._make_grid_cell()
        
        
    def setup_basis(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Sets up the basis of the grid coordinate generation matrix.

        Returns:
            np.nd.array: self.n_axes x 2 matrix to generate float coordinates
                of cells in Cartesian space from integer grid coordinates of
                cells.
        &#34;&#34;&#34;        
        # angles are perpendicular to the direction of their respective strands
        # so e.g. 2nd strand in 3 axis case is at 120, and perpendicular is 210
        if self.n_axes == 2:
            angles = (np.pi / 2, 0)
            dx = [self.spacing * np.cos(a) for a in angles]  # [0, 1]
            dy = [self.spacing * np.sin(a) for a in angles]  # [1, 0]
        elif self.n_axes == 3:
            angles = [np.pi / 6 * x for x in range(3, 12, 4)]  # [90, 210, 330]
            dx = [self.spacing * 2 / 3 * np.cos(a) for a in angles]
            dy = [self.spacing * 2 / 3 * np.sin(a) for a in angles]
        return np.array(dx + dy).reshape(2, self.n_axes)
    
        
    def get_coordinates(self, coords: tuple) -&gt; np.ndarray:
        &#34;&#34;&#34;Uses self.basis to determine Cartesian coordinates of cell centroid
        from grid coordinates.

        Args:
            coords (tuple[int]): integer coordinate pair of grid location.

        Returns:
            np.ndarray: float coordinate pair of grid cell centroid.
        &#34;&#34;&#34;        
        return self.basis @ coords
        

    def get_grid_cell_at(self, coords: tuple[int] = None) -&gt; Polygon:
        &#34;&#34;&#34;Returns grid cell polygon centred on coords.

        Args:
            coords (tuple[int], optional): _description_. Defaults to None.

        Returns:
            Polygon: square or triangle centred at the specified coordinates.
        &#34;&#34;&#34;        
        if coords is None:
            coords = tuple([0] * self.n_axes)
        if self.grid_cell is None:
            polygon = self.make_grid_cell()
        else:
            polygon = self.grid_cell
            xy = self.get_coordinates(coords)
            polygon = translate(polygon, xy[0], xy[1])
        if self.n_axes == 2 or sum(coords) %2 == 0:
            return polygon
        else:
            return rotate(polygon, 180, origin = polygon.centroid)

        
    def _make_grid_cell(self) -&gt; Polygon:
        &#34;&#34;&#34;Returns base cell polygon for this _WeaveGrid

        Grid cell is centred at (0, 0) with  number of sides dependent
        on self.n_axes. One side of polygon will be horizontal below the 
        x-axis symmetric about the y-axis. Radii to corners are either
        
        n_axes=2:   n_axes=3:
          \  /          |
           \/           |   
           /\          / \
          /  \        /   \
        
        face to face distance of cell from base vertically to the opposite face 
        or corner is (square) L = 2 Rcos(45), or (triangle) L = R + Rcos(60) where R is the radius of the circumcircle.
        
        Polygon is generated by finding points equally spaced on the 
        circumcircle. Note that the code could easily be altered to return a 
        hexagon, if the need arises (this would require a change to the basis
        calculation also).
        
        Returns:
            Polygon: square or triangular cell of appropriate size i.e. spacing
                centred at (0, 0).
        &#34;&#34;&#34;        
        n_sides = 4 if self.n_axes == 2 else 3
        if n_sides == 4:
            R = self.spacing / (2 * np.cos(np.pi / n_sides))
        else:
            R = self.spacing / (1 + np.cos(np.pi / n_sides))
        angles = self.__get_angles(n_sides)
        corners = [(R * np.cos(a), R * np.sin(a)) for a in angles]
        # return Polygon(corners)
        return self._gridify(Polygon(corners), precision = 6)


    def __get_angles(self, n: int = 4) -&gt; list[float]:
        &#34;&#34;&#34;Returns angles to corners of n sides polygon, assuming one side is horizontal parallel to x-axis.

        To determine angles start at 6 o&#39;clock (3pi/2) and add (pi/n), then
        add n - 1 more 2pi/n steps.

        Args:
            n (int, optional): Number of sides. Defaults to 4.

        Returns:
            list[float]: angles in radians.
        &#34;&#34;&#34;        
        return [(3 * np.pi / 2) + 
                (np.pi / n) + 
                (i / n * 2 * np.pi) for i in range(n)]


    def _gridify(self, shape: Polygon, precision = 3) -&gt; Polygon:
        &#34;&#34;&#34;Returns polygon with coordinates at specified precision. 

        Args:
            shape (Polygon): polygon to gridify.
            precision (int): digits of precision. Defaults to 3.

        Returns:
            Polygon: gridified polygon.
        &#34;&#34;&#34;        
        return loads(dumps(shape, rounding_precision = precision))


    def _get_grid_cell_slices(self, L:float = 0.0, W:float = 1, 
                              n_slices:int = 1) -&gt; list[Polygon]:
        &#34;&#34;&#34;Gets list of rectangular polygons represneting &#39;slices&#39; across cell.
        
        Returns &#39;slices&#39; across grid cell (i.e. horizontally) centred vertically
        relative to the cell, ie
        
                 /\
                /  \
        +------------------+
        |     /      \     |
        +------------------+
        |   /          \   |
        +------------------+
          /              \
         /________________\
        
        Horizontal extent is L, total width of the strips is W * self.spacing,
        they are &#39;sliced&#39; horizontally in n_slices slices of equal width.

        Args:
            L (float, optional): length of slices. Defaults to 0.
            W (float, optional): width of slices relative to grid spacing.    
                Defaults to 1.
            n_slices (int, optional): number of slices to divide strands into
                along their length. Defaults to 1.

        Returns:
            list[Polygon]: _description_
        &#34;&#34;&#34;        
        L = self.spacing if L == 0 else L
        # note that strand width is based on self.spacing, not L because L
        # may be larger if generating slices for aspect &lt; 1 when strands
        # will extend outside grid cell.
        strand_w = self.spacing * W
        slice_w = strand_w / n_slices
        odd_numbers = [x for x in range(1, 2 * n_slices, 2)]
        slice_offsets = [(slice_w * o / 2) - 
                         (strand_w / 2) for o in odd_numbers] 
        base_slice = Polygon([(-L/2, -slice_w/2), ( L/2, -slice_w/2), 
                              ( L/2,  slice_w/2), (-L/2,  slice_w/2)])
        return [translate(base_slice, 0, offset) for offset in slice_offsets]


    def _get_cell_strands(
            self, width:float = 1.0, coords:tuple[int] = None, 
            orientation:int = 0, n_slices:int = 1
        ) -&gt; list[Union[Polygon, MultiPolygon]]:
        &#34;&#34;&#34;Gets n_slices cells strands with specified total width across the
        grid cell at coords at orientation.

        Args:
            width (float, optional): total width of strands relative to 
                self.spacing. Defaults to 1.0.
            coords (tuple[int], optional): integer grid coordinates of 
                cell. Defaults to None.
            orientation (int, optional): orientation of the strands. 
                Defaults to 0.
            n_slices (int, optional): number of length-wise slices to cut
                strands into. Defaults to 1.

        Returns:
            list[Polygon|MultiPolygon]: polygons representing the strands.
        &#34;&#34;&#34;        
        cell = self.get_grid_cell_at(coords)
        # when aspect is &lt;1 strands extend outside cell by some scale factor
        sf = 2 - width if self.n_axes == 2 else (5 - 3 * width) / 2
        expanded_cell = scale(cell, sf, sf, origin = cell.centroid)
        big_l = (sf * self.spacing      ## rectangular case is simple
                 if self.n_axes == 2    ## triangular less so!
                 else sf * self.spacing * 2 / np.sqrt(3) * (3 - width) / 2)
        strands = MultiPolygon(self._get_grid_cell_slices(L = big_l, W = width,
                                                          n_slices = n_slices))
        # we need centre of cell bounding box to shift strands to 
        # vertical center of triangular cells. In rectangular case
        # this will be (0, 0).
        cell_offset = cell.envelope.centroid.coords[0]
        strands = translate(strands, cell_offset[0], cell_offset[1])
        strands = MultiPolygon([expanded_cell.intersection(s)
                                for s in strands.geoms])
        strands = rotate(strands, orientation, origin = cell.centroid)
        # return [s for s in strands.geoms]
        return [self._gridify(s) for s in strands.geoms]


    def get_visible_cell_strands(
            self, width:float= 1.0, coords:tuple[int] = None, 
            strand_order:tuple[int] = (0, 1, 2), n_slices:tuple[int] = (1, 1, 1)
        ) -&gt; list[Union[Polygon, MultiPolygon]]:
        &#34;&#34;&#34;Returns visible strands in grid cell based on layer order.

        Returns visible parts of the strands in a grid cell, given strand width, strand layer order and the number of slices in each direction.

        Args:
            width (float): total width of strands relative to self.spacing.
                Defaults to 1.0.
            coords (tuple[int], optional): grid cell coordinates. Defaults 
                to None.
            strand_order (tuple[int], optional): order of the layers from top,  
                at this cell site. Defaults to (0, 1, 2).
            n_slices (tuple[int], optional): number of slices in each layer 
                at this cell site. Defaults to (1, 1, 1).

        Returns:
            list[Polygon|MultiPolygon]: those polygons that will be visible at
                this site given requested strand order from the top.
        &#34;&#34;&#34;        
        all_polys = []
        for order in strand_order[:self.n_axes]:
            next_polys = self._get_cell_strands(width, coords, 
                                                self.orientations[order], 
                                                n_slices[order])
            if all_polys == []:
                all_polys.extend(next_polys)
                mask = unary_union(next_polys)
            else:
                all_polys.extend([p.difference(mask) for p in next_polys])
                mask = mask.union(unary_union(next_polys))
        return all_polys


    def get_tile_from_cells(self, approx_tile:Polygon) -&gt; Polygon:
        &#34;&#34;&#34;Returns a rectangle or hexagon derived from the bounds of the
        supplied approximation to a tile.
        
        This is required because we know the required tile is an exact 4 or
        6 cornered polygon, but the MultiPolygon formed by unary_union is likely
        to have many more corners than this (for some reason...).

        Args:
            approx_tile (Polygon): MultiPolygon formed from the cells of the
                tile.

        Returns:
            Polygon (geom.Polygon): rectangle of hexagon Polygon.
        &#34;&#34;&#34;
        xmin, ymin, xmax, ymax = approx_tile.bounds
        if self.n_axes == 2:
            w = np.round((xmax - xmin) / self.spacing) * self.spacing
        else:
            h_spacing = self.spacing * 2 / np.sqrt(3)
            w = np.round((xmax - xmin) / h_spacing) * h_spacing
        h = np.round((ymax - ymin) / self.spacing) * self.spacing
        if self.n_axes == 2:
            return Polygon([(-w/2, -h/2), (w/2, -h/2), (w/2, h/2), (-w/2, h/2)])
        else:
            return Polygon([( w/4, -h/2), ( w/2,    0), ( w/4,  h/2), 
                            (-w/4,  h/2), (-w/2,    0), (-w/4, -h/2)])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.weave_grids.WeaveGrid.basis"><code class="name">var <span class="ident">basis</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.grid_cell"><code class="name">var <span class="ident">grid_cell</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.n_axes"><code class="name">var <span class="ident">n_axes</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.orientations"><code class="name">var <span class="ident">orientations</span> : tuple[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.spacing"><code class="name">var <span class="ident">spacing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.weave_grids.WeaveGrid.get_coordinates"><code class="name flex">
<span>def <span class="ident">get_coordinates</span></span>(<span>self, coords: tuple) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Uses self.basis to determine Cartesian coordinates of cell centroid
from grid coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple[int]</code></dt>
<dd>integer coordinate pair of grid location.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>float coordinate pair of grid cell centroid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinates(self, coords: tuple) -&gt; np.ndarray:
    &#34;&#34;&#34;Uses self.basis to determine Cartesian coordinates of cell centroid
    from grid coordinates.

    Args:
        coords (tuple[int]): integer coordinate pair of grid location.

    Returns:
        np.ndarray: float coordinate pair of grid cell centroid.
    &#34;&#34;&#34;        
    return self.basis @ coords</code></pre>
</details>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.get_grid_cell_at"><code class="name flex">
<span>def <span class="ident">get_grid_cell_at</span></span>(<span>self, coords: tuple[int] = None) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<div class="desc"><p>Returns grid cell polygon centred on coords.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple[int]</code>, optional</dt>
<dd><em>description</em>. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Polygon</code></dt>
<dd>square or triangle centred at the specified coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid_cell_at(self, coords: tuple[int] = None) -&gt; Polygon:
    &#34;&#34;&#34;Returns grid cell polygon centred on coords.

    Args:
        coords (tuple[int], optional): _description_. Defaults to None.

    Returns:
        Polygon: square or triangle centred at the specified coordinates.
    &#34;&#34;&#34;        
    if coords is None:
        coords = tuple([0] * self.n_axes)
    if self.grid_cell is None:
        polygon = self.make_grid_cell()
    else:
        polygon = self.grid_cell
        xy = self.get_coordinates(coords)
        polygon = translate(polygon, xy[0], xy[1])
    if self.n_axes == 2 or sum(coords) %2 == 0:
        return polygon
    else:
        return rotate(polygon, 180, origin = polygon.centroid)</code></pre>
</details>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.get_tile_from_cells"><code class="name flex">
<span>def <span class="ident">get_tile_from_cells</span></span>(<span>self, approx_tile: shapely.geometry.polygon.Polygon) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rectangle or hexagon derived from the bounds of the
supplied approximation to a tile.</p>
<p>This is required because we know the required tile is an exact 4 or
6 cornered polygon, but the MultiPolygon formed by unary_union is likely
to have many more corners than this (for some reason&hellip;).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>approx_tile</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>MultiPolygon formed from the cells of the
tile.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Polygon (geom.Polygon): rectangle of hexagon Polygon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tile_from_cells(self, approx_tile:Polygon) -&gt; Polygon:
    &#34;&#34;&#34;Returns a rectangle or hexagon derived from the bounds of the
    supplied approximation to a tile.
    
    This is required because we know the required tile is an exact 4 or
    6 cornered polygon, but the MultiPolygon formed by unary_union is likely
    to have many more corners than this (for some reason...).

    Args:
        approx_tile (Polygon): MultiPolygon formed from the cells of the
            tile.

    Returns:
        Polygon (geom.Polygon): rectangle of hexagon Polygon.
    &#34;&#34;&#34;
    xmin, ymin, xmax, ymax = approx_tile.bounds
    if self.n_axes == 2:
        w = np.round((xmax - xmin) / self.spacing) * self.spacing
    else:
        h_spacing = self.spacing * 2 / np.sqrt(3)
        w = np.round((xmax - xmin) / h_spacing) * h_spacing
    h = np.round((ymax - ymin) / self.spacing) * self.spacing
    if self.n_axes == 2:
        return Polygon([(-w/2, -h/2), (w/2, -h/2), (w/2, h/2), (-w/2, h/2)])
    else:
        return Polygon([( w/4, -h/2), ( w/2,    0), ( w/4,  h/2), 
                        (-w/4,  h/2), (-w/2,    0), (-w/4, -h/2)])</code></pre>
</details>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.get_visible_cell_strands"><code class="name flex">
<span>def <span class="ident">get_visible_cell_strands</span></span>(<span>self, width: float = 1.0, coords: tuple[int] = None, strand_order: tuple[int] = (0, 1, 2), n_slices: tuple[int] = (1, 1, 1)) ‑> list[typing.Union[shapely.geometry.polygon.Polygon, shapely.geometry.multipolygon.MultiPolygon]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns visible strands in grid cell based on layer order.</p>
<p>Returns visible parts of the strands in a grid cell, given strand width, strand layer order and the number of slices in each direction.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>total width of strands relative to self.spacing.
Defaults to 1.0.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple[int]</code>, optional</dt>
<dd>grid cell coordinates. Defaults
to None.</dd>
<dt><strong><code>strand_order</code></strong> :&ensp;<code>tuple[int]</code>, optional</dt>
<dd>order of the layers from top,<br>
at this cell site. Defaults to (0, 1, 2).</dd>
<dt><strong><code>n_slices</code></strong> :&ensp;<code>tuple[int]</code>, optional</dt>
<dd>number of slices in each layer
at this cell site. Defaults to (1, 1, 1).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list[Polygon|MultiPolygon]: those polygons that will be visible at
this site given requested strand order from the top.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visible_cell_strands(
        self, width:float= 1.0, coords:tuple[int] = None, 
        strand_order:tuple[int] = (0, 1, 2), n_slices:tuple[int] = (1, 1, 1)
    ) -&gt; list[Union[Polygon, MultiPolygon]]:
    &#34;&#34;&#34;Returns visible strands in grid cell based on layer order.

    Returns visible parts of the strands in a grid cell, given strand width, strand layer order and the number of slices in each direction.

    Args:
        width (float): total width of strands relative to self.spacing.
            Defaults to 1.0.
        coords (tuple[int], optional): grid cell coordinates. Defaults 
            to None.
        strand_order (tuple[int], optional): order of the layers from top,  
            at this cell site. Defaults to (0, 1, 2).
        n_slices (tuple[int], optional): number of slices in each layer 
            at this cell site. Defaults to (1, 1, 1).

    Returns:
        list[Polygon|MultiPolygon]: those polygons that will be visible at
            this site given requested strand order from the top.
    &#34;&#34;&#34;        
    all_polys = []
    for order in strand_order[:self.n_axes]:
        next_polys = self._get_cell_strands(width, coords, 
                                            self.orientations[order], 
                                            n_slices[order])
        if all_polys == []:
            all_polys.extend(next_polys)
            mask = unary_union(next_polys)
        else:
            all_polys.extend([p.difference(mask) for p in next_polys])
            mask = mask.union(unary_union(next_polys))
    return all_polys</code></pre>
</details>
</dd>
<dt id="weavingspace.weave_grids.WeaveGrid.setup_basis"><code class="name flex">
<span>def <span class="ident">setup_basis</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the basis of the grid coordinate generation matrix.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.nd.array</code></dt>
<dd>self.n_axes x 2 matrix to generate float coordinates
of cells in Cartesian space from integer grid coordinates of
cells.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_basis(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Sets up the basis of the grid coordinate generation matrix.

    Returns:
        np.nd.array: self.n_axes x 2 matrix to generate float coordinates
            of cells in Cartesian space from integer grid coordinates of
            cells.
    &#34;&#34;&#34;        
    # angles are perpendicular to the direction of their respective strands
    # so e.g. 2nd strand in 3 axis case is at 120, and perpendicular is 210
    if self.n_axes == 2:
        angles = (np.pi / 2, 0)
        dx = [self.spacing * np.cos(a) for a in angles]  # [0, 1]
        dy = [self.spacing * np.sin(a) for a in angles]  # [1, 0]
    elif self.n_axes == 3:
        angles = [np.pi / 6 * x for x in range(3, 12, 4)]  # [90, 210, 330]
        dx = [self.spacing * 2 / 3 * np.cos(a) for a in angles]
        dy = [self.spacing * 2 / 3 * np.sin(a) for a in angles]
    return np.array(dx + dy).reshape(2, self.n_axes)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.weave_grids.WeaveGrid" href="#weavingspace.weave_grids.WeaveGrid">WeaveGrid</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.weave_grids.WeaveGrid.basis" href="#weavingspace.weave_grids.WeaveGrid.basis">basis</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.get_coordinates" href="#weavingspace.weave_grids.WeaveGrid.get_coordinates">get_coordinates</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.get_grid_cell_at" href="#weavingspace.weave_grids.WeaveGrid.get_grid_cell_at">get_grid_cell_at</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.get_tile_from_cells" href="#weavingspace.weave_grids.WeaveGrid.get_tile_from_cells">get_tile_from_cells</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.get_visible_cell_strands" href="#weavingspace.weave_grids.WeaveGrid.get_visible_cell_strands">get_visible_cell_strands</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.grid_cell" href="#weavingspace.weave_grids.WeaveGrid.grid_cell">grid_cell</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.n_axes" href="#weavingspace.weave_grids.WeaveGrid.n_axes">n_axes</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.orientations" href="#weavingspace.weave_grids.WeaveGrid.orientations">orientations</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.setup_basis" href="#weavingspace.weave_grids.WeaveGrid.setup_basis">setup_basis</a></code></li>
<li><code><a title="weavingspace.weave_grids.WeaveGrid.spacing" href="#weavingspace.weave_grids.WeaveGrid.spacing">spacing</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>