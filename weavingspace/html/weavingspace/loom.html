<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weavingspace.loom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.loom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

from dataclasses import dataclass

import numpy as np


# initially in a biaxial weave intersection sites are encoded numerically: 
# 1 = warp is absent
# 2 = weft is absent
# 3 = both threads are absent
# 4 = weft is on top
# 5 = warp is on top 
# this dictionary translates these to tuples listing the &#39;layer&#39; order
# depending on the input axis, where 0 is the biaxial case with layers 0 and 1
# only, and 1 is layers 0 and 1, 2 is layers 1 and 2, and 3 is layers 2 and 0.
decode_orders = (
    {1: (0,  ), 2: (1,  ), 3: (   ), 4: (0, 1), 5: (1, 0)},
    {1: (1,  ), 2: (0,  ), 3: (   ), 4: (1, 0), 5: (0, 1)},
    {1: (2,  ), 2: (1,  ), 3: (   ), 4: (2, 1), 5: (1, 2)},
    {1: (0,  ), 2: (2,  ), 3: (   ), 4: (0, 2), 5: (2, 0)}
)


# Nested dictionary to combine layer orders from 3 biaxial weaves
# into a single consistent order of layers. Inconsistent combinations
# will not return a value. 
# Various other if-elif-else types of approach were tried here, but
# overall, I think this is the cleanest option. 
combined_orderings = {
  (    ): {(    ): {(    ): None,          # All absent
                    (2,  ): (2,  )},       # Only 2 present
           (1,  ): {(    ): (1,  )},       # Only 1 present
           (2,  ): {(2,  ): (2,  )}},      # Only 2 present
  (0,  ): {(    ): {(0,  ): (0,  ),        # Only 0 present
                    (    ): (0,  )},       # Only 0 present
           (2,  ): {(2, 0): (2, 0),        # 0 2 20 --&gt; 2 &gt; 0
                    (0, 2): (0, 2)}},      # 0 2 02 --&gt; 0 &gt; 2
  (1,  ): {(1,  ): {(    ): (1,  )},       # Only 1 present
           (1, 2): {(2,  ): (1, 2)},       # 1 12 2 --&gt; 1 &gt; 2
           (2, 1): {(2,  ): (2, 1)}},      # 1 21 2 --&gt; 2 &gt; 1
  (0, 1): {(1,  ): {(0,  ): (0, 1)},       # 01 1 0 --&gt; 0 &gt; 1
           (1, 2): {(0, 2): (0, 1, 2)},    # 01 12 02 --&gt; 0 &gt; 1 &gt; 2
           (2, 1): {(2, 0): (2, 0, 1),     # 01 21 20 --&gt; 2 &gt; 0 &gt; 1
                    (0, 2): (0, 2, 1)}},   # 01 21 02 --&gt; 0 &gt; 2 &gt; 1
  (1, 0): {(1,  ): {(0,  ): (1, 0)},       # 10 1 0 --&gt; 1 &gt; 0
           (1, 2): {(2, 0): (1, 2, 0),     # 10 12 20 --&gt; 1 &gt; 2 &gt; 0
                    (0, 2): (1, 0, 2)},    # 10 12 02 --&gt; 1 &gt; 0 &gt; 2
           (2, 1): {(2, 0): (2, 1, 0)}}    # 10 21 20 --&gt; 2 &gt; 1 &gt; 0
}


@dataclass
class Loom:
    &#34;&#34;&#34;A collection of weave matrices and associated attributes.
    
    Central to the loom object are the indices and orderings lists. These
    list the grid coordinate pairs and corresponding layer orderings at the
    site indexed by the coordinates. E.g., for a simple plain weave, we have:
    
        indices: [(0, 0), (0, 1), (1, 0), (1, 1)]
        orderings: [(0, 1), (1, 0), (1, 0), (0, 1)]
    
    Attributes:
        indices (list[tuple]): grid coordinate pairs.
        orderings (list[Union[tuple[int],None]]): list of the layer orders at 
            site locations indexed by the corresponding item in indices.
        dimensions (tuple[int]): the maximum coordinate values in each 
            direction.
        orientations (tuple[float]): the angles which strands on each axis 
            make to the x-axis. (0, -90) for 2 axes, (0, 120, 240) for 2 axes.
        n_axes (int): 2 or 3.   
    &#34;&#34;&#34;    
    indices: list[tuple]
    orderings: list
    dimensions: tuple
    orientations: tuple
    n_axes: int
    
    def __init__(self, *matrices:np.ndarray):
        &#34;&#34;&#34;Constructor for a Loom. Takes either one or three weave matrices
        as input and initialises the loom based on these.
        &#34;&#34;&#34;        
        if len(matrices) == 1:
            m = matrices[0]
            self.dimensions = m.shape
            self.n_axes = len(self.dimensions)
            # self.parity = None
            self.orientations = (0, -90)
            self.indices = [(i, j) for i in range(m.shape[0])
                                   for j in range(m.shape[1])]
            self.orderings = [decode_orders[0][m[ij]] for ij in self.indices]
        else:
            nA, nB, nC = [max(m.shape) for m in matrices]
            self.dimensions = (nA, nB, nC)
            self.n_axes = len(self.dimensions)
            self.orientations = (0, 120, 240)
            all_indices = [(i, j, k) for i in range(nA) 
                                     for j in range(nB) 
                                     for k in range(nC)]
            # parity is used to select coordinate triples in the grid see: 
            # Nagy BN 2003. Shortest Paths in Triangular Grids with 
            # Neighbourhood Sequences. Journal of Computing and Information
            # Technology 11 (2):111
            parity = (nA + nB + nC - 3) // 2
            self.indices = [x for x in all_indices 
                            if sum(x) in (parity, parity + 1)]
            m1, m2, m3 = matrices
            # extend the input 2D grids if needed
            mAB = np.tile(m1, (np.lcm(nA, m1.shape[0]) // m1.shape[0],
                               np.lcm(nA, m1.shape[1]) // m1.shape[1]))
            mBC = np.tile(m2, (np.lcm(nB, m2.shape[0]) // m2.shape[0],
                               np.lcm(nB, m2.shape[1]) // m2.shape[1]))
            mCA = np.tile(m3, (np.lcm(nC, m3.shape[0]) // m3.shape[0],
                               np.lcm(nC, m3.shape[1]) // m3.shape[1]))
            # get the layer orders in each using 2 of the 3 coordinates
            ordAB = [decode_orders[1][mAB[ij]] 
                     for ij in [(x[1], x[0]) for x in self.indices]]
            ordBC = [decode_orders[2][mBC[ij]] 
                     for ij in [(x[2], x[1]) for x in self.indices]]
            ordCA = [decode_orders[3][mCA[ij]] 
                     for ij in [(x[0], x[2]) for x in self.indices]]
            # # combine orders from the three matrices stacked 
            self.orderings = [self._combine_orders(abc) 
                              for abc in zip(ordAB, ordBC, ordCA)]


    # convenience wrapper for the combined_orderings dictionary
    # missing values return &#34;NA&#34;
    def _combine_orders(self, orders):
        # print(f&#34;orders: {orders}&#34;)
        try:
            result = combined_orderings[orders[0]][orders[1]][orders[2]]
        except:
            print(f&#34;Unable to determine unique ordering on {orders}&#34;)
            return &#34;NA&#34;
        else:
            return result </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.loom.Loom"><code class="flex name class">
<span>class <span class="ident">Loom</span></span>
<span>(</span><span>*matrices: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>A collection of weave matrices and associated attributes.</p>
<p>Central to the loom object are the indices and orderings lists. These
list the grid coordinate pairs and corresponding layer orderings at the
site indexed by the coordinates. E.g., for a simple plain weave, we have:</p>
<pre><code>indices: [(0, 0), (0, 1), (1, 0), (1, 1)]
orderings: [(0, 1), (1, 0), (1, 0), (0, 1)]
</code></pre>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>list[tuple]</code></dt>
<dd>grid coordinate pairs.</dd>
<dt><strong><code>orderings</code></strong> :&ensp;<code>list[Union[tuple[int],None]]</code></dt>
<dd>list of the layer orders at
site locations indexed by the corresponding item in indices.</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>tuple[int]</code></dt>
<dd>the maximum coordinate values in each
direction.</dd>
<dt><strong><code>orientations</code></strong> :&ensp;<code>tuple[float]</code></dt>
<dd>the angles which strands on each axis
make to the x-axis. (0, -90) for 2 axes, (0, 120, 240) for 2 axes.</dd>
<dt><strong><code>n_axes</code></strong> :&ensp;<code>int</code></dt>
<dd>2 or 3.
</dd>
</dl>
<p>Constructor for a Loom. Takes either one or three weave matrices
as input and initialises the loom based on these.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Loom:
    &#34;&#34;&#34;A collection of weave matrices and associated attributes.
    
    Central to the loom object are the indices and orderings lists. These
    list the grid coordinate pairs and corresponding layer orderings at the
    site indexed by the coordinates. E.g., for a simple plain weave, we have:
    
        indices: [(0, 0), (0, 1), (1, 0), (1, 1)]
        orderings: [(0, 1), (1, 0), (1, 0), (0, 1)]
    
    Attributes:
        indices (list[tuple]): grid coordinate pairs.
        orderings (list[Union[tuple[int],None]]): list of the layer orders at 
            site locations indexed by the corresponding item in indices.
        dimensions (tuple[int]): the maximum coordinate values in each 
            direction.
        orientations (tuple[float]): the angles which strands on each axis 
            make to the x-axis. (0, -90) for 2 axes, (0, 120, 240) for 2 axes.
        n_axes (int): 2 or 3.   
    &#34;&#34;&#34;    
    indices: list[tuple]
    orderings: list
    dimensions: tuple
    orientations: tuple
    n_axes: int
    
    def __init__(self, *matrices:np.ndarray):
        &#34;&#34;&#34;Constructor for a Loom. Takes either one or three weave matrices
        as input and initialises the loom based on these.
        &#34;&#34;&#34;        
        if len(matrices) == 1:
            m = matrices[0]
            self.dimensions = m.shape
            self.n_axes = len(self.dimensions)
            # self.parity = None
            self.orientations = (0, -90)
            self.indices = [(i, j) for i in range(m.shape[0])
                                   for j in range(m.shape[1])]
            self.orderings = [decode_orders[0][m[ij]] for ij in self.indices]
        else:
            nA, nB, nC = [max(m.shape) for m in matrices]
            self.dimensions = (nA, nB, nC)
            self.n_axes = len(self.dimensions)
            self.orientations = (0, 120, 240)
            all_indices = [(i, j, k) for i in range(nA) 
                                     for j in range(nB) 
                                     for k in range(nC)]
            # parity is used to select coordinate triples in the grid see: 
            # Nagy BN 2003. Shortest Paths in Triangular Grids with 
            # Neighbourhood Sequences. Journal of Computing and Information
            # Technology 11 (2):111
            parity = (nA + nB + nC - 3) // 2
            self.indices = [x for x in all_indices 
                            if sum(x) in (parity, parity + 1)]
            m1, m2, m3 = matrices
            # extend the input 2D grids if needed
            mAB = np.tile(m1, (np.lcm(nA, m1.shape[0]) // m1.shape[0],
                               np.lcm(nA, m1.shape[1]) // m1.shape[1]))
            mBC = np.tile(m2, (np.lcm(nB, m2.shape[0]) // m2.shape[0],
                               np.lcm(nB, m2.shape[1]) // m2.shape[1]))
            mCA = np.tile(m3, (np.lcm(nC, m3.shape[0]) // m3.shape[0],
                               np.lcm(nC, m3.shape[1]) // m3.shape[1]))
            # get the layer orders in each using 2 of the 3 coordinates
            ordAB = [decode_orders[1][mAB[ij]] 
                     for ij in [(x[1], x[0]) for x in self.indices]]
            ordBC = [decode_orders[2][mBC[ij]] 
                     for ij in [(x[2], x[1]) for x in self.indices]]
            ordCA = [decode_orders[3][mCA[ij]] 
                     for ij in [(x[0], x[2]) for x in self.indices]]
            # # combine orders from the three matrices stacked 
            self.orderings = [self._combine_orders(abc) 
                              for abc in zip(ordAB, ordBC, ordCA)]


    # convenience wrapper for the combined_orderings dictionary
    # missing values return &#34;NA&#34;
    def _combine_orders(self, orders):
        # print(f&#34;orders: {orders}&#34;)
        try:
            result = combined_orderings[orders[0]][orders[1]][orders[2]]
        except:
            print(f&#34;Unable to determine unique ordering on {orders}&#34;)
            return &#34;NA&#34;
        else:
            return result </code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.loom.Loom.dimensions"><code class="name">var <span class="ident">dimensions</span> : tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.loom.Loom.indices"><code class="name">var <span class="ident">indices</span> : list[tuple]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.loom.Loom.n_axes"><code class="name">var <span class="ident">n_axes</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.loom.Loom.orderings"><code class="name">var <span class="ident">orderings</span> : list</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.loom.Loom.orientations"><code class="name">var <span class="ident">orientations</span> : tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.loom.Loom" href="#weavingspace.loom.Loom">Loom</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.loom.Loom.dimensions" href="#weavingspace.loom.Loom.dimensions">dimensions</a></code></li>
<li><code><a title="weavingspace.loom.Loom.indices" href="#weavingspace.loom.Loom.indices">indices</a></code></li>
<li><code><a title="weavingspace.loom.Loom.n_axes" href="#weavingspace.loom.Loom.n_axes">n_axes</a></code></li>
<li><code><a title="weavingspace.loom.Loom.orderings" href="#weavingspace.loom.Loom.orderings">orderings</a></code></li>
<li><code><a title="weavingspace.loom.Loom.orientations" href="#weavingspace.loom.Loom.orientations">orientations</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>