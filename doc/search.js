window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "weavingspace", "modulename": "weavingspace", "kind": "module", "doc": "<p>See <a href=\"https://github.com/DOSull/weaving-space/blob/main/using-the-library.ipynb\">this notebook</a> for some preliminary usage notes.</p>\n"}, {"fullname": "weavingspace.symmetry", "modulename": "weavingspace.symmetry", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavingspace.symmetry.KMP_Matcher", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher", "kind": "class", "doc": "<p>Class to find matching subsequences in a sequence.</p>\n"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.__init__", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.sequence", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.sequence", "kind": "variable", "doc": "<p>Iterable in which subsequences are to be found.</p>\n", "annotation": ": Iterable"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.find_matches", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.find_matches", "kind": "function", "doc": "<p>Implements Knuth-Morris-Pratt string pattern matching algorithm. See:\n<a href=\"https://en.wikipedia.org/wiki/Knuth\u2013Morris\u2013Pratt_algorithm\">https://en.wikipedia.org/wiki/Knuth\u2013Morris\u2013Pratt_algorithm</a> which provides\ndetailed pseudo-code on which this code is directly based. See also:</p>\n\n<p>Knuth DE, JH Morris Jr, and VR Pratt. 1977. Fast pattern  matching in \nstrings. SIAM Journal on Computing 6(2): 323\u2013350. doi: 10.1137/0206024.</p>\n\n<p>This implementation expects sequences of tuples of floats, although in \nprinciple any objects could be contained in the Iterables.</p>\n\n<p>Args:\n  pat (Iterable[tuple[float]]): The sequence to match.</p>\n\n<p>Returns:\n  Iterable[int]: _description_</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pat</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform", "modulename": "weavingspace.symmetry", "qualname": "Transform", "kind": "class", "doc": "<p>Class to store details of a transform and draw it.</p>\n"}, {"fullname": "weavingspace.symmetry.Transform.__init__", "modulename": "weavingspace.symmetry", "qualname": "Transform.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transform_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.Transform.transform_type", "modulename": "weavingspace.symmetry", "qualname": "Transform.transform_type", "kind": "variable", "doc": "<p>Type of transform, 'rotation', 'reflection', 'translation' or 'identity'.</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.symmetry.Transform.angle", "modulename": "weavingspace.symmetry", "qualname": "Transform.angle", "kind": "variable", "doc": "<p>Angle of rotation (degrees).</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.symmetry.Transform.centre", "modulename": "weavingspace.symmetry", "qualname": "Transform.centre", "kind": "variable", "doc": "<p>Centre of the transformation.</p>\n", "annotation": ": shapely.geometry.point.Point"}, {"fullname": "weavingspace.symmetry.Transform.translation", "modulename": "weavingspace.symmetry", "qualname": "Transform.translation", "kind": "variable", "doc": "<p>X and Y coordinates shifts of a translation transform. A glide reflection\nmay also include this.</p>\n", "annotation": ": tuple[float]"}, {"fullname": "weavingspace.symmetry.Transform.transform", "modulename": "weavingspace.symmetry", "qualname": "Transform.transform", "kind": "variable", "doc": "<p>Six element tuple for the transform in shapely.transform format. See\n<a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a> and\nmethods in <code>weavingspace.tiling_utils</code>.</p>\n", "annotation": ": tuple[float]"}, {"fullname": "weavingspace.symmetry.Transform.offset", "modulename": "weavingspace.symmetry", "qualname": "Transform.offset", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "weavingspace.symmetry.Transform.apply", "modulename": "weavingspace.symmetry", "qualname": "Transform.apply", "kind": "function", "doc": "<p>Applies this transform to supplied shapely geometry and returns result.</p>\n\n<p>Args:\n  geometry (Any): a shapely geometry to transform.</p>\n\n<p>Returns:\n  Any: the resulting transformed shapely geometry.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw", "kind": "function", "doc": "<p>Draws this transform on the supplied axes. Arguments specific to each\ntransform type are supplied as **kwargs and are documented in \n<code>draw_rotation</code>, <code>draw_reflection</code>, and <code>draw_translation</code>.</p>\n\n<p>Args:\n    ax (pyplot.axes): the axes on which to draw the transform.</p>\n\n<p>Returns:\n    pyplot.Axes: the axes with the rendering of this transform added.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">axes</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_rotation", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_rotation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">200</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_reflection", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_reflection", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">mirror_length</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_translation", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_translation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries", "kind": "class", "doc": "<p>Class to store the symmetries (as a list of <code>Transform</code> objects) of a\nsupplied shapely.Polygon.</p>\n"}, {"fullname": "weavingspace.symmetry.Symmetries.__init__", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.Symmetries.polygon", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.polygon", "kind": "variable", "doc": "<p>Polygon from which these symmetries are derived.</p>\n", "annotation": ": shapely.geometry.polygon.Polygon", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.matcher", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.matcher", "kind": "variable", "doc": "<p>the subsequence matcher used in symmetry detection.</p>\n", "annotation": ": weavingspace.symmetry.KMP_Matcher", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.n", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.n", "kind": "variable", "doc": "<p>number of vertices of the polygon.</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.p_code", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.p_code", "kind": "variable", "doc": "<p>the encoding of the polygon as sequence of length, angle pairs.</p>\n", "annotation": ": list[tuple[float]]", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.p_code_r", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.p_code_r", "kind": "variable", "doc": "<p>the reversed encoding used to detect reflection symmetries.</p>\n", "annotation": ": list[tuple[float]]", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.rotation_shifts", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.rotation_shifts", "kind": "variable", "doc": "<p>list of number of 2pi/n rotation symmetries.</p>\n", "annotation": ": list[int]", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.reflection_shifts", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.reflection_shifts", "kind": "variable", "doc": "<p>list of pi/n relection angle symmetries.</p>\n", "annotation": ": list[int]", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.symmetries", "kind": "variable", "doc": "<p>list of Transform objects with more complete information.</p>\n", "annotation": ": list[weavingspace.symmetry.Transform]", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.symmetry_group", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.symmetry_group", "kind": "variable", "doc": "<p>the code denoting the symmetry group</p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "weavingspace.symmetry.Symmetries.get_symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_symmetries", "kind": "function", "doc": "<p>Finds rotation and reflection symmetries of the supplied polygon.\nBased on</p>\n\n<p>Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and \n  Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology. \n  North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.</p>\n\n<p>and also</p>\n\n<p>Wolter JD, TC Woo, and RA Volz. 1985. Optimal algorithms for symmetry \n  detection in two and three dimensions. The Visual Computer 1(1): 37-48. \n  doi: 10.1007/BF01901268.</p>\n\n<p>Details in these papers are not unambiguous. This implementation was\ndeveloped based on them, but with a lot of trial and error to get the index\noffsets and (especially) retrieval of the reflection axes angles to work.</p>\n\n<p>Args:\n  other (geom.Polygon, optional): finds transforms between this polygon and \n    another that may be supplied. Defaults to None, when the comparison \n    polygon will be that for which this Symmetries object has been <br />\n    initialised.</p>\n\n<p>Returns:\n  list[Transform]: a list of Transform objects representing the polygon\n    symmetries.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">other_polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_rotations", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_rotations", "kind": "function", "doc": "<p>Gets the rotations associated with this collection of symmetries.</p>\n\n<p>Returns:\n  list[Transform]: A list of the rotation symmetries associated with this\n    polygon.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_reflections", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_reflections", "kind": "function", "doc": "<p>Gets the reflections associated with this collection of symmetries.</p>\n\n<p>Returns:\n  list[Transform]: A list of the reflection symmetries associated with this\n    polygon.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_symmetry_group_code", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_symmetry_group_code", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_corner_offset", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_corner_offset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">poly2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_corner_labels", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_corner_labels", "kind": "function", "doc": "<p>Returns all the reorderings of vertex labels corresponding to each\nsymmetry.</p>\n\n<p>Returns:\n  dict[str, list[str]]: A dictionary with two entries. \"rotations\" is\n    a list of labels under the rotation symmetries, \"reflections\" those\n    under the reflection symmetries.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_unique_labels", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_unique_labels", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.plot", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">as_image</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.StraightLine", "modulename": "weavingspace.symmetry", "qualname": "StraightLine", "kind": "class", "doc": "<p>Named tuple to represent equation of a straight line in standard \nAx + By + C = 0 form.</p>\n", "bases": "builtins.tuple"}, {"fullname": "weavingspace.symmetry.StraightLine.__init__", "modulename": "weavingspace.symmetry", "qualname": "StraightLine.__init__", "kind": "function", "doc": "<p>Create new instance of StraightLine(A, B, C)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">C</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.StraightLine.A", "modulename": "weavingspace.symmetry", "qualname": "StraightLine.A", "kind": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "weavingspace.symmetry.StraightLine.B", "modulename": "weavingspace.symmetry", "qualname": "StraightLine.B", "kind": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "weavingspace.symmetry.StraightLine.C", "modulename": "weavingspace.symmetry", "qualname": "StraightLine.C", "kind": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "weavingspace.symmetry.Shape_Matcher", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.__init__", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.shape", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.shape", "kind": "variable", "doc": "<p></p>\n", "annotation": ": shapely.geometry.polygon.Polygon"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.s1", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.s1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": weavingspace.symmetry.Symmetries"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.other", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.other", "kind": "variable", "doc": "<p></p>\n", "annotation": ": shapely.geometry.polygon.Polygon"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.centre", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.centre", "kind": "variable", "doc": "<p></p>\n", "annotation": ": shapely.geometry.point.Point"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.translation", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.translation", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[float]"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.matches", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.matches", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[weavingspace.symmetry.Transform]"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.identity_transform", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.identity_transform", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[float]", "default_value": "(1, 0, 0, 1, 0, 0)"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.get_polygon_matches", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.get_polygon_matches", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.get_angle_between_polygons", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.get_angle_between_polygons", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">corners1</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">corners2</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.get_straight_line", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.get_straight_line", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">perpendicular</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Shape_Matcher.get_intersection", "modulename": "weavingspace.symmetry", "qualname": "Shape_Matcher.get_intersection", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">line1</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span>,</span><span class=\"param\">\t<span class=\"n\">line2</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map", "modulename": "weavingspace.tile_map", "kind": "module", "doc": "<p>Classes for tiling maps. <code>weavingspace.tile_map.Tiling</code> and\n<code>weavingspace.tile_map.TiledMap</code> are exposed in the  public API and\nrespectively enable creation of a tiling and plotting of the tiling as a\nmultivariate map.</p>\n"}, {"fullname": "weavingspace.tile_map.Tiling", "modulename": "weavingspace.tile_map", "qualname": "Tiling", "kind": "class", "doc": "<p>Class that applies a <code>Tileable</code> object to a region to be mapped.</p>\n\n<p>The result of the tiling procedure is stored in the <code>tiles</code> variable and\ncovers a region sufficient that the tiling can be rotated to any desired\nangle.</p>\n"}, {"fullname": "weavingspace.tile_map.Tiling.__init__", "modulename": "weavingspace.tile_map", "qualname": "Tiling.__init__", "kind": "function", "doc": "<p>Class to persist a tiling by filling an area relative to\na region sufficient to apply the tiling at any rotation.</p>\n\n<p>The Tiling constructor allows a number of adjustments to the supplied\n<code>weavingspace.tileable.Tileable</code> object:</p>\n\n<ul>\n<li><code>prototile_margin</code> values greater than 0 will introduce spacing of\nthe specified distance between tiles on the boundary of each tile\nby applying the <code>TileUnit.inset_prototile()</code> method. Note that this\noperation does not make sense for <code>WeaveUnit</code> objects,\nand may not preserve the equality of tile areas.</li>\n<li><code>tiles_sf</code> values less than one scale down tiles by applying the \n<code>TileUnit.scale_tiles()</code> method. Does not make sense for <code>WeaveUnit</code> \nobjects.</li>\n<li><code>tiles_margin</code> values greater than one apply a negative buffer of\nthe specified distance to every tile in the tiling by applying the\n<code>Tileable.inset_tiles()</code> method. This option is applicable to both\n<code>WeaveUnit</code> and <code>TileUnit</code> objects.</li>\n</ul>\n\n<p>Args:\n  unit (Tileable): the tile_unit to use.\n  region (gpd.GeoDataFrame): the region to be tiled.\n  prototile_margin (float, optional): values greater than 0 apply an\n    inset margin to the tile unit. Defaults to 0.\n  tiles_sf (float, optional): scales the tiles. Defaults to 1.\n  tiles_margin (float, optional): applies a negative buffer to\n    the tiles. Defaults to 0.\n  as_icons (bool, optional): if True prototiles will only be placed at\n    the region's zone centroids, one per zone. Defaults to\n    False.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>,</span><span class=\"param\">\t<span class=\"n\">region</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">id_var</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prototile_margin</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">tiles_sf</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">tiles_margin</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">as_icons</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "weavingspace.tile_map.Tiling.tile_unit", "modulename": "weavingspace.tile_map", "qualname": "Tiling.tile_unit", "kind": "variable", "doc": "<p>tileable on which the tiling is based.</p>\n", "annotation": ": weavingspace.tileable.Tileable", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.tile_shape", "modulename": "weavingspace.tile_map", "qualname": "Tiling.tile_shape", "kind": "variable", "doc": "<p>base shape of the tileable.</p>\n", "annotation": ": weavingspace.tileable.TileShape", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.region", "modulename": "weavingspace.tile_map", "qualname": "Tiling.region", "kind": "variable", "doc": "<p>the region to be tiled.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.region_union", "modulename": "weavingspace.tile_map", "qualname": "Tiling.region_union", "kind": "variable", "doc": "<p></p>\n", "annotation": ": shapely.geometry.polygon.Polygon", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.grid", "modulename": "weavingspace.tile_map", "qualname": "Tiling.grid", "kind": "variable", "doc": "<p>the grid which will be used to apply the tiling.</p>\n", "annotation": ": weavingspace.tile_map._TileGrid", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.tiles", "modulename": "weavingspace.tile_map", "qualname": "Tiling.tiles", "kind": "variable", "doc": "<p>the tiles after tiling has been carried out.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.prototiles", "modulename": "weavingspace.tile_map", "qualname": "Tiling.prototiles", "kind": "variable", "doc": "<p>the prototiles after tiling has been carried out.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tile_map.Tiling.rotation", "modulename": "weavingspace.tile_map", "qualname": "Tiling.rotation", "kind": "variable", "doc": "<p>the cumulative rotation already applied to the tiling.</p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "weavingspace.tile_map.Tiling.get_tiled_map", "modulename": "weavingspace.tile_map", "qualname": "Tiling.get_tiled_map", "kind": "function", "doc": "<p>Returns a <code>TiledMap</code> filling a region at the requested rotation.</p>\n\n<p>HERE BE DRAGONS! This function took a lot of trial and error to get\nright, so modify with CAUTION!</p>\n\n<p>The <code>proritise_tiles = True</code> option means that the tiling will not\nbreak up the tiles in <code>TileUnit</code>s at the boundaries between areas\nin the mapped region, but will instead ensure that tiles remain\ncomplete, picking up their data from the region zone which they overlap\nthe most.</p>\n\n<p>The exact order in which operations are performed affects performance.\nFor example, the final clipping to self.region when ragged_edges =\nFalse is _much_ slower if it is carried out before the dissolving of\ntiles into the region zones. So... again... modify CAREFULLY!</p>\n\n<p>Args:\n  rotation (float, optional): An optional rotation to apply. Defaults\n    to 0.\n  join_on_prototiles (bool, optional): if True data from the region\n    dataset are joined to tiles based on the prototile to which they\n    belong. If False the join is based on the tiles in relation to the\n    region areas. For weave-based tilings False is probably to be\n    preferred. Defaults to True.\n  prioritise_tiles (bool, optional): if True tiles will not be\n    broken at boundaries in the region dataset. Defaults to True.\n  ragged_edges (bool, optional): if True tiles at the edge of the\n    region will not be cut by the region extent - ignored if\n    prioritise_tiles is False when edges will always be clipped to\n    the region extent. Defaults to True.\n  use_centroid_lookup_approximation (bool, optional): if True use\n    tile centroids for lookup of region data - ignored if\n    prioritise_tiles is False when it is irrelevant. Defaults to\n    False.\n  debug (bool, optional): if True prints timing messages. Defaults\n    to False.</p>\n\n<p>Returns:\n  TiledMap: a TiledMap of the source region.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">join_on_prototiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prioritise_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">ragged_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_centroid_lookup_approximation</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_map</span><span class=\"o\">.</span><span class=\"n\">TiledMap</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.Tiling.make_tiling", "modulename": "weavingspace.tile_map", "qualname": "Tiling.make_tiling", "kind": "function", "doc": "<p>Tiles the region with a tile unit, returning a GeoDataFrame</p>\n\n<p>Returns:\n  geopandas.GeoDataFrame: a GeoDataFrame of the region tiled with the\n    tile unit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.Tiling.rotated", "modulename": "weavingspace.tile_map", "qualname": "Tiling.rotated", "kind": "function", "doc": "<p>Returns the stored tiling rotated.</p>\n\n<p>Args:\n  rotation (float, optional): Rotation angle in degrees.\n    Defaults to None.</p>\n\n<p>Returns:\n  gpd.GeoDataFrame: Rotated tiling.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap", "modulename": "weavingspace.tile_map", "qualname": "TiledMap", "kind": "class", "doc": "<p>Class representing a tiled map. Should not be accessed directly, but\nwill be created by calling <code>Tiling.get_tiled_map()</code>. After creation the\nvariables and colourmaps attributes can be set, and then\n<code>TiledMap.render()</code> called to make a map. Settable attributes are explained\nin documentation of the <code>TiledMap.render()</code> method.</p>\n\n<p>Examples:\n  Recommended usage is as follows. First, make a <code>TiledMap</code> from a <code>Tiling</code> object.</p>\n\n<pre><code>tm = tiling.get_tiled_map(...)\n</code></pre>\n\n<p>Some options in the <code>Tiling</code> constructor affect the map appearance. See\n  <code>Tiling</code> for details.</p>\n\n<p>Once a <code>TiledMap</code> object exists, set options on it, either when calling\n  <code>TiledMap.render()</code> or explicitly, i.e.</p>\n\n<pre><code>tm.render(opt1 = val1, opt2 = val2, ...)\n</code></pre>\n\n<p>or</p>\n\n<pre><code>tm.opt1 = val1\ntm.opt2 = val2\ntm.render()\n</code></pre>\n\n<p>Option settings are persistent, i.e. unless a new <code>TiledMap</code> object is\n  created the option settings have to be explicitly reset to default\n  values on subsequent calls to <code>TiledMap.render()</code>.</p>\n\n<p>The most important options are the <code>variables</code> and <code>colourmaps</code>\n  settings.</p>\n\n<p><code>variables</code> is a dictionary mapping <code>weavingspace.tileable.Tileable</code>\n  tile_ids (usually \"a\", \"b\", etc.) to variable names in the data. For\n  example,</p>\n\n<pre><code>tm.variables = dict(zip([\"a\", \"b\"], [\"population\", \"income\"]))\n</code></pre>\n\n<p><code>colourmaps</code> is a dictionary mapping dataset variable names to the\n  matplotlib colourmap to be used for each. For example,</p>\n\n<pre><code>tm.colourmaps = dict(zip(tm.variables.values(), [\"Reds\", \"Blues\"]))\n</code></pre>\n\n<p>See <a href=\"https://github.com/DOSull/weaving-space/blob/main/weavingspace/example-tiles-cairo.ipynb\">this notebook</a>\n  for simple usage.\n  TODO: This more complicated example shows how categorical maps can be\n  created.</p>\n"}, {"fullname": "weavingspace.tile_map.TiledMap.__init__", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tiling</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_map</span><span class=\"o\">.</span><span class=\"n\">Tiling</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"nb\">map</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">variables</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">colourmaps</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">legend_zoom</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">legend_dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">legend_dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">use_ellipse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ellipse_magnification</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">radial_key</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">draft_mode</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">scheme</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;equalinterval&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">dpi</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">72</span></span>)</span>"}, {"fullname": "weavingspace.tile_map.TiledMap.tiling", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.tiling", "kind": "variable", "doc": "<p>the Tiling with the required tiles</p>\n", "annotation": ": weavingspace.tile_map.Tiling", "default_value": "None"}, {"fullname": "weavingspace.tile_map.TiledMap.map", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.map", "kind": "variable", "doc": "<p>the GeoDataFrame on which this map is based</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tile_map.TiledMap.variables", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.variables", "kind": "variable", "doc": "<p>lookup from tile_id to variable names</p>\n", "annotation": ": dict[str, str]", "default_value": "None"}, {"fullname": "weavingspace.tile_map.TiledMap.colourmaps", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.colourmaps", "kind": "variable", "doc": "<p>lookup from variables to matplotlib cmaps</p>\n", "annotation": ": dict[str, typing.Union[str, dict]]", "default_value": "None"}, {"fullname": "weavingspace.tile_map.TiledMap.legend", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend", "kind": "variable", "doc": "<p>whether or not to show a legend</p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_zoom", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_zoom", "kind": "variable", "doc": "<p>&lt;1 zooms out from legend to show more context</p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_dx", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_dx", "kind": "variable", "doc": "<p>x shift of legend relative to the map</p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_dy", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_dy", "kind": "variable", "doc": "<p>y shift of legend relative to the map</p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "weavingspace.tile_map.TiledMap.use_ellipse", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.use_ellipse", "kind": "variable", "doc": "<p>if True clips legend with an ellipse</p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "weavingspace.tile_map.TiledMap.ellipse_magnification", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.ellipse_magnification", "kind": "variable", "doc": "<p>magnification to apply to clip ellipse</p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "weavingspace.tile_map.TiledMap.radial_key", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.radial_key", "kind": "variable", "doc": "<p>if True use radial key even for ordinal/ratio data (normally these will be \nshown by concentric tile geometries)</p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "weavingspace.tile_map.TiledMap.draft_mode", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.draft_mode", "kind": "variable", "doc": "<p>if True plot the map coloured by tile_id</p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "weavingspace.tile_map.TiledMap.scheme", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.scheme", "kind": "variable", "doc": "<p>geopandas scheme to apply</p>\n", "annotation": ": str", "default_value": "&#x27;equalinterval&#x27;"}, {"fullname": "weavingspace.tile_map.TiledMap.k", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.k", "kind": "variable", "doc": "<p>geopandas number of classes to apply</p>\n", "annotation": ": int", "default_value": "100"}, {"fullname": "weavingspace.tile_map.TiledMap.figsize", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.figsize", "kind": "variable", "doc": "<p>maptlotlib figsize</p>\n", "annotation": ": tuple[float]", "default_value": "(20, 15)"}, {"fullname": "weavingspace.tile_map.TiledMap.dpi", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.dpi", "kind": "variable", "doc": "<p>dpi for bitmap formats</p>\n", "annotation": ": float", "default_value": "72"}, {"fullname": "weavingspace.tile_map.TiledMap.render", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.render", "kind": "function", "doc": "<p>Renders the current state to a map.</p>\n\n<p>Note that TiledMap objects will usually be created by calling\n<code>Tiling.get_tiled_map()</code>.</p>\n\n<p>Args:\n  variables (dict[str,str]): Mapping from tile_id values to\n    variable names. Defaults to None.\n  colourmaps (dict[str,Union[str,dict]]): Mapping from variable\n    names to colour map, either a colour palette as used by\n    geopandas/matplotlib, a fixed colour, or a dictionary mapping\n    categorical data values to colours. Defaults to None.\n  legend (bool): If True a legend will be drawn. Defaults to True.\n  legend_zoom (float): Zoom factor to apply to the legend. Values &lt;1\n    will show more of the tile context. Defaults to 1.0.\n  legend_dx (float): x shift to apply to the legend position.\n    Defaults to 0.0.\n  legend_dy (float): x and y shift to apply to the legend position.\n    Defaults to 0.0.\n  use_ellipse (bool): If True applies an elliptical clip to the\n    legend. Defaults to False.\n  ellipse_magnification (float): Magnification to apply to ellipse\n    clipped legend. Defaults to 1.0.\n  radial_key (bool): If True legend key for TileUnit maps will be\n    based on radially dissecting the tiles. Defaults to False.\n  draft_mode (bool): If True a map of the tiled map coloured by\n    tile_ids (and with no legend) is returned. Defaults to False.\n  scheme (str): passed to geopandas.plot for numeric data. Defaults to\n    \"equalinterval\".\n  k (int): passed to geopandas.plot for numeric data. Defaults to 100.\n  figsize (tuple[float,floar]): plot dimensions passed to geopandas.\n    plot. Defaults to (20,15).\n  dpi (float): passed to pyplot.plot. Defaults to 72.\n  **kwargs: other settings to pass to pyplot/geopandas.plot.</p>\n\n<p>Returns:\n  matplotlib.figure.Figure: figure on which map is plotted.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.to_file", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.to_file", "kind": "function", "doc": "<p>Outputs the tiled map to a layered GPKG file.</p>\n\n<p>Currently delegates to <code>weavingspace.tiling_utils.write_map_to_layers()</code>.</p>\n\n<p>Args:\n  fname (str, optional): Filename to write. Defaults to None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.plot_legend", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.plot_legend", "kind": "function", "doc": "<p>Plots a legend for this tiled map.</p>\n\n<p>Args:\n  ax (pyplot.Axes, optional): axes to draw legend. Defaults to None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.explore", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.explore", "kind": "function", "doc": "<p>TODO: add wrapper to make tiled web map via geopandas.explore.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_unit", "modulename": "weavingspace.tile_unit", "kind": "module", "doc": "<p>The <code>TileUnit</code> subclass of <code>weavingspace.tileable.Tileable</code> implements\nmany 'conventional' tilings of the plane.</p>\n\n<p>Examples:\n  A <code>TileUnit</code> is initialised like this</p>\n\n<pre><code>tile_unit = TileUnit(tiling_type = \"cairo\")\n</code></pre>\n\n<p>The <code>tiling_type</code> may be one of the following</p>\n\n<ul>\n<li>\"cairo\" the Cairo tiling more formally known as the Laves\n[3<sup>2</sup>.4.3.4] tiling. The author's favourite tiling, hence it\nhas its own tiling_type.</li>\n<li>\"hex-slice\" a range of dissections of the regular hexagon into,\n2, 3, 4, 6, or 12 'pie slices'. The number of slices is set by\nspecifying an additional argument <code>n</code>. Slices are cut either starting\nat the corners of  the hexagon or from the midpoints of hexagon edges,\nby specifying an additional argument <code>offset</code> set to either\n0 or 1 respectively.</li>\n<li>\"hex-dissection\" a range of 4, 7 or 9-fold dissections of the hexagon.  </li>\n<li>\"laves\" a range of isohedral tilings. See <a href=\"https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings\">this article</a>.\nThe desired tiling is specified by the additional argument <code>code</code> which\nis a string like \"3.3.4.3.4\".</li>\n<li>\"archimedean\" a range of tilings by regular polygons. See <a href=\"https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons#Archimedean,_uniform_or_semiregular_tilings\">this\narticle</a>. Many of these are the dual tilings of\nthe Laves tilings. The desired tiling is specified by the additional\nargument <code>code</code> which is a string like \"3.3.4.3.4\". Not all the\npossible Archimedean tilings are implemented.</li>\n<li>\"hex-colouring\" three colourings of the regular hexagon tiling, of\neither 3, 4, or 7 colours, as specified by the argument <code>n</code>.</li>\n<li><p>\"square-colouring\" one colouring of the regular square tiling, of 5\ncolours as specified by the argument <code>n = 5</code>.</p>\n\n<p>See <a href=\"https://github.com/DOSull/weaving-space/blob/main/weavingspace/all-the-tiles.ipynb\">this notebook</a> for exact usage, and illustrations of\neach tiling.</p>\n\n<p>Spacing and coordinate reference of the tile unit are specified by the\n<code>weavingspace.tileable.Tileable</code> superclass variables\n<code>weavingspace.tileable.Tileable.spacing</code> and\n<code>weavingspace.tileable.Tileable.crs</code>.</p>\n\n<p>Base tilings by squares, hexagons or triangles can also be requested\nusing</p>\n\n<p>tile_unit = TileUnit()  # square tiling, the default\ntile_unit = TileUnit(tile_shape = TileShape.HEXAGON)\ntile_unit = TileUnit(tile_shape = TileShape.TRIANGLE)</p>\n\n<p>The first two of these have only one tile_id value, and so cannot be\nused for multivariate mapping. The triangle case has two tile_id\nvalues so may be useful in its base form.</p>\n\n<p>To create custom tilings start from one of the base tiles above, and\nexplicitly set the <code>weavingspace.tileable.Tileable.tiles</code> variable\nby geometric construction of suitable shapely.geometry.Polygons. TODO: A detailed example of this usage can be found here ....</p></li>\n</ul>\n"}, {"fullname": "weavingspace.tile_unit.TileUnit", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit", "kind": "class", "doc": "<p>Class to represent the tiles of a 'conventional' tiling.</p>\n", "bases": "weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.tile_unit.TileUnit.__init__", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavingspace.tile_unit.TileUnit.tiling_type", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.tiling_type", "kind": "variable", "doc": "<p>tiling type as detailed in the class documentation preamble.</p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "weavingspace.tile_unit.TileUnit.offset", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.offset", "kind": "variable", "doc": "<p>offset for 'hex-dissection' and 'hex-slice tilings. Defaults to 1.</p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "weavingspace.tile_unit.TileUnit.n", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.n", "kind": "variable", "doc": "<p>number of dissections or colours in 'hex-dissection', 'hex-slice' and\n'hex-colouring' tilings. Defaults to 3.</p>\n", "annotation": ": int", "default_value": "3"}, {"fullname": "weavingspace.tile_unit.TileUnit.code", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.code", "kind": "variable", "doc": "<p>tne code for 'laves' or 'archimedean' tiling types.</p>\n", "annotation": ": str", "default_value": "&#x27;3.3.4.3.4&#x27;"}, {"fullname": "weavingspace.tile_unit.TileUnit.inset_prototile", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.inset_prototile", "kind": "function", "doc": "<p>Returns a new TileUnit clipped by <code>self.regularised_tile</code> after\na negative buffer d has been applied.</p>\n\n<p>Args:\n  d (float, optional): the inset distance. Defaults to 0.</p>\n\n<p>Returns:\n  TileUnit: the new TileUnit with inset applied.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_unit.TileUnit.scale_tiles", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.scale_tiles", "kind": "function", "doc": "<p>Scales the tiles by the specified factor, centred on (0, 0).</p>\n\n<p>Args:\n  sf (float, optional): scale factor to apply. Defaults to 1.</p>\n\n<p>Returns:\n  TileUnit: the scaled TileUnit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sf</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable", "modulename": "weavingspace.tileable", "kind": "module", "doc": "<p>Implements <code>weavingspace.tileable.TileShape</code> and\n<code>weavingspace.tileable.Tileable</code> the base classes for\n<code>weavingspace.tile_unit.TileUnit</code> and <code>weavingspace.weave_unit.WeaveUnit</code>.</p>\n\n<p><code>Tileable</code> should not be called directly, but is instead accessed from the\n<code>weavingspace.tile_unit.TileUnit</code> or <code>weavingspace.weave_unit.WeaveUnit</code>\nconstructor.</p>\n\n<p>Several methods of <code>weavingspace.tileable.Tileable</code> are generally useful and\ncan be accessed through its subclasses.</p>\n"}, {"fullname": "weavingspace.tileable.TileShape", "modulename": "weavingspace.tileable", "qualname": "TileShape", "kind": "class", "doc": "<p>The available base tile shapes.</p>\n\n<p>NOTE: the TRIANGLE type does not persist, but should be converted to a\nDIAMOND or HEXAGON type during <code>Tileable</code> construction.</p>\n", "bases": "enum.Enum"}, {"fullname": "weavingspace.tileable.TileShape.RECTANGLE", "modulename": "weavingspace.tileable", "qualname": "TileShape.RECTANGLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.RECTANGLE: &#x27;rectangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.HEXAGON", "modulename": "weavingspace.tileable", "qualname": "TileShape.HEXAGON", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.HEXAGON: &#x27;hexagon&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.TRIANGLE", "modulename": "weavingspace.tileable", "qualname": "TileShape.TRIANGLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.TRIANGLE: &#x27;triangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.DIAMOND", "modulename": "weavingspace.tileable", "qualname": "TileShape.DIAMOND", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.DIAMOND: &#x27;diamond&#x27;&gt;"}, {"fullname": "weavingspace.tileable.Tileable", "modulename": "weavingspace.tileable", "qualname": "Tileable", "kind": "class", "doc": "<p>Class to represent a tileable set of tile geometries.</p>\n"}, {"fullname": "weavingspace.tileable.Tileable.__init__", "modulename": "weavingspace.tileable", "qualname": "Tileable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavingspace.tileable.Tileable.tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.tiles", "kind": "variable", "doc": "<p>the geometries with associated <code>title_id</code> attribute encoding their \ndifferent colouring.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.prototile", "modulename": "weavingspace.tileable", "qualname": "Tileable.prototile", "kind": "variable", "doc": "<p>the tileable polygon (rectangle, hexagon or diamond)</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.spacing", "modulename": "weavingspace.tileable", "qualname": "Tileable.spacing", "kind": "variable", "doc": "<p>the tile spacing effectively the resolution of the tiling. Defaults to\n1000</p>\n", "annotation": ": float", "default_value": "1000.0"}, {"fullname": "weavingspace.tileable.Tileable.base_shape", "modulename": "weavingspace.tileable", "qualname": "Tileable.base_shape", "kind": "variable", "doc": "<p>the tile shape. Defaults to 'RECTANGLE'</p>\n", "annotation": ": weavingspace.tileable.TileShape", "default_value": "&lt;TileShape.RECTANGLE: &#x27;rectangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.Tileable.vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.vectors", "kind": "variable", "doc": "<p>translation vector symmetries of the tiling</p>\n", "annotation": ": dict[tuple[int], tuple[float]]", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.regularised_prototile", "modulename": "weavingspace.tileable", "qualname": "Tileable.regularised_prototile", "kind": "variable", "doc": "<p>polygon containing the tiles of this tileable, usually a union of its\ntile polygons</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.crs", "modulename": "weavingspace.tileable", "qualname": "Tileable.crs", "kind": "variable", "doc": "<p>coordinate reference system of the tile. Most often an ESPG code but\nany valid geopandas CRS specification is valid. Defaults to 3857 (i.e. Web\nMercator).</p>\n", "annotation": ": int", "default_value": "3857"}, {"fullname": "weavingspace.tileable.Tileable.rotation", "modulename": "weavingspace.tileable", "qualname": "Tileable.rotation", "kind": "variable", "doc": "<p>cumulative rotation of the tileable.</p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "weavingspace.tileable.Tileable.debug", "modulename": "weavingspace.tileable", "qualname": "Tileable.debug", "kind": "variable", "doc": "<p>if True prints debug messages. Defaults to False.</p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "weavingspace.tileable.Tileable.setup_vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.setup_vectors", "kind": "function", "doc": "<p>Sets up the symmetry translation vectors as floating point pairs\nindexed by integer tuples with respect to either a rectangular or\ntriangular grid location.</p>\n\n<p>Derived from the size and shape of the tile attribute. These are not\nthe minimal translation vectors, but the 'face to face' vectors of the\ntile, such that a hexagonal tile will have 3 vectors, not the minimal\nparallelogram pair. Also supplies the inverse vectors.</p>\n\n<p>The vectors are stored in a dictionary indexed by their\ncoordinates, e.g.</p>\n\n<p>{( 1,  0): ( 100, 0), ( 0,  1): (0,  100),\n   (-1,  0): (-100, 0), ( 0, -1): (0, -100)}</p>\n\n<p>For a tileable of type <code>TileShape.HEXAGON</code>, the indexing tuples\nhave three components. See <a href=\"https://www.redblobgames.com/grids/hexagons/\">https://www.redblobgames.com/grids/hexagons/</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.get_vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.get_vectors", "kind": "function", "doc": "<p>Returns symmetry translation vectors as floating point pairs.\nOptionally returns the vectors in a dictionary indexed by their\ncoordinates, e.g.</p>\n\n<p>{( 1,  0): ( 100, 0), ( 0,  1): (0,  100),\n   (-1,  0): (-100, 0), ( 0, -1): (0, -100)}</p>\n\n<p>Returns:\n  Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]:\n    either the vectors as a list of float tuples, or a dictionary\n    of those vectors indexed by integer coordinate tuples.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">as_dict</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.setup_regularised_prototile_from_tiles", "kind": "function", "doc": "<p>Sets the regularised tile to a union of the tiles.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.merge_fragments", "modulename": "weavingspace.tileable", "qualname": "Tileable.merge_fragments", "kind": "function", "doc": "<p>Merges a set of polygons based on testing if they touch when subjected\nto the translation vectors provided by <code>get_vectors()</code>.</p>\n\n<p>Called by <code>regularise_tiles()</code> to combine tiles in a tile unit that\nmay be fragmented as supplied but will combine after tiling into single\ntiles. This step makes for more efficient implementation of the\ntiling of map regions.</p>\n\n<p>Args:\n  fragments (list[geom.Polygon]): A set of polygons to merge.</p>\n\n<p>Returns:\n  list[geom.Polygon]: A minimal list of merged polygons.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">fragments</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.reattach_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.reattach_tiles", "kind": "function", "doc": "<p>Move tiles that are outside the regularised prototile main polygon\nback inside it adjusting regularised prototile if needed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.regularise_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.regularise_tiles", "kind": "function", "doc": "<p>Combines separate tiles that share a tile_id value into\nsingle tiles, if they would end up touching after tiling.</p>\n\n<p>Also adjusts the <code>Tileable.regularised_prototile</code>\nattribute accordingly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.get_local_patch", "modulename": "weavingspace.tileable", "qualname": "Tileable.get_local_patch", "kind": "function", "doc": "<p>Returns a GeoDataFrame with translated copies of the Tileable.</p>\n\n<p>The geodataframe takes the same form as the <code>Tileable.tile</code> attribute.</p>\n\n<p>Args:\n  r (int, optional): the number of 'layers' out from the unit to\n    which the translate copies will extendt. Defaults to <code>1</code>.\n  include_0 (bool, optional): If True includes the Tileable itself at\n    (0, 0). Defaults to <code>False</code>.</p>\n\n<p>Returns:\n  gpd.GeoDataFrame: A GeoDataframe of the tiles extended by a number \n    of 'layers'.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">include_0</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.fit_tiles_to_prototile", "modulename": "weavingspace.tileable", "qualname": "Tileable.fit_tiles_to_prototile", "kind": "function", "doc": "<p>Fits the tiles so they sit inside the prototile boundary.</p>\n\n<p>If tiles project outside the boundaries of the prototile, this\nmethod will clip them so that they don't. This may result in\n'fragmented' tiles, i.e. pieces that would form a single tile\nafter tiling which are separated into fragments.</p>\n\n<p>Args:\n  centre_tile (int, optional): the index position of the central\n    tile. Defaults to <code>0</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">centre_tile</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.inset_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.inset_tiles", "kind": "function", "doc": "<p>Returns a new Tileable with an inset applied around the tiles.</p>\n\n<p>Works by applying a negative buffer of specfied size to all tiles.\nTiles that collapse to zero area are removed and the tile_id\nattribute updated accordingly.</p>\n\n<p>NOTE: this method is likely to not preserve the relative area of tiles.</p>\n\n<p>Args:\n  inset (float, optional): The distance to inset. Defaults to <code>0</code>.</p>\n\n<p>Returns:\n  \"Tileable\": the new inset Tileable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">inset</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.plot", "modulename": "weavingspace.tileable", "qualname": "Tileable.plot", "kind": "function", "doc": "<p>Plots a representation of the Tileable on the supplied axis. **kwargs\nare passed on to matplotlib.plot()</p>\n\n<p>Args:\n  ax (_type_, optional): matplotlib axis to draw to. Defaults to None.\n  show_prototile (bool, optional): if <code>True</code> show the tile outline.\n    Defaults to <code>True</code>.\n  show_reg_prototile (bool, optional): if <code>True</code> show the regularised tile\n    outline. Defaults to <code>True</code>.\n  show_ids (str, optional): if <code>tile_id</code> show the tile_ids. If\n    <code>id</code> show index number. If None or <code>''</code> don't label tiles.\n    Defaults to <code>tile_id</code>.\n  show_vectors (bool, optional): if <code>True</code> show the translation\n    vectors (not the minimal pair, but those used by\n    <code>get_local_patch()</code>). Defaults to <code>False</code>.\n  r (int, optional): passed to <code>get_local_patch()</code> to show context if\n    greater than 0. Defaults to <code>0</code>.\n  r_alpha (float, optional): alpha setting for units other than the\n    central one. Defaults to 0.3.\n  prototile_edgecolour (str, optional): outline colour for the tile.\n    Defaults to <code>\"k\"</code>.\n  reg_prototile_edgecolour (str, optional): outline colour for the\n    regularised. Defaults to <code>\"r\"</code>.\n  cmap (list[str], optional): colour map to apply to the central\n    tiles. Defaults to <code>None</code>.\n  figsize (tuple[float], optional): size of the figure.\n    Defaults to <code>(8, 8)</code>.</p>\n\n<p>Returns:\n  pyplot.axes: to which calling context may add things.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_prototile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_reg_prototile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_ids</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;tile_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show_vectors</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">prototile_edgecolour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;k&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">reg_prototile_edgecolour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;r&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">r_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">axes</span> <span class=\"n\">at</span> <span class=\"mh\">0x14469e480</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_scale", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_scale", "kind": "function", "doc": "<p>Transforms tileable by scaling.</p>\n\n<p>Args:\n  xscale (float, optional): x scale factor. Defaults to 1.0.\n  yscale (float, optional): y scale factor. Defaults to 1.0.</p>\n\n<p>Returns:\n  Tileable: the transformed Tileable.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xscale</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">yscale</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_rotate", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_rotate", "kind": "function", "doc": "<p>Transforms tiling by rotation.</p>\n\n<p>Args:\n  angle (float, optional): angle to rotate by. Defaults to 0.0.</p>\n\n<p>Returns:\n  Tileable: the transformed Tileable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_skew", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_skew", "kind": "function", "doc": "<p>Transforms tiling by skewing</p>\n\n<p>Args:\n  xa (float, optional): x direction skew. Defaults to 0.0.\n  ya (float, optional): y direction skew. Defaults to 0.0.</p>\n\n<p>Returns:\n  Tileable: the transformed Tileable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xa</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">ya</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries", "modulename": "weavingspace.tiling_geometries", "kind": "module", "doc": "<p>Functions for setting up a <code>weavingspace.tile_unit.TileUnit</code> with various\ntile geometries. Some care is required in adding new functions that use\nexisitng ones to get the sequence of setup operations right. Modify with care!</p>\n\n<p>The available tilings can be viewed in <a href=\"https://github.com/DOSull/weaving-space/blob/main/all-the-tiles.ipynb\">this notebook</a>.</p>\n\n<p>These tilings (and many many more!) are discussed in</p>\n\n<p>Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H. Freeman and\nCompany, New York)</p>\n\n<p>A more accessible introduction is</p>\n\n<p>Kaplan C S, 2002 _Computer Graphics and Geometric Ornamental Design_, PhD\nthesis, University of Washington, Seattle, WA, <a href=\"https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf\">https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf</a></p>\n\n<p>and a more 'polished' version of that work focused on computer graphics is also\navailable</p>\n\n<p>Kaplan C S, 2009 _Introductory tiling theory for computer graphics_ (Morgan &amp;\nClaypool)</p>\n"}, {"fullname": "weavingspace.tiling_geometries.setup_cairo", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_cairo", "kind": "function", "doc": "<p>Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.\nThis code shows how a 'handcoded' set of geometries can be applied.</p>\n\n<p>Note that it is advisable to avoid intersection and union operations where\npossible, as it often yields floating point mismatches that can be hard\nto repair! (This tiling can be relatively conveniently generated by\ndissecting a square in 4 quarters at a 30 degree angle to the sides and\nthen reflecting and rotating copies and joing them back together. But\nfloating point issues make that very messy indeed. Much better to make\nthe geometries 'pure'.)</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_hex_slice", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_hex_slice", "kind": "function", "doc": "<p>Tilings from radial slices of a hexagon into 2, 3, 4, 6 or 12 slices.</p>\n\n<p>The supplied unit should have offset and n set.</p>\n\n<p>self.offset == 1 starts at midpoints, 0 at hexagon corners\nself.n is the number of slices and should be 2, 3, 4, 6 or 12.</p>\n\n<p>Again, construction avoids intersection operations where possible.</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_hex_dissection", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_hex_dissection", "kind": "function", "doc": "<p>Tilings from dissection of a hexagon into parts.</p>\n\n<p>The supplied unit should have offset and n set.</p>\n\n<p>self.offset == 1 starts at midpoints, 0 at hexagon corners\nself.n is the number of slices and should be 2, 3, 4, 6 or 12.</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.get_4_parts_of_hexagon", "modulename": "weavingspace.tiling_geometries", "qualname": "get_4_parts_of_hexagon", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.get_7_parts_of_hexagon", "modulename": "weavingspace.tiling_geometries", "qualname": "get_7_parts_of_hexagon", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.get_9_parts_of_hexagon", "modulename": "weavingspace.tiling_geometries", "qualname": "get_9_parts_of_hexagon", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_laves", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_laves", "kind": "function", "doc": "<p>The Laves tilings. See <a href=\"https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings\">https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings</a>.</p>\n\n<p>These are all isohedral, but mostly not regular polygons. We\nprioritise them over the Archimedean tilings because being\nisohedral all tiles are the same size. Several are hex\ndissections and setup is delegated accordingly.</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_archimedean", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_archimedean", "kind": "function", "doc": "<p>The Archimedean 'regular tilings. See <a href=\"https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane\">https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane</a></p>\n\n<p>Many of these are most easily constructed as duals of the Laves tilings.</p>\n\n<p>Some are not yet implemented:</p>\n\n<p>(3.3.3.4.4) is kind of weird (stripes of triangles and squares) so can't be\nbothered with it. Perhaps as a 5-variable option we'll get to it in time.</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_hex_colouring", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_hex_colouring", "kind": "function", "doc": "<p>3, 4, and 7 colourings of a regular array of hexagons.</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_geometries.setup_square_colouring", "modulename": "weavingspace.tiling_geometries", "qualname": "setup_square_colouring", "kind": "function", "doc": "<p>Colourings of a regular array of squares. Only supports n = 5 at present\nbut we need a n=5 option</p>\n\n<p>Args:\n  unit (TileUnit):  the TileUnit to setup.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils", "modulename": "weavingspace.tiling_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavingspace.tiling_utils.PRECISION", "modulename": "weavingspace.tiling_utils", "qualname": "PRECISION", "kind": "variable", "doc": "<p></p>\n", "default_value": "6"}, {"fullname": "weavingspace.tiling_utils.RESOLUTION", "modulename": "weavingspace.tiling_utils", "qualname": "RESOLUTION", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-06"}, {"fullname": "weavingspace.tiling_utils.get_strand_ids", "modulename": "weavingspace.tiling_utils", "qualname": "get_strand_ids", "kind": "function", "doc": "<p>Conversts a strands specification string to a list of lists of strand\nlabels.</p>\n\n<p>Args:\n  strands_spec (str): string format \"a|bc|(de)f\" | separates strands in\n    each direction and () designates combining labels into a single\n    strand that will be sliced lengthwise. Example output:</p>\n\n<pre><code>  \"a|bc|(de)f\" -&gt; ([\"a\"], [\"b\", \"c\"], [\"de\", \"f\"])\n</code></pre>\n\n<p>Superflous parentheses are removed, but no other error-checks are\n    applied.</p>\n\n<p>Returns:\n  tuple[str]: tuple of lists of labels for each set of strands.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">strands_spec</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.centre_offset", "modulename": "weavingspace.tiling_utils", "qualname": "centre_offset", "kind": "function", "doc": "<p>Returns vector required to move centroid of polygon to target.</p>\n\n<p>Args:\n  shape (Polygon): polygon to move.\n  target (tuple[float], optional): target to move to.\n    Defaults to (0, 0).</p>\n\n<p>Returns:\n  tuple[float]: tuple of x, y movement required.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_regular_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_regular_polygon", "kind": "function", "doc": "<p>Returns regular polygon with n sides centered on (0, 0) with a horizontal base, and height given by spacing.</p>\n\n<p>Args:\n  spacing (_type_): required height.\n  n (int): number of sides.</p>\n\n<p>Returns:\n  geom.Polygon: required geom.Polygon.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacing</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.offset_polygon_corners", "modulename": "weavingspace.tiling_utils", "qualname": "offset_polygon_corners", "kind": "function", "doc": "<p>Returns this polygon but with its first corner offset from its\noriginal position in the coordinate sequence. The returned polygon will\nbe identical but stored differently internally.</p>\n\n<p>Args:\n  polygon (geom.Polygon): the polygon to reorder.\n  offset (int): the number of corner positions by which to shift the\n    sequence.</p>\n\n<p>Returns:\n    geom.Polygon: the reordered polygon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.rotate_preserving_order", "modulename": "weavingspace.tiling_utils", "qualname": "rotate_preserving_order", "kind": "function", "doc": "<p>Returns the supplied polygon rotated with the order of its corner points\npreserved (not guaranteed by shapely.affinity.rotate).</p>\n\n<p>Args:\n    polygon (geom.Polygon): polygon to rotate.\n    angle (float): desired angle of rotation (in degrees).\n    centre (geom.Point): the rotation centre (passed on to shapely.affinity.\n      rotate).</p>\n\n<p>Returns:\n    geom.Polygon: rotated polygon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.geometry_matches", "modulename": "weavingspace.tiling_utils", "qualname": "geometry_matches", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">geom1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">geom2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.is_convex", "modulename": "weavingspace.tiling_utils", "qualname": "is_convex", "kind": "function", "doc": "<p>Tests for shape convexity. There are better ways to do this, like\ne.g. using something like the get_interior_angles() function, but simply\nchecking if the area is close to that of its convex hull works too!</p>\n\n<p>Args:\n  shape (geom.Polygon): polygon to check</p>\n\n<p>Returns:\n  bool: True if the polygon is convex, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_corners", "modulename": "weavingspace.tiling_utils", "qualname": "get_corners", "kind": "function", "doc": "<p>Returns a list of geom.Points around the boundary of a polygon, optionally\nrepeating the first. Does no simplification (e.g. if a line segment has a \n'corner' along its length, it is NOT removed; see get_clean_polygon for \nthat). Points have precision set to the package default tiling_utils.\nRESOLUTION.</p>\n\n<p>Args:\n  shape (geom.Polygon): polygon whose corners are required.\n  repeat_first (bool, optional): if True the first corner is repeated in the \n    returned list, if False it is omitted. Defaults to True.</p>\n\n<p>Returns:\n  list[geom.Point]: list of geom.Point vertices of the polygon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">repeat_first</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_sides", "modulename": "weavingspace.tiling_utils", "qualname": "get_sides", "kind": "function", "doc": "<p>Returns polygon sides as a list of geom.LineStrings, with resolution set\nto the package default tiling_utils.RESOLUTION. No simplification for \nsuccessive colinear sides is carried out.</p>\n\n<p>Args:\n  shape (geom.Polygon): polygon whose edges are required.</p>\n\n<p>Returns:\n  list[geom.LineString]: list of geom.LineString sides of the polygon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_side_lengths", "modulename": "weavingspace.tiling_utils", "qualname": "get_side_lengths", "kind": "function", "doc": "<p>Returns list of lengths of polygon sides. No simplification for corners\nalong sides is carried out.</p>\n\n<p>Args:\n  shape (geom.Polygon): polygon whose edge lengths are required.</p>\n\n<p>Returns:\n  list[float]: list of side lengths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_side_bearings", "modulename": "weavingspace.tiling_utils", "qualname": "get_side_bearings", "kind": "function", "doc": "<p>Returns a list of angles (in degrees) between the sides of a polygon and\nthe positive x-axis, when proceeding from the first point in each side to its\nend point. This should usually be CW around the polygon.</p>\n\n<p>Args:\n  shape (geom.Polygon): polygon whose side bearings are required.</p>\n\n<p>Returns:\n  tuple[tuple[float]]: tuple of bearings of each edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_interior_angles", "modulename": "weavingspace.tiling_utils", "qualname": "get_interior_angles", "kind": "function", "doc": "<p>Returns angles (in degrees) between successive edges of a polygon. No \npolygon simplification is carried out so some angles may be 180 (i.e. a \n'corner' along a side, such that successive sides are colinear). </p>\n\n<p>Args:\n  shape (geom.Polygon): polygon whose angles are required.</p>\n\n<p>Returns:\n  list[float]: list of angles.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_clean_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_clean_polygon", "kind": "function", "doc": "<p>Returns polygon with any successive corners that are co-linear along a \nside or very close to one another removed. </p>\n\n<p>Particularly useful for tidying polygons weave tilings that have been \nassembled from multiple 'cells' in the weave grid.</p>\n\n<p>Args:\n  shape (Union[geom.MultiPolygon,geom.Polygon]): polygon to clean.</p>\n\n<p>Returns:\n  geom.Polygon: cleaned polygon.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">multipolygon</span><span class=\"o\">.</span><span class=\"n\">MultiPolygon</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_inner_angle", "modulename": "weavingspace.tiling_utils", "qualname": "get_inner_angle", "kind": "function", "doc": "<p>Returns the angle (in degrees) between line p1-p2 and p2-p3, i.e., the \nangle A below</p>\n\n<pre><code>      p2\n     / \\ \n    / A \\ \n  p1     p3\n</code></pre>\n\n<p>Args:\n  p1 (geom.Point): first point.\n  p2 (geom.Point): second 'corner' point.\n  p3 (geom.Point): third point.</p>\n\n<p>Returns:\n    float: angle in degrees.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p3</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_outer_angle", "modulename": "weavingspace.tiling_utils", "qualname": "get_outer_angle", "kind": "function", "doc": "<p>Returns outer angle (in degrees) between lines p1-p2 and p2-p3, i.e., the \nangle A below</p>\n\n<pre><code>        /\n       /\n      p2 A\n     / \\ \n    /   \\ \n  p1     p3\n</code></pre>\n\n<p>Args:\n  p1 (geom.Point): first point.\n  p2 (geom.Point): second 'corner' point.\n  p3 (geom.Point): third point.</p>\n\n<p>Returns:\n  float: angle in degrees.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p3</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.is_regular_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "is_regular_polygon", "kind": "function", "doc": "<p>Tests if supplied polygon is regular (i.e. equal sides and angles).</p>\n\n<p>Args:\n    shape (geom.Polygon): polygon to test.</p>\n\n<p>Returns:\n    bool: True if polygon is regular, False if not.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.is_tangential", "modulename": "weavingspace.tiling_utils", "qualname": "is_tangential", "kind": "function", "doc": "<p>Determines if the supplied polygon is tangential i.e., it can have\ncircle inscribed tangential to all its sides. </p>\n\n<p>Note that this will fail for polygons with successive colinear sides,\nmeaning that polygons should be fully simplified...</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.incentre", "modulename": "weavingspace.tiling_utils", "qualname": "incentre", "kind": "function", "doc": "<p>A different polygon centre, which produces better results for some\ndual tilings where tiles are not regular polygons... see\n<a href=\"https://en.wikipedia.org/wiki/Incenter\">https://en.wikipedia.org/wiki/Incenter</a></p>\n\n<p>This method relies on the polygon being tangential, i.e. there is an\ninscribed circle to which all sides of the polygon are tangent. It will\nwork on all the polygons encountered in the Laves tilings, but is not\nguaranteed to work on all polygons.</p>\n\n<p>Given that the polygon is tangential, the radius of the inscribed circle is\nthe <a href=\"https://en.wikipedia.org/wiki/Apothem\">apothem of the polygon</a> given\nby 2 x Area / Perimeter. We apply a parallel offset of this size to two\nsides of the polygon and find their intersection to determine the centre of\nthe circle, givng the incentre of the polygon.</p>\n\n<p>Args:\n  shape (geom.Polygon): the polygon.</p>\n\n<p>Returns:\n  geom.Point: the incentre of the polygon.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_apothem_length", "modulename": "weavingspace.tiling_utils", "qualname": "get_apothem_length", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.ensure_cw", "modulename": "weavingspace.tiling_utils", "qualname": "ensure_cw", "kind": "function", "doc": "<p>Returns the polygon with its outer boundary vertices in clockwise order.</p>\n\n<p>It is important to note that shapely.set_precision() imposes clockwise order\non polygons, and since it is used widely throughout theses modules, it makes\nsense to impose this order.</p>\n\n<p>Args:\n  shape (geom.Polygon): the polygon.</p>\n\n<p>Returns:\n  geom.Polygon: the polygon in clockwise order.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_angle_bisector", "modulename": "weavingspace.tiling_utils", "qualname": "get_angle_bisector", "kind": "function", "doc": "<p>Returns a line which is the angle bisector of the specified corner of the\nsupplied polygon.</p>\n\n<p>Args:\n    shape (geom.Polygon): the polygon\n    v (int, optional): index of the corner whose bisector is required. \n    Defaults to 0.</p>\n\n<p>Returns:\n    geom.LineString: line which bisects the specified corner.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_side_bisector", "modulename": "weavingspace.tiling_utils", "qualname": "get_side_bisector", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.gridify", "modulename": "weavingspace.tiling_utils", "qualname": "gridify", "kind": "function", "doc": "<p>Returns the supplied GeoSeries rounded to the specified precision.</p>\n\n<p>Args:\n  gs (gpd.GeoSeries): geometries to gridify.\n  precision (int, optional): digits of precision. Defaults to 6.</p>\n\n<p>Returns:\n  gpd.GeoSeries: the rounded geometries.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_dual_tile_unit", "modulename": "weavingspace.tiling_utils", "qualname": "get_dual_tile_unit", "kind": "function", "doc": "<p>Converts supplied TileUnit to a candidate GeoDataFrame of its dual\nTileUnit.</p>\n\n<p>NOTE: this is complicated and not remotely guaranteed to work!\na particular issue is that where to place the vertices of the faces\nof the dual with respect to the tiles in the original is ill-defined.\nThis is because the dual process is topologically not metrically defined,\nso that exact vertex locations are ambiguous. Tiling duality is defined in\nSection 4.2 of Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H.\nFreeman and Company, New York)</p>\n\n<p>NOTE: In general, this method will work only if all supplied tiles are\nregular polygons. A known exception is if the only non-regular polygons are\ntriangles.</p>\n\n<p>NOTE: 'clean' polygons are required. If supplied polygons have messy\nvertices with multiple points where there is only one proper point, bad\nthings are likely to happen! Consider using <code>clean_polygon()</code> on the\ntile geometries.</p>\n\n<p>Because of the above limitations, we only return a GeoDataFrame\nfor inspection. However some <code>weavingspace.tile_unit.TileUnit</code> setup\nmethods in <code>weavingspace.tiling_geometries</code> use this method, where we are\nconfident the returned dual is valid.</p>\n\n<p>Args:\n  unit (TileUnit): the tiling for which the dual is required.</p>\n\n<p>Returns:\n  gpd.GeoDataFrame: GeoDataFrame that could be the tiles attribute for\n    a TileUnit of the dual tiling.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.relabel", "modulename": "weavingspace.tiling_utils", "qualname": "relabel", "kind": "function", "doc": "<p>Returns supplied data reassigned with unique values from\nstring.ascii_letters.</p>\n\n<p>Args:\n  data (Iterable): the data to relabel</p>\n\n<p>Returns:\n  list: the reassigned data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.sort_cw", "modulename": "weavingspace.tiling_utils", "qualname": "sort_cw", "kind": "function", "doc": "<p>Sorts supplied tuple of x, y, ID into clockwise order relative to their\nmean centre.</p>\n\n<p>Args:\n  pts_ids (list[tuple[float, float, str]]): A tuple of a pair of\n    floats and a string.</p>\n\n<p>Returns:\n  list: a list in the same format as supplied sorted into\n    clockwise order of the point locations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pts_ids</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.order_of_pts_cw_around_centre", "modulename": "weavingspace.tiling_utils", "qualname": "order_of_pts_cw_around_centre", "kind": "function", "doc": "<p>Returns the order of the supplied points clockwise relative to supplied \ncentre point, i.e. a list of the indices in clockwise order.</p>\n\n<p>Args:\n    pts (list[geom.Point]): list of points to order.\n    centre (geom.Point): centre relative to which CW order is determined.</p>\n\n<p>Returns:\n    _type_: list of reordered points.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pts</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.write_map_to_layers", "modulename": "weavingspace.tiling_utils", "qualname": "write_map_to_layers", "kind": "function", "doc": "<p>Writes supplied GeoDataFrame to a GPKG file with layers based on\nthe tile_var attribute.</p>\n\n<p>Args:\n  gdf (gpd.GeoDataFrame): the GeoDataFrame.\n  fname (str, optional): filename to write.\n  tile_var (str, optional): the attribute to use to separate\n    output file into layers. Defaults to \"tile_id\".</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gdf</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;output.gpkg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tile_var</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;tile_id&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_collapse_distance", "modulename": "weavingspace.tiling_utils", "qualname": "get_collapse_distance", "kind": "function", "doc": "<p>Returns the distance under which the supplied polygon will shrink\nto nothing if negatively buffered by that distance.</p>\n\n<p>Performs a binary search between an upper bound based on the radius of\nthe circle of equal area to the polygon, and 0.</p>\n\n<p>Args:\n  geometry (geom.Polygon): the polygon.</p>\n\n<p>Returns:\n  float: its collapse distance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_largest_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_largest_polygon", "kind": "function", "doc": "<p>Returns the largest polygon in a GeoSeries as a GeoSeries of one polygon.</p>\n\n<p>Args:\n  polygons (gpd.GeoSeries): the set of polygons to pick from.</p>\n\n<p>Returns:\n  gpd.GeoSeries: the largest polygon.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.touch_along_an_edge", "modulename": "weavingspace.tiling_utils", "qualname": "touch_along_an_edge", "kind": "function", "doc": "<p>Tests if two polygons touch along an edge.</p>\n\n<p>Checks that the intersection area of the two polygons buffered by\na small amount is large enough to indicate that they neighbour at more\nthan a corner.</p>\n\n<p>Args:\n  p1 (geom.Polygon): First polygon\n  p2 (geom.Polygon): Second polygon</p>\n\n<p>Returns:\n  bool: True if they neighbour along an edge</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_width_height_left_bottom", "modulename": "weavingspace.tiling_utils", "qualname": "get_width_height_left_bottom", "kind": "function", "doc": "<p>Returns width, height, left and bottom limits of a GeoSeries</p>\n\n<p>Args:\n  gs (geopandas.GeoSeries): GeoSeries for which limits are required.</p>\n\n<p>Returns:\n  tuple: four float values of width, height, left and bottom of gs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_bounding_ellipse", "modulename": "weavingspace.tiling_utils", "qualname": "get_bounding_ellipse", "kind": "function", "doc": "<p>Returns an ellipse containing the supplied shapes.</p>\n\n<p>The method used is to calculate the size of square that would contain\nthe shapes, if they had an aspect ratio 1, then stretch the circle in\nthe x, y directions according to the actual aspect ratio of the shapes.</p>\n\n<p>Args:\n  shapes (gpd.GeoSeries): the shapes to be contained.\n  mag (float, optional): optionally increase the size of the returned\n    ellipse by this scale factor. Defaults to 1.0.</p>\n\n<p>Returns:\n  gpd.GeoSeries: the set of shapes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>,</span><span class=\"param\">\t<span class=\"n\">mag</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_tiling_edges", "modulename": "weavingspace.tiling_utils", "qualname": "get_tiling_edges", "kind": "function", "doc": "<p>Returns linestring GeoSeries from supplied polygon GeoSeries.</p>\n\n<p>This is used to allow display of edges of tiles in legend when they are\nmasked by an ellipse (if we instead clip polygons then the ellipse edge\nwill also show in the result.)</p>\n\n<p>Args:\n  shapes (gpd.GeoSeries): Polygons to convert.</p>\n\n<p>Returns:\n  gpd.GeoSeries: LineStrings from the supplied Polygons.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_polygon_sector", "modulename": "weavingspace.tiling_utils", "qualname": "get_polygon_sector", "kind": "function", "doc": "<p>Returns a sector of the provided Polygon.</p>\n\n<p>The returned sector is a section of the polygon boundary between the\nnormalized start and end positions, and including the polygon centroid.\nShould (probably) only be applied to convex polygons.</p>\n\n<p>Args:\n  shape (geom.Polygon): the Polygon.\n  start (float): normalized start position along the boundary. Defaults to\n    0.\n  end (float): normalized start position along the boundary. Defaults to\n    1.</p>\n\n<p>Returns:\n  geom.Polygon: the requested polygon sector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.repair_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "repair_polygon", "kind": "function", "doc": "<p>Convenience function to 'repair' a shapely polyon or GeoSeries by applying\na negative buffer then the same positive buffer.</p>\n\n<p>Optionally the buffer may be applied in the opposite order (i.e. grow then\nshrink). This operation may also convert a MultiPolygon that has some 'stray'\nparts to a Polygon.</p>\n\n<p>This is method is often unofficially recommended (on stackexchange etc.)\neven in the shapely docs, to resolve topology issues and extraneous\nadditional vertices appearing when spatial operations are repeatedly\napplied.</p>\n\n<p>Args:\n  p (Union[geom.Polygon, gpd.GeoSeries]): Polygon or GeoSeries to clean.\n  res (float, optional): buffer size to use. Defaults to 1e-3.\n  shrink_then_grow (bool, optional): if True the negative buffer is\n    applied first, otherwise the buffer operations are applied in\n    reverse. Defaults to True.</p>\n\n<p>Returns:\n  Union[geom.Polygon, gpd.GeoSeries]: the cleaned Polygon or GeoSeries.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">multipolygon</span><span class=\"o\">.</span><span class=\"n\">MultiPolygon</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">shrink_then_grow</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.safe_union", "modulename": "weavingspace.tiling_utils", "qualname": "safe_union", "kind": "function", "doc": "<p>Unions the supplied GeoSeries of Polygons while buffering them to avoid\ngaps and odd internal floating edges. Optionally returns a Polygon or a\nGeoSeries.</p>\n\n<p>Frequently when unioning polygons that are ostensibly adjacent 'rogue'\ninternal boundaries remain in the result. We can avoid this by buffering the\npolygons before unioning them, then reversing the buffer on the unioned\nshape.</p>\n\n<p>Args:\n  gs (gpd.GeoSeries): the Polygons to union.\n  res (float, optional): size of the buffer to use. Defaults to 1e-3.\n  as_polygon (bool, optional): if True returns a Polygon, otherwise\n    returns a one Polygon GeoSeries. Defaults to False.</p>\n\n<p>Returns:\n  Union[gpd.GeoSeries, geom.Polygon]: the resulting union of supplied\n    polygons.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>,</span><span class=\"param\">\t<span class=\"n\">as_polygon</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span><span class=\"p\">,</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.zigzag_between_points", "modulename": "weavingspace.tiling_utils", "qualname": "zigzag_between_points", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p0</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">smoothness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_translation_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_translation_transform", "kind": "function", "doc": "<p>Returns the shapely affine transform tuple for a translation.</p>\n\n<p>Args:\n    dx (float): translation distance in x direction.\n    dy (float): translation distance in y direction.</p>\n\n<p>Returns:\n  list[float]: a six item list of floats, per the shapely.affinity.\n  affine_transform method, see \n    <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_rotation_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_rotation_transform", "kind": "function", "doc": "<p>Returns the shapely affine transform tuple for a rotation, optionally\nabout a supplied centre point.</p>\n\n<p>Args:\n    angle (float): the angle of rotation (in degrees).\n    centre (tuple[float], optional): An option centre location. Defaults to \n    None, which will in turn be converted to (0, 0).</p>\n\n<p>Returns:\n  list[float]: a six item list of floats, per the shapely.affinity.\n    affine_transform method, see \n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_reflection_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_reflection_transform", "kind": "function", "doc": "<p>Returns a shapely affine transform tuple that will reflect a shape\nin a line at the specified angle, optionally through a specified centre\npoint.</p>\n\n<p>Args:\n  angle (float): angle to the x-axis of the line of reflection.\n  centre (tuple[float], optional): point through which the line of \n    reflection passes. Defaults to None, which\n    will in turn be converted to (0, 0).</p>\n\n<p>Returns:\n  list[float]: a six item list of floats, per the shapely.affinity.\n    affine_transform method, see \n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.combine_transforms", "modulename": "weavingspace.tiling_utils", "qualname": "combine_transforms", "kind": "function", "doc": "<p>Returns a shapely affine transform list that combines the listed\nsequence of transforms applied in order.</p>\n\n<p>Args:\n  transforms (list[list[float]]): sequence of transforms to combine.</p>\n\n<p>Returns:\n  list[float]: a transform tuple combining the supplied transforms applied\n    in order, see \n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transforms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.reverse_transform", "modulename": "weavingspace.tiling_utils", "qualname": "reverse_transform", "kind": "function", "doc": "<p>Returns the inverse shapely affine transform of the supplied transform.</p>\n\n<p>Args:\n  transform (list[float]): the transform for which the inverse is desired.</p>\n\n<p>Returns:\n  list[float]: shapely affine transform tuple that will invert the supplied\n    transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.as_shapely_transform", "modulename": "weavingspace.tiling_utils", "qualname": "as_shapely_transform", "kind": "function", "doc": "<p>Returns the shapely affine transform list equivalent to the supplied\nnumpy matrix of a conventional augmented affine transform matrix.</p>\n\n<p>Args:\n  arr (np.array): augmented affine transform matrix of the desired \n    transform.</p>\n\n<p>Returns:\n  list[float]: desired shapely affine transform list of floats.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.as_numpy_matrix", "modulename": "weavingspace.tiling_utils", "qualname": "as_numpy_matrix", "kind": "function", "doc": "<p>Converts the supplied shapely affine transform list to an augmented\naffine transform matrix in numpy array form. This makes combining transforms\nmuch easier.</p>\n\n<p>Args:\n  transform (list[float]): the transform in shapely format.</p>\n\n<p>Returns:\n  np.array: the transform in numpy matrix format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology", "modulename": "weavingspace.topology", "kind": "module", "doc": "<p>Together the <code>Topology</code>, <code>weavingspace.topology_elements.Tile</code>, \n<code>weavingspace.topology_elements.Vertex</code>, <code>weavingspace.topology_elements.Edge</code>,\nand <code>weavingspace.symmetry.Symmetries</code> classes enable extraction of the \ntopological structure of periodic <code>weavingspace.tileable.Tileable</code> objects so \nthat modification of equivalent tiles can be carried out while retaining \ntileability. It is important to note that these are not fully generalised \nclasses and methods, that is, the Topology object that is supported is not a \npermanent 'backing' data structure for our Tileable objects. While it might \nbecome that in time, as at Feb 2024 it is not such a data structure. Instead \nusage is</p>\n\n<pre><code>tile = TileUnit(...)\ntopology = Topology(tile)\ntopology = topology.transform_*(...)\nnew_tile = topology.tile_unit\n</code></pre>\n\n<p>Topology plot function is necessary for a user to be able to see what they are\ndoing, because how edges and vertices in a tiling are labelled under tile\nequivalences is an essential step in the process.</p>\n\n<p>Note also that these classes do not accurately represent the distinctions made\nin the mathematical literature between tiling vertices and tile corners, or \nbetween tiling edges and tile sides.</p>\n"}, {"fullname": "weavingspace.topology.ALPHABET", "modulename": "weavingspace.topology", "qualname": "ALPHABET", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;"}, {"fullname": "weavingspace.topology.alphabet", "modulename": "weavingspace.topology", "qualname": "alphabet", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz&#x27;"}, {"fullname": "weavingspace.topology.Topology", "modulename": "weavingspace.topology", "qualname": "Topology", "kind": "class", "doc": "<p>Class to represent topology of a Tileable object.</p>\n\n<p>NOTE: It is important that get_local_patch return the tileable elements and \nthe translated copies in consistent sequence, i.e. if there are (say) four \ntiles in the unit, the local patch should be 1 2 3 4 1 2 3 4 1 2 3 4 ... and\nso on. This is because self.tiles[i % n_tiles] is frequently used to reference\nthe base unit Tile which corresponds to self.tiles[i].</p>\n"}, {"fullname": "weavingspace.topology.Topology.__init__", "modulename": "weavingspace.topology", "qualname": "Topology.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<p>Args:\n  unit (Tileable): the Tileable whose topology is required.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>, </span><span class=\"param\"><span class=\"n\">ignore_tile_ids</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "weavingspace.topology.Topology.tileable", "modulename": "weavingspace.topology", "qualname": "Topology.tileable", "kind": "variable", "doc": "<p>the Tileable on which the topology will be based.</p>\n", "annotation": ": weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.topology.Topology.tiles", "modulename": "weavingspace.topology", "qualname": "Topology.tiles", "kind": "variable", "doc": "<p>list of the Tiles in the topology. We use polygons returned by the\ntileable.get_local_patch method for these. That is the base tiles and 8 adjacent \ncopies (for a rectangular tiling), or 6 adjacent copies (for a hexagonal tiling).</p>\n", "annotation": ": list[weavingspace.topology_elements.Tile]"}, {"fullname": "weavingspace.topology.Topology.points", "modulename": "weavingspace.topology", "qualname": "Topology.points", "kind": "variable", "doc": "<p>dictionary of all points (vertices and corners) in the tiling, keyed by Vertex ID.</p>\n", "annotation": ": dict[int, weavingspace.topology_elements.Vertex]"}, {"fullname": "weavingspace.topology.Topology.edges", "modulename": "weavingspace.topology", "qualname": "Topology.edges", "kind": "variable", "doc": "<p>dictionary of the tiling edges, keyed by Edge ID.</p>\n", "annotation": ": dict[int, weavingspace.topology_elements.Edge]"}, {"fullname": "weavingspace.topology.Topology.unique_tile_shapes", "modulename": "weavingspace.topology", "qualname": "Topology.unique_tile_shapes", "kind": "variable", "doc": "<p>a 'reference' tile shape one per tile shape (up to vertices, so two tiles\nmight be the same shape, but one might have extra vertices induced by the\ntiling and hence is a different shape under this definition).</p>\n", "annotation": ": list[shapely.geometry.polygon.Polygon]"}, {"fullname": "weavingspace.topology.Topology.dual_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.dual_tiles", "kind": "variable", "doc": "<p>list of geom.Polygons from which a dual tiling might be constructed.</p>\n", "annotation": ": list[shapely.geometry.polygon.Polygon]"}, {"fullname": "weavingspace.topology.Topology.n_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.n_tiles", "kind": "variable", "doc": "<p>number of tiles in the base Tileable (retained for convenience).</p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "weavingspace.topology.Topology.shape_groups", "modulename": "weavingspace.topology", "qualname": "Topology.shape_groups", "kind": "variable", "doc": "<p>list of lists of tile IDs distinguished by shape and optionally tile_id</p>\n", "annotation": ": list[list[int]]"}, {"fullname": "weavingspace.topology.Topology.tile_matching_transforms", "modulename": "weavingspace.topology", "qualname": "Topology.tile_matching_transforms", "kind": "variable", "doc": "<p>shapely transform tuples that map tiles onto other tiles</p>\n", "annotation": ": list[tuple[float]]"}, {"fullname": "weavingspace.topology.Topology.tile_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.tile_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of tile IDs in each transitivity class</p>\n", "annotation": ": list[tuple[int]]"}, {"fullname": "weavingspace.topology.Topology.vertex_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.vertex_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of vertex IDs in each transitivity class</p>\n", "annotation": ": list[list[int]]"}, {"fullname": "weavingspace.topology.Topology.edge_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.edge_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of edge IDs in each transitivity class</p>\n", "annotation": ": list[list[tuple[int]]]"}, {"fullname": "weavingspace.topology.Topology.get_potential_symmetries", "modulename": "weavingspace.topology", "qualname": "Topology.get_potential_symmetries", "kind": "function", "doc": "<p>Assembles potential symmetries of the tiling from symmetries of the \ntileable.prototile and of the tileable.tiles. Removes any duplicates that\nresult. Result is assigned to the tile_matching_transforms attribute.</p>\n\n<p>TODO: consider retaining the Symmetry objects as these carry additional \ninformation that might facilitate labelling under a limited number of the\nsymmetries not all of them.</p>\n\n<p>Returns:\n  dict[int, tuple[float]]: dictionary of the symmetries (transforms \n    actually) in shapely affine transform 6-tuple format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.vertices_in_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.vertices_in_tiles", "kind": "function", "doc": "<p>Gets the vertices from self.points that are incident on the tiles in the \nsupplied list.</p>\n\n<p>Args:\n    tiles (list[Tile]): tiles whose vertices are required.</p>\n\n<p>Returns:\n    list[Vertex]: the required vertices.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Tile</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.edges_in_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.edges_in_tiles", "kind": "function", "doc": "<p>Gets the edges from self.edges that are part of the boundary of tiles in \nthe supplied list.</p>\n\n<p>Args:\n    tiles (list[Tile]): tiles whose edges are required.</p>\n\n<p>Returns:\n    list[Edge]: the required edges.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Tile</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.generate_dual", "modulename": "weavingspace.topology", "qualname": "Topology.generate_dual", "kind": "function", "doc": "<p>Create the dual tiiing for the tiling of this Topology.</p>\n\n<p>TODO: make this a viable replacement for the existing dual tiling \ngeneration.</p>\n\n<p>Returns:\n  list[geom.Polygon]: a list of polygon objects.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.add_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.add_vertex", "kind": "function", "doc": "<p>Adds a Vertex at the specified point location, returning it to the \ncaller. No attempt is made to ensure Vertex IDs are an unbroken sequemce: a \nnew ID is generated one greater than the existing highest ID. IDs will \nusually be an unbroken sequence up to removals when geometry transformations\nare applied.</p>\n\n<p>Args:\n    pt (geom.Point): point location of the Vertex.</p>\n\n<p>Returns:\n    Vertex: the added Vertex object.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.add_edge", "modulename": "weavingspace.topology", "qualname": "Topology.add_edge", "kind": "function", "doc": "<p>Adds an Edge to the edges dictionary. Edges are self indexing by the IDs\n of their end Vertices. Returns the new Edge to the caller.</p>\n\n<p>Args:\n  vs (list[Vertex]): list of Vertices in the Edge to be created.</p>\n\n<p>Returns:\n    Edge: the added Edge.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">vs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.plot", "modulename": "weavingspace.topology", "qualname": "Topology.plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">show_original_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_tile_centres</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_tile_vertex_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_tile_edge_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_vertex_ids</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_vertex_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">offset_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_edge_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_dual_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.plot_tiling_symmetries", "modulename": "weavingspace.topology", "qualname": "Topology.plot_tiling_symmetries", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.transform_geometry", "modulename": "weavingspace.topology", "qualname": "Topology.transform_geometry", "kind": "function", "doc": "<p>Applies a specified transformation of elements in the Topology whose \nlabels match the selector parameter, optionally applying the transform to \nupdate tile and optionally returning a new Topology object (or applying it \nto this one). </p>\n\n<p>Implemented in this way so that transformations can be applied one at a time\nwithout creating an intermediate set of new tiles, which may be invalid and\nfail. So, if you wish to apply (say) 3 transforms and generate a new \nTopology leaving the existing one intact:</p>\n\n<pre><code>new_topo = old_topo.transform_geometry(True,  False, \"a\", ...) \\\n                   .transform_geometry(False, False, \"B\", ...) \\\n                   .transform_geometry(False, True,  \"C\", ...)\n</code></pre>\n\n<p>The first transform requests a new Topology, subsequent steps do not, and it\nis only the last step which attempts to create the new tile polygons.</p>\n\n<p>**kwargs supply named parameters for the requested transformation.</p>\n\n<p>Args:\n  new_topology (bool): if True returns a new Topology object, else returns \n    the current Topology modified.\n  apply_to_tiles (bool): if True attempts to create new Tiles after the \n    transformation has been applied. Usually set to False, unless the last\n    transformation in a pipeline, to avoid problems of topologically invalid\n    tiles at intermediate steps.\n  selector (str): label of elements to which to apply the transformation. <br />\n    Note that all letters in the supplied string are checked, so you can \n    use e.g. \"abc\" to apply a transformation to edges labelled \"a\", \"b\" or \n    \"c\", or \"AB\" for vertices labelled \"A\" or \"B\".\n  type (str): name of the type of transformation requested. Currently\n    supported are <code>zigzag_edge</code>, <code>rotate_edge</code>, <code>push_vertex</code>, and \n    <code>nudge_vertex</code>. Keyword arguments for each are documented in the \n    corresponding methods.</p>\n\n<p>Returns:\n  Topology: if new_topology is True a new Topology based on this one with\n    after transformation, if False this Topology is returned after the\n    transformation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">new_topology</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Topology</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.zigzag_edge", "modulename": "weavingspace.topology", "qualname": "Topology.zigzag_edge", "kind": "function", "doc": "<p>Applies a zigzag transformation to the supplied Edge. Currently this will\nonly work correctly if h is even.</p>\n\n<p>TODO: make it possible for odd numbers of 'peaks' to work (this may require\nallowing bidirectional Edges, i.e. storing Edges in both directions so that\nall Tile edges are drawn CW). The <code>start</code> parameter is a temporary hack for \nthis</p>\n\n<p>Args:\n  edge (Edge): Edge to transform\n  n (int, optional): number of zigs and zags in the edge. Defaults to 2.\n  start (str, optional): label at one end of edge which is used to determine\n    the sense of h, enabling C-curves with an odd number n of zigs and zags \n    to be applied. Defaults to 'A'.\n  h (float, optional): width of the zig zags relative to edge length. \n    Defaults to 0.5.\n  smoothness (int, optional): spline smoothness. 0 gives a zig zag proper,\n    higher values will produce a sinusoid. Defaults to 0.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;A&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">smoothness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.rotate_edge", "modulename": "weavingspace.topology", "qualname": "Topology.rotate_edge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;A&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.push_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.push_vertex", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">vertex</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">push_d</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.nudge_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.nudge_vertex", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">vertex</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.get_kwargs", "modulename": "weavingspace.topology", "qualname": "Topology.get_kwargs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements", "modulename": "weavingspace.topology_elements", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavingspace.topology_elements.Tile", "modulename": "weavingspace.topology_elements", "qualname": "Tile", "kind": "class", "doc": "<p>Class to capture and manipulate essential features of polygons in a tiling.</p>\n"}, {"fullname": "weavingspace.topology_elements.Tile.__init__", "modulename": "weavingspace.topology_elements", "qualname": "Tile.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<p>Args:\n  ID (int): Tile ID which indexes it in the containing Topology tiles list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ID</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "weavingspace.topology_elements.Tile.ID", "modulename": "weavingspace.topology_elements", "qualname": "Tile.ID", "kind": "variable", "doc": "<p>integer ID number which indexes the Tile in the containing Topology tiles \nlist.</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology_elements.Tile.base_ID", "modulename": "weavingspace.topology_elements", "qualname": "Tile.base_ID", "kind": "variable", "doc": "<p>ID of corresponding Tile in the base tileable unit</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology_elements.Tile.corners", "modulename": "weavingspace.topology_elements", "qualname": "Tile.corners", "kind": "variable", "doc": "<p>list of Vertex objects. This includes all corners of the original polygon \nand any tiling vertices induced by (for example) a the corner of an adjacent \ntile lying halfway along an edge of the original polygon on which this tile \nis based. Vertex objects are stored in strictly clockwise sequence.</p>\n", "annotation": ": list[weavingspace.topology_elements.Vertex]"}, {"fullname": "weavingspace.topology_elements.Tile.edges", "modulename": "weavingspace.topology_elements", "qualname": "Tile.edges", "kind": "variable", "doc": "<p>list of Edge objects that together compose the tile boundary.</p>\n", "annotation": ": list[weavingspace.topology_elements.Edge]"}, {"fullname": "weavingspace.topology_elements.Tile.edges_CW", "modulename": "weavingspace.topology_elements", "qualname": "Tile.edges_CW", "kind": "variable", "doc": "<p>list of Edge direction. Edges are stored only once in a Topology so some \nedges are in clockwise order and others  are in counter-clockwise order. \nThese boolean flags are True if the corresponding Edge is clockwise, False if \ncounter-clockwise.</p>\n", "annotation": ": list[bool]"}, {"fullname": "weavingspace.topology_elements.Tile.label", "modulename": "weavingspace.topology_elements", "qualname": "Tile.label", "kind": "variable", "doc": "<p>tile_id label from the tileable source</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.topology_elements.Tile.vertex_labels", "modulename": "weavingspace.topology_elements", "qualname": "Tile.vertex_labels", "kind": "variable", "doc": "<p>list of (upper case) letter labels of the tile corners (i.e. all corners, \nnot only tiling vertices).</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.topology_elements.Tile.edge_labels", "modulename": "weavingspace.topology_elements", "qualname": "Tile.edge_labels", "kind": "variable", "doc": "<p>list of (lower case) letter labels of the tile edges (tiling edges, not \ntile sides).</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.topology_elements.Tile.shape", "modulename": "weavingspace.topology_elements", "qualname": "Tile.shape", "kind": "variable", "doc": "<p>the tile geometry (which may include some redundant points along sides \nwhere neighbouring tiles induce a tiling vertex). So for example a rectangle \nmight have additional points along its sides:</p>\n\n<pre><code>  +---+-------+\n  |   |   2   |\n  | 1 A---B---E---+\n  |   |   |   4   |\n  +---C 3 D-------+\n      |   |\n      +---+\n</code></pre>\n\n<p>In the above Tile 1 has additional point A, 2 has B and 3 has C and D induced \nby the corners of neighbouring tiles.</p>\n", "annotation": ": shapely.geometry.polygon.Polygon", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Tile.centre", "modulename": "weavingspace.topology_elements", "qualname": "Tile.centre", "kind": "variable", "doc": "<p>a point centre for the Tile (determined by weavingspace.tiling_utils.\nincentre).</p>\n", "annotation": ": shapely.geometry.point.Point", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Tile.shape_group", "modulename": "weavingspace.topology_elements", "qualname": "Tile.shape_group", "kind": "variable", "doc": "<p>the tile shape group of this tile in its containing Topology.</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Tile.transitivity_class", "modulename": "weavingspace.topology_elements", "qualname": "Tile.transitivity_class", "kind": "variable", "doc": "<p>the tile transitivity class of this tile its containing Topology</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Tile.get_corner_IDs", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_corner_IDs", "kind": "function", "doc": "<p>Convenience method to return list of corner IDs (not Vertex objects).</p>\n\n<p>Returns:\n  list[int]: list of integer IDs of tile corners.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_edge_IDs", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_edge_IDs", "kind": "function", "doc": "<p>Convenience method to return list of edge IDs (not Edge objects).</p>\n\n<p>Returns:\n  list[tuple[int]]: list of 2-element tuples of the start and end Vertex IDs\n    of each edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.set_shape_from_corners", "modulename": "weavingspace.topology_elements", "qualname": "Tile.set_shape_from_corners", "kind": "function", "doc": "<p>Sets the shape attribute based on the current list of corners, and sets \nthe associated tile centre.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.set_corners_from_edges", "modulename": "weavingspace.topology_elements", "qualname": "Tile.set_corners_from_edges", "kind": "function", "doc": "<p>Sets the corners attribute from the edges attribute. Typically called \nafter modification of topology edges. Optionally the shape attribute is NOT\nupdated, which may save time when multiple changes to the edges of a tile\nare in process (i.e., only update the shape after all changes are complete).</p>\n\n<p>Args:\n  update_shape (bool, optional): if True the shape attribute will be \n    updated, otherwise not. Defaults to True.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">update_shape</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.set_edge_directions", "modulename": "weavingspace.topology_elements", "qualname": "Tile.set_edge_directions", "kind": "function", "doc": "<p>Sets up the edges_CW attribute by inspection of the edges list.\nIt is (frankly!) hard to keep track of the correct sequence of CW/CCW order\nof edges as new ones are created or old ones merged. This method inspects\nthe 'tail-head' relations between consecutive edges to set these flags \ncorrectly.</p>\n\n<p>The test is simply to check if the 'tail' Vertex ID in each edge appears\nin the ID tuple of the following edge, i.e. if successive edge \nIDs are (0, 1) (2, 1) or (0, 1) (1, 2), then edge (0, 1) is in clockwise\ndirection, but if we have (0, 1) (2, 3) then it is not.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.insert_vertex_at", "modulename": "weavingspace.topology_elements", "qualname": "Tile.insert_vertex_at", "kind": "function", "doc": "<p>Method to insert the supplied Vertex into tile at index position i, \noptionally updating the shape attribute. Both corners and edges attributes\nare updated, and the old edge IDs for removal and the new edge itself are\nreturned to the calling context (the containing Topology) for update of its\nedges collection.</p>\n\n<p>This is NOT a generic vertex insertion method: it is only for use during \nTopology initialisation, and does not guarantee correct maintenance of \nall tile, edge and vertex relations in the general case---at any rate it\nhas not been tested for this!</p>\n\n<p>Args:\n    v (Vertex): the Vertex to insert.\n    i (int): index position in current corners after which to insert \n      supplied Vertex.\n    update_shape (bool, optional): if True shape attribute is updated. \n      Defaults to False.</p>\n\n<p>Returns:\n  tuple: the (tuple) ID of the old edge which should be deleted, and \n    the new Edges arising from insertion of this Vertex.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">update_shape</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.merge_edges_at_vertex", "modulename": "weavingspace.topology_elements", "qualname": "Tile.merge_edges_at_vertex", "kind": "function", "doc": "<p>Method to merge the edges that meet at the supplied Vertex. It is \nassumed that only two tiles are impacted this one, and its neighbour across\nthe Edge on which v lies. Both are updated. For this reason the work is\ndelegated to get_updated_edges_from_merge which is run on both affected\ntiles, but only determines the edges to remove and the new edge to be added\nonce. See that method for details.</p>\n\n<p>Args:\n  v (Vertex): Vertex at which to merge Edges. This should currently be an\n    end</p>\n\n<p>Returns:\n  tuple: 2 item list of the edge IDs to be removed and a new Edge object to\n    be added by the calling context (i.e. the containing Topology).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_updated_edges_from_merge", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_updated_edges_from_merge", "kind": "function", "doc": "<p>Updates the edges and edges_CW attributes based on insertion of \nthe supplied Vertex. If new_edge is supplied then the neighbour tile at\nv has already created the needed new Edge and this Edge is the one that\nwill be 'slotted in' at the appropriate spot in the edges list.</p>\n\n<p>The edges_CW is also updated to maintain correct directions of the edges.\nThe corners attribute is unaffected by these changes.</p>\n\n<p>Args:\n  v (Vertex): existing Vertex at which to carry out the merge.\n  new_edge (Edge, optional): if another Tile has already carried out this \n    merge this should be the resulting new Edge for insertion into this \n    Tile. Defaults to None (when the new Edge will be constructed).</p>\n\n<p>Returns:\n  Union[None, tuple]: either None (if a new edge was supplied) or a tuple \n    of the two edge IDs to be removed and the new edge added for return to\n    the calling context (i.e. the containing Topology).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">new_edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_edge_IDs_including_vertex", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_edge_IDs_including_vertex", "kind": "function", "doc": "<p>Gets the (two) index positions of the edges that include supplied Vertex.</p>\n\n<p>Args:\n    v (Vertex): Vertex of interest.</p>\n\n<p>Returns:\n  tuple[int]: two index positions of Edges in edges list that contain v.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_merged_edge", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_merged_edge", "kind": "function", "doc": "<p>Returns the new edge resulting from merging the two existing edges at\nindex positions i and j in the edges list. For example, if the current list \nof edge IDs was</p>\n\n<pre><code>(0 1 2) (4 2) (4 5) (5 0)\n</code></pre>\n\n<p>and the merge Vertex was #2, the resulting new edge is constructed from \nvertices (0 1 2 4). </p>\n\n<p>Returns:\n  Edge: the requested new Edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">j</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.offset_corners", "modulename": "weavingspace.topology_elements", "qualname": "Tile.offset_corners", "kind": "function", "doc": "<p>Shifts shape, corners, edges, and edges_CW by an offset amount. This is\nused to align tiles that are similar, which is required for correct \ntransfer of 'base' tile labelling on to 'radius 1' tiles during Topology \nconstruction.</p>\n\n<p>Args:\n  offset int: the number of positions to shift the lists.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_edge_label", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_edge_label", "kind": "function", "doc": "<p>Returns edge label of specified edge.</p>\n\n<p>Args:\n    e (Edge): Edge whose label is required.</p>\n\n<p>Returns:\n    str: requested edge label.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_corner_label", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_corner_label", "kind": "function", "doc": "<p>Returns corner label of specified corner.</p>\n\n<p>Args:\n    v (Vertex): corner whose label is required.</p>\n\n<p>Returns:\n    str: requested corner label.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_vertex_label_positions", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_vertex_label_positions", "kind": "function", "doc": "<p>Returns a viable location at which to position corner labels inside\ntile shape. The method is convoluted because a negative buffer may remove\ncolinear corners resulting in fewer positions than we have corners in the\ntile shape!</p>\n\n<p>Returns:\n    list[geom.Point]: list of locations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.get_edge_label_positions", "modulename": "weavingspace.topology_elements", "qualname": "Tile.get_edge_label_positions", "kind": "function", "doc": "<p>Returns a reasonable location at which to position edge labels inside\ntile shape.</p>\n\n<p>Returns:\n    list[geom.Point]: list of locations</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Tile.angle_at", "modulename": "weavingspace.topology_elements", "qualname": "Tile.angle_at", "kind": "function", "doc": "<p>Returns interior angle at the specified corner (in degrees).</p>\n\n<p>Args:\n    v (Vertex): corner where angle is requested.</p>\n\n<p>Returns:\n    float: angle at corner v in degrees.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Vertex", "modulename": "weavingspace.topology_elements", "qualname": "Vertex", "kind": "class", "doc": "<p>Class to store attributes of a vertex in a tiling.</p>\n"}, {"fullname": "weavingspace.topology_elements.Vertex.__init__", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<p>Args:\n  point (geom.Point): point location of the vertex.\n  ID (int): a unique integer ID (which will be its key in the containing\n    Topology points dictionary).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>, </span><span class=\"param\"><span class=\"n\">ID</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "weavingspace.topology_elements.Vertex.point", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.point", "kind": "variable", "doc": "<p>point (geom.Point): point location of the vertex.</p>\n", "annotation": ": shapely.geometry.point.Point"}, {"fullname": "weavingspace.topology_elements.Vertex.ID", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.ID", "kind": "variable", "doc": "<p>integer (mostly but not necessarily in sequence) of vertex keyed into the \npoints dictionary of the containing Topology.</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology_elements.Vertex.tiles", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.tiles", "kind": "variable", "doc": "<p>list of Tiles incident on this vertex.</p>\n", "annotation": ": list[weavingspace.topology_elements.Tile]"}, {"fullname": "weavingspace.topology_elements.Vertex.neighbours", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.neighbours", "kind": "variable", "doc": "<p>list of the immediately adjacent other corner IDs. Only required to \ndetermine if a point is a tiling vertex (when it will have) three or more \nneighbours, so only IDs are stored.</p>\n", "annotation": ": list[int]"}, {"fullname": "weavingspace.topology_elements.Vertex.base_ID", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.base_ID", "kind": "variable", "doc": "<p>ID of corresponding Vertex in the tileable base_unit</p>\n", "annotation": ": int", "default_value": "1000000"}, {"fullname": "weavingspace.topology_elements.Vertex.transitivity_class", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.transitivity_class", "kind": "variable", "doc": "<p>transitivity class of the vertex under symmetries of the tiling</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Vertex.label", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.label", "kind": "variable", "doc": "<p>the (upper case letter) label of the vertex under the symmetries of the \ntiling.</p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "weavingspace.topology_elements.Vertex.is_tiling_vertex", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.is_tiling_vertex", "kind": "variable", "doc": "<p>is_tiling_vertex (bool): True if this is a tiling vertex, rather than a \ntile corner. E.g., A below is a corner, not a tiling vertex. B is a tiling \nvertex:</p>\n\n<pre><code>+-------+\n| 1     |\n|   A---B---+\n|   | 2     |\n+---C   +---+\n    |   |\n    +---+\n</code></pre>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "weavingspace.topology_elements.Vertex.get_tile_IDs", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.get_tile_IDs", "kind": "function", "doc": "<p>Convenience method to return list of Tile IDs (not the Tiles themselves).</p>\n\n<p>Returns:\n    list[int]: list of Tile IDs</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Vertex.add_tile", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.add_tile", "kind": "function", "doc": "<p>Adds supplied Tile to the tiles list if it is not already present.</p>\n\n<p>Args:\n    tile (Tile): Tile to add.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tile</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Tile</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Vertex.add_neighbour", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.add_neighbour", "kind": "function", "doc": "<p>Adds supplied ID to the neighbours list if it is not already present</p>\n\n<p>Args:\n  vertex_id (int): ID to add to the neighbours list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vertex_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Vertex.clockwise_order_incident_tiles", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.clockwise_order_incident_tiles", "kind": "function", "doc": "<p>Reorders the tiles list clockwise (this is for dual tiling construction)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Vertex.is_interior", "modulename": "weavingspace.topology_elements", "qualname": "Vertex.is_interior", "kind": "function", "doc": "<p>Tests if vertex is completely enclosed by its incident Tiles. Based on\nsumming the interior angles of the incident tiles at this vertex.</p>\n\n<p>Returns:\n    bool: True if vertex is completely enclosed by incident Tiles.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Edge", "modulename": "weavingspace.topology_elements", "qualname": "Edge", "kind": "class", "doc": "<p>Class to represent edges in a tiling (not tile sides) per the definitions\nin Gr\u00fcnbaum and Shephard.</p>\n"}, {"fullname": "weavingspace.topology_elements.Edge.__init__", "modulename": "weavingspace.topology_elements", "qualname": "Edge.__init__", "kind": "function", "doc": "<p>Class constructor. Initialises the corners and vertices lists and sets ID\nto (vertices[0].ID, vertices[1].ID). The vertices list is all the corners\nwith is_tiling_vertex property True -- Note that during initialisation the\ndefault of this property is True until after the relations between tiles and\nvertices have been determined.</p>\n\n<p>Args:\n  corners (list[Vertex]): list of all corners along the edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">corners</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "weavingspace.topology_elements.Edge.ID", "modulename": "weavingspace.topology_elements", "qualname": "Edge.ID", "kind": "variable", "doc": "<p>IDs of the vertices at ends of the edge. Used as key in the containing \nTopology's edges dictionary.</p>\n", "annotation": ": tuple[int]"}, {"fullname": "weavingspace.topology_elements.Edge.vertices", "modulename": "weavingspace.topology_elements", "qualname": "Edge.vertices", "kind": "variable", "doc": "<p>two item list of the end vertices.</p>\n", "annotation": ": list[weavingspace.topology_elements.Vertex]"}, {"fullname": "weavingspace.topology_elements.Edge.corners", "modulename": "weavingspace.topology_elements", "qualname": "Edge.corners", "kind": "variable", "doc": "<p>list of all the vertices in the edge (including its end vertices). In a \n'normal' edge to edge tiling corners and vertices will be identical.</p>\n", "annotation": ": list[weavingspace.topology_elements.Vertex]"}, {"fullname": "weavingspace.topology_elements.Edge.right_tile", "modulename": "weavingspace.topology_elements", "qualname": "Edge.right_tile", "kind": "variable", "doc": "<p>the tile to the right of the edge traversed from its first to its last \nvertex. Given clockwise winding default, all edges will have a right_tile.</p>\n", "annotation": ": weavingspace.topology_elements.Tile", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Edge.left_tile", "modulename": "weavingspace.topology_elements", "qualname": "Edge.left_tile", "kind": "variable", "doc": "<p>the tile to the left of the edge traversed from its first to its last \nvertex. Exterior edges of the tiles in a Topology will not have a left_tile.</p>\n", "annotation": ": weavingspace.topology_elements.Tile", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Edge.base_ID", "modulename": "weavingspace.topology_elements", "qualname": "Edge.base_ID", "kind": "variable", "doc": "<p>ID of corresponding edge in the base tileable</p>\n", "annotation": ": tuple[int]", "default_value": "(1000000, 1000000)"}, {"fullname": "weavingspace.topology_elements.Edge.transitivity_class", "modulename": "weavingspace.topology_elements", "qualname": "Edge.transitivity_class", "kind": "variable", "doc": "<p>transitivity class of the edge under symmetries of the tiling</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology_elements.Edge.label", "modulename": "weavingspace.topology_elements", "qualname": "Edge.label", "kind": "variable", "doc": "<p>the (lower case letter) label of the edge under the symmetries of the \ntiling.</p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "weavingspace.topology_elements.Edge.get_corner_IDs", "modulename": "weavingspace.topology_elements", "qualname": "Edge.get_corner_IDs", "kind": "function", "doc": "<p>Convenience method to get the IDs of edge corners.</p>\n\n<p>Returns:\n    list[int]: IDs of all corners.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Edge.get_vertex_IDs", "modulename": "weavingspace.topology_elements", "qualname": "Edge.get_vertex_IDs", "kind": "function", "doc": "<p>Convenience method to get IDs of edge vertices.</p>\n\n<p>Returns:\n    list[int]: list of IDs of the vertices.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Edge.insert_vertex", "modulename": "weavingspace.topology_elements", "qualname": "Edge.insert_vertex", "kind": "function", "doc": "<p>Inserts a vertex along this edge after the specified predecessor \nVertex and returns this edge modified and a new edge. </p>\n\n<p>If the initial edge was (say) (0 1 2 5) and the predecessor was set to 1 \nthe returned edges would be (0 1 v) and (v 2 5).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">predecessor</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology_elements</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Edge.get_geometry", "modulename": "weavingspace.topology_elements", "qualname": "Edge.get_geometry", "kind": "function", "doc": "<p>Returns a geom.LineString representing the geometry (including all\ncorners) of this Edge, optionally starting at either end.</p>\n\n<p>Args:\n  forward (bool, optional): if True the returned LineString starts at\n    corners[0], else at corners[-1]. Defaults to True.</p>\n\n<p>Returns:\n  geom.LineString: the required LineString.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">forward</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology_elements.Edge.get_topology", "modulename": "weavingspace.topology_elements", "qualname": "Edge.get_topology", "kind": "function", "doc": "<p>Returns a LineString connecting the first and last corners (i.e. the\nvertices) of this tilin edge, optionally starting from either end.</p>\n\n<p>Args:\n  forward (bool, optional): if True LineString starts at vertices[0], \n    else at vertices[1]. Defaults to True.</p>\n\n<p>Returns:\n    geom.LineString: the required LineString.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">forward</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices", "modulename": "weavingspace.weave_matrices", "kind": "module", "doc": "<p>Functions to generate the matrices summarising tiles of tileable repeating \ngeometries that when repeated across a map area give the appearance of a woven surface \ncomposed of criss-crossing strands. </p>\n\n<p>Implementation is based on ideas discussed in variously</p>\n\n<ul>\n<li>Glassner, A. 2002. Digital weaving. 1. IEEE Computer Graphics and Applications 22 (6):108\u2013118.</li>\n<li>\u2014\u2014\u2014. 2003a. Digital weaving. 3. IEEE Computer Graphics and Applications 23 (2):80-83.</li>\n<li>\u2014\u2014\u2014. 2003b. Digital weaving. 2. IEEE Computer Graphics and Applications 23 (1):77-90.</li>\n</ul>\n\n<p>and (unpublished)</p>\n\n<ul>\n<li>Griswold, R. 2006. Mathematical and Computational Topics in Weaving\n<a href=\"https://www2.cs.arizona.edu/patterns/weaving/webdocs/mo/Griswold-MO.pdf\">https://www2.cs.arizona.edu/patterns/weaving/webdocs/mo/Griswold-MO.pdf</a> \n(accessed 29/10/21).</li>\n</ul>\n\n<p>where weaving is shown to be a matrix multiplication of tie-up, threading and \ntreadling matrices. An accessible introduction can be found at \n<a href=\"https://www.youtube.com/watch?v=oMOSiag3dxg\">https://www.youtube.com/watch?v=oMOSiag3dxg</a></p>\n"}, {"fullname": "weavingspace.weave_matrices.reps_needed", "modulename": "weavingspace.weave_matrices", "qualname": "reps_needed", "kind": "function", "doc": "<p>Returns how many repetitions of sequences of length x1 and x2 are \nneeded to make a matched length sequence </p>\n\n<p>Args:\n  x1 (int): length of first sequence.\n  x2 (int): length of second sequence.</p>\n\n<p>Returns:\n  tuple[int]: (number of repeats of x1, number of repeats of x2).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">x2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.get_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "get_pattern", "kind": "function", "doc": "<p>Returns a 0/1 encoded weave matrix. </p>\n\n<p>Given tie_up, treadling and threading matrices. The following conditions \nmust be satisfied to avoid non-conformable matrix error:</p>\n\n<p>treadling.shape[1] == tie_up.shape[0]\n  tie_up.shape[1] == threading.shape[0]</p>\n\n<p>The \"twill\", \"random\", \"basket\" and \"plain\" options should guarantee\nthis, but the \"this\" option requires the user to make this happen\nIf the warp_n and weft_n values are not factors of treadling.shape[0] and\nthreading.shape[1] respectively, the output matrix will be repeated as\nneeded to make this match</p>\n\n<p>Args:\n  tie_up (np.ndarray): the tie up matrix.\n  treadling (np.ndarray): the treadling matrix.\n  threading (np.ndarray): the threading matrix.\n  warp_n (int): the number of uniquely labelled warp threads.\n  weft_n (int): the number of uniquely labelled weft threads.\n  rep (int, optional): optional additional repetition of the output <br />\n    applied in both directions. Defaults to 1.</p>\n\n<p>Returns:\n  np.ndarray: _description_</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">treadling</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">threading</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">rep</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_plain_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_plain_pattern", "kind": "function", "doc": "<p>Returns plain weave (checkerboard) matrix.</p>\n\n<p>Args:\n  warp_n (int, optional): number of warp thread labels. Defaults to 1.\n  weft_n (int, optional): number of weft thread labels. Defaults to 1.</p>\n\n<p>Returns:\n  np.ndarray: 0/1 matrix where 1 = warp on top.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_twill_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_twill_pattern", "kind": "function", "doc": "<p>Returns twill pattern matrix extended for warp and weft patterns.</p>\n\n<p>n is the number of over-unders. With n = 1 we get a plain weave.</p>\n\n<p>Args:\n  n (Union[int,tuple[int]], optional): specifies over-under sequence in\n    the weave. Defaults to 2.\n  warp_n (int, optional): number of warp thread labels. Defaults to 2.\n  weft_n (int, optional): number of weft thread labels. Defaults to 2.</p>\n\n<p>Returns:\n  np.ndarray: _description_</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_over_under_row", "modulename": "weavingspace.weave_matrices", "qualname": "make_over_under_row", "kind": "function", "doc": "<p>Returns a tuple of runs of 1s and 0s.</p>\n\n<p>Returns a tuple of runs of 1s and 0s per supplied n. </p>\n\n<p>If n is an integer, returned tuple will be a series of n 1s followed by\nn 0s.</p>\n\n<p>If n is a tuple of odd length it will be repeated to produce an even\nlength over-under sequence. This is required to avoid cases such as\ne.g, (1,2,3) -> 100111 which repeated is 1001111001111, i.e. a (2,4)\npattern. Repeating it yields 100111011000 which is the requested pattern.</p>\n\n<p>Args:\n  n (Union[int,tuple[int]]): requested over-under sequence. See details.</p>\n\n<p>Returns:\n  list[int]: list of runs of 1s and 0s in the requested pattern.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.wrap_row", "modulename": "weavingspace.weave_matrices", "qualname": "wrap_row", "kind": "function", "doc": "<p>Wraps the list r by number of positions.</p>\n\n<p>Positive by will shift right.\nNegative shifts left.</p>\n\n<p>Args:\n  r (list): list to wrap.\n  by (int, optional): number of positions to shift by. Defaults to 1.</p>\n\n<p>Returns:\n  list: wrapped list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">by</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_twill_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "make_twill_matrix", "kind": "function", "doc": "<p>Makes a twill 0/1 matrix.</p>\n\n<p>Makes a matrix like</p>\n\n<p>1 1 0 0\n  0 1 1 0\n  0 0 1 1\n  1 0 0 1</p>\n\n<p>where the repeat runs in each row are lengths returned by\nmake_over_under_rown(n)</p>\n\n<p>Args:\n  over_under (Union[int,tuple[int]]): over-under run specification. See\n    make_over_under_row().</p>\n\n<p>Returns:\n  np.ndarray: a matrix of 0s and 1s.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">over_under</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_basket_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_basket_pattern", "kind": "function", "doc": "<p>Returns basket pattern matrix extended for warp and weft patterns.</p>\n\n<p>Args:\n  n (int, optional): over under count. Defaults to 2.\n  warp_n (int, optional): number of warp thread labels. Defaults to 2.\n  weft_n (int, optional): number of weft thread labels. Defaults to 2.</p>\n\n<p>Returns:\n  np.ndarray: _description_</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_basket_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "make_basket_matrix", "kind": "function", "doc": "<p>Returns a basket weave pattern matrix.</p>\n\n<p>Makes a matrix like</p>\n\n<p>1 1 0 0\n  1 1 0 0\n  0 0 1 1\n  0 0 1 1</p>\n\n<p>where the repeat runs in each row are length n</p>\n\n<p>Args:\n  n (int): dimension of the 'basket' over-under pattern.</p>\n\n<p>Returns:\n  np.ndarray: 0/1 matrix in basket weave pattern.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_this_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_this_pattern", "kind": "function", "doc": "<p>Pass through returns weave pattern matrix from supplied input.</p>\n\n<p>This is just a pass through function which applies suitable size identity. \nCould try to enforce</p>\n\n<p>treadling.shape[1] == tie_up.shape[0] and \n  tie_up.shape[1] == threading.shape[0]</p>\n\n<p>but unsure what would be an appropriate way to do this...</p>\n\n<p>Args:\n  tie_up (np.ndarray): desired weave pattern.\n  threading (np.ndarray): desired threading pattern.\n  treadling (np.ndarray): desired treadling pattern.\n  warp_n (int, optional): number of warp thread labels. Defaults to 1.\n  weft_n (int, optional): number of weft thread labels. Defaults to 1.</p>\n\n<p>Returns:\n  np.ndarray: resulting 0/1 weave pattern matrix.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">threading</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">treadling</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.get_weave_pattern_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "get_weave_pattern_matrix", "kind": "function", "doc": "<p>Returns encoded weave pattern matrix.</p>\n\n<p>See <code>_encode_biaxial_weave()</code> for the encoding.</p>\n\n<p>Allowed weave_types: \"plain\", \"twill\", \"basket\", and \"this\" (pass-thru).\nThese are explained in the respective functions to which this function\ndelegates construction of the base matrices before applying the encoding.</p>\n\n<p>Args:\n  weave_type (str, optional): one of \"plain\", \"twill\", \"basket\" or\n    \"this\". Defaults to \"plain\".\n  n (Union[int,tuple[int]], optional): over under pattern. See \n    make_over_under_row() for details. Defaults to 2.\n  warp (Union[list[str],tuple[str]], optional): list of labels for warp \n    strands. Defaults to [\"a\", \"b\"].\n  weft (Union[list[str],tuple[str]], optional): list of labels for weft \n    strands. Defaults to [\"c\", \"d\"].\n  tie_up (np.ndarray, optional): a weave pattern matrix to pass thru in \n    the \"this\" case. Defaults to make_twill_matrix((2, 2)).\n  tr (np.ndarray, optional): treadling matrix for the \"this\" case. <br />\n    Defaults to None.\n  th (np.ndarray, optional): threading matrix for the \"this\" case. <br />\n    Defaults to None.</p>\n\n<p>Returns:\n  np.ndarray: encoded weave pattern matrix.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">weave_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;plain&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">warp</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">weft</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;c&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;d&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>,</span><span class=\"param\">\t<span class=\"n\">tr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">th</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_unit", "modulename": "weavingspace.weave_unit", "kind": "module", "doc": "<p>The <code>WeaveUnit</code> subclass of <code>weavingspace.tileable.Tileable</code> implements\ntileable geometric patterns constructed by specifying 2- or 3-axial weaves.</p>\n\n<p>Examples:\n  Explain usage here...</p>\n"}, {"fullname": "weavingspace.weave_unit.WeaveUnit", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit", "kind": "class", "doc": "<p>Extends Tileable to allow for tiles that appear like woven patterns.</p>\n", "bases": "weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.__init__", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.weave_type", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.weave_type", "kind": "variable", "doc": "<p>type of weave pattern, one of <code>plain</code>, <code>twill</code>, <code>basket</code>, <code>cube</code>, <code>hex</code> or\n<code>this</code>. Defaults to <code>plain</code>.</p>\n", "annotation": ": str", "default_value": "&#x27;plain&#x27;"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.aspect", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.aspect", "kind": "variable", "doc": "<p>width of strands relative to the <code>spacing</code>. Defaults to 1.0.</p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.n", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.n", "kind": "variable", "doc": "<p>number of over-under strands in biaxial weaves. Only one item is \nrequired in a plain weave. Twill and basket patterns expect an even number of \nentries in the tuple.</p>\n", "annotation": ": Union[int, tuple[int]]", "default_value": "(2, 2)"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.strands", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.strands", "kind": "variable", "doc": "<p>specification of the strand labels along each axis. Defaults to <code>a|b|c</code>.</p>\n", "annotation": ": str", "default_value": "&#x27;a|b|c&#x27;"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();