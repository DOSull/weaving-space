window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "weavingspace", "modulename": "weavingspace", "kind": "module", "doc": "<p>See <a href=\"https://github.com/DOSull/weaving-space/blob/main/examples/using-the-library.ipynb\">https://github.com/DOSull/weaving-space/blob/main/examples/using-the-library.ipynb</a>)\nfor introductory usage guidance.</p>\n"}, {"fullname": "weavingspace.symmetry", "modulename": "weavingspace.symmetry", "kind": "module", "doc": "<p>Classes for working with symmetries.</p>\n"}, {"fullname": "weavingspace.symmetry.KMP_Matcher", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher", "kind": "class", "doc": "<p>Class to find matching subsequences in a sequence.</p>\n"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.__init__", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.sequence", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.sequence", "kind": "variable", "doc": "<p>Iterable in which subsequences are to be found.</p>\n", "annotation": ": Sequence"}, {"fullname": "weavingspace.symmetry.KMP_Matcher.find_matches", "modulename": "weavingspace.symmetry", "qualname": "KMP_Matcher.find_matches", "kind": "function", "doc": "<p>Find matches in supplied pattern using Knuth-Morris-Pratt algorithm.</p>\n\n<p>See:\n<a href=\"https://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm\">https://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm</a> which provides\ndetailed pseudo-code on which this code is directly based. See also:</p>\n\n<p>Knuth DE, JH Morris Jr, and VR Pratt. 1977. Fast pattern  matching in\nstrings. SIAM Journal on Computing 6(2): 323-350. doi: 10.1137/0206024.</p>\n\n<p>This implementation expects sequences of tuples of floats, although in\nprinciple any objects could be contained in the Sequence.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pattern (Sequence[tuple[float,...]]):</strong>  The sequence to match.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sequence[int]: the index positions at which matches are found.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pattern</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform", "modulename": "weavingspace.symmetry", "qualname": "Transform", "kind": "class", "doc": "<p>Class to store details of a transform and draw it.</p>\n"}, {"fullname": "weavingspace.symmetry.Transform.__init__", "modulename": "weavingspace.symmetry", "qualname": "Transform.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transform_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.Transform.transform_type", "modulename": "weavingspace.symmetry", "qualname": "Transform.transform_type", "kind": "variable", "doc": "<p>Type of transform 'rotation', 'reflection', 'translation' or 'identity'.</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.symmetry.Transform.angle", "modulename": "weavingspace.symmetry", "qualname": "Transform.angle", "kind": "variable", "doc": "<p>Angle of rotation (degrees).</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.symmetry.Transform.centre", "modulename": "weavingspace.symmetry", "qualname": "Transform.centre", "kind": "variable", "doc": "<p>Centre of the transformation.</p>\n", "annotation": ": shapely.geometry.point.Point"}, {"fullname": "weavingspace.symmetry.Transform.translation", "modulename": "weavingspace.symmetry", "qualname": "Transform.translation", "kind": "variable", "doc": "<p>X and Y coordinates shifts of a translation transform. A glide reflection\nmay also include this.</p>\n", "annotation": ": tuple[float, ...]"}, {"fullname": "weavingspace.symmetry.Transform.transform", "modulename": "weavingspace.symmetry", "qualname": "Transform.transform", "kind": "variable", "doc": "<p>Six element tuple for the transform in shapely.transform format. See\n<a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a>\nand methods in <code>weavingspace.tiling_utils</code>.</p>\n", "annotation": ": tuple[float, ...]"}, {"fullname": "weavingspace.symmetry.Transform.apply", "modulename": "weavingspace.symmetry", "qualname": "Transform.apply", "kind": "function", "doc": "<p>Apply this transform to supplied shapely geometry and return result.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>geometry (shapely.Geometry):</strong>  a shapely geometry to transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>shapely.Geometry: the resulting transformed shapely geometry.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">Geometry</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">Geometry</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw", "kind": "function", "doc": "<p>Draw this transform on the supplied axes.</p>\n\n<p>Arguments specific to each transform type are supplied as **kwargs and are\ndocumented in <code>draw_rotation</code>, <code>draw_reflection</code>, and <code>draw_translation</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (pyplot.axes):</strong>  the axes on which to draw the transform.</li>\n<li><strong>kwargs:</strong>  passed on to specific draw method.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pyplot.Axes: the axes with the rendering of this transform added.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_rotation", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_rotation", "kind": "function", "doc": "<p>Draw a rotation transform on the supplied Axes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (pyplot.Axes):</strong>  axes on which to draw the representation.</li>\n<li><strong>radius (float):</strong>  radius in object units to draw arcs representing the\nangle. Defaults to 200.</li>\n<li><strong>add_title (bool):</strong>  whether or not to add a title to the drawing.\nDefaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the Axes with the rendering of this transform added.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">200</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_reflection", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_reflection", "kind": "function", "doc": "<p>Draw a reflection transform on the supplied Axes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (pyplot.Axes):</strong>  axes on which to draw the representation.</li>\n<li><strong>w (float):</strong>  linewidth for the mirror line. Defaults to 5.</li>\n<li><strong>mirror_length (float):</strong>  length of the mirror line in units of the\nobjects being reflected. Defaults to 100.</li>\n<li><strong>add_title (bool):</strong>  whether or not to add a title to the drawing.\nDefaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the Axes with the rendering of this transform added.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">mirror_length</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Transform.draw_translation", "modulename": "weavingspace.symmetry", "qualname": "Transform.draw_translation", "kind": "function", "doc": "<p>Draw a translation transform on the supplied Axes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (pyplot.Axes):</strong>  axes on which to draw the representation.</li>\n<li><strong>c (geom.Point):</strong>  an origin point in the coordinate space of the objects\nfrom which to start the arrow representing the translation.</li>\n<li><strong>w (float):</strong>  linewidth for the arrow. Defaults to 5.</li>\n<li><strong>add_title (bool):</strong>  whether or not to add a title to the drawing.\nDefaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the Axes with the rendering of this transform added.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">add_title</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries", "kind": "class", "doc": "<p>Class to identify and store symmetries of a shapely.Polygon.</p>\n"}, {"fullname": "weavingspace.symmetry.Symmetries.__init__", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.__init__", "kind": "function", "doc": "<p>Construct a Symmetries instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.Symmetries.polygon", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.polygon", "kind": "variable", "doc": "<p>Polygon from which these symmetries are derived.</p>\n", "annotation": ": shapely.geometry.polygon.Polygon"}, {"fullname": "weavingspace.symmetry.Symmetries.matcher", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.matcher", "kind": "variable", "doc": "<p>the subsequence matcher used in symmetry detection.</p>\n", "annotation": ": weavingspace.symmetry.KMP_Matcher"}, {"fullname": "weavingspace.symmetry.Symmetries.n", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.n", "kind": "variable", "doc": "<p>number of vertices of the polygon.</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.symmetry.Symmetries.poly_code", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.poly_code", "kind": "variable", "doc": "<p>the encoding of the polygon as sequence of length, angle pairs.</p>\n", "annotation": ": list[tuple[float, ...]]"}, {"fullname": "weavingspace.symmetry.Symmetries.poly_code_r", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.poly_code_r", "kind": "variable", "doc": "<p>the reversed encoding used to detect reflection symmetries.</p>\n", "annotation": ": list[tuple[float, ...]]"}, {"fullname": "weavingspace.symmetry.Symmetries.rotation_shifts", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.rotation_shifts", "kind": "variable", "doc": "<p>list of number of 2pi/n rotation symmetries.</p>\n", "annotation": ": list[int]"}, {"fullname": "weavingspace.symmetry.Symmetries.reflection_shifts", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.reflection_shifts", "kind": "variable", "doc": "<p>list of pi/n relection angle symmetries.</p>\n", "annotation": ": list[int]"}, {"fullname": "weavingspace.symmetry.Symmetries.symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.symmetries", "kind": "variable", "doc": "<p>list of Transform objects with more complete information.</p>\n", "annotation": ": list[weavingspace.symmetry.Transform]"}, {"fullname": "weavingspace.symmetry.Symmetries.symmetry_group", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.symmetry_group", "kind": "variable", "doc": "<p>the code denoting the symmetry group</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.symmetry.Symmetries.get_symmetries", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_symmetries", "kind": "function", "doc": "<p>Find rotation and reflection symmetries of a polygon.</p>\n\n<p>The work is delegated to <code>get_rotations()</code> and <code>get_reflections()</code>.</p>\n\n<p>Based on</p>\n\n<p>Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and\n  Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology.\n  North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.</p>\n\n<p>and also</p>\n\n<p>Wolter JD, TC Woo, and RA Volz. 1985. Optimal algorithms for symmetry\n  detection in two and three dimensions. The Visual Computer 1(1): 37-48.\n  doi: 10.1007/BF01901268.</p>\n\n<p>Details in these papers are not unambiguous. This implementation was\ndeveloped based on them, but with some trial and error to get the index\noffsets and (especially) retrieval of the reflection axes angles to work.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Transform]: a list of Transform objects representing the polygon\n    symmetries.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_rotations", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_rotations", "kind": "function", "doc": "<p>Get the rotations associated with this collection of symmetries.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Transform]: A list of the rotation symmetries associated with this\n    Symmetries instance's polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_reflections", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_reflections", "kind": "function", "doc": "<p>Get the reflections associated with this collection of symmetries.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>offsets (list[int]):</strong>  list of integer offsets i where i / n * 360 where n\nis the number of sides of this Symmetries instance's polygons is the\nangle of the mirror in which a reflection symmetry has been identified.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Transform]: A list of the reflection symmetries associated with this\n    Symmetries instance's polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_symmetry_group_code", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_symmetry_group_code", "kind": "function", "doc": "<p>Return symmetry group code for this instance's polygon.</p>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Symmetry_group#Two_dimensions\">https://en.wikipedia.org/wiki/Symmetry_group#Two_dimensions</a>.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: code such as C2 or D4 for cyclic or dihedral symmetry groups.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.Symmetries.get_corner_offset", "modulename": "weavingspace.symmetry", "qualname": "Symmetries.get_corner_offset", "kind": "function", "doc": "<p>Find offset between corners of this polygon and another one.</p>\n\n<p>The offset is determined under whatever transformation will match one on\nto the other. Used by the <code>Topology</code> class. The offset is expressed as the\nnumber of corners clockwise by which the supplied polygon is offset from\nthis one.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>poly2 (geom.Polygon):</strong>  polygon for which the offset is desired.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int|None: integer number of corners clockwise by which the polygon\n    is offset from this one, or None if they don't match.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">poly2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.symmetry.ShapeMatcher", "modulename": "weavingspace.symmetry", "qualname": "ShapeMatcher", "kind": "class", "doc": "<p>Class to manage finding transforms that map one polygon on to another.</p>\n\n<p>This was previously handled 'internally' by an earlier version of the\nSymmetries code, but that quickly became ungainly and difficult to maintain.\nThis approach makes for cleaner code, and does the additional work of finding\ne.g. centres of rotations (which may lie outside either or both polygons).</p>\n"}, {"fullname": "weavingspace.symmetry.ShapeMatcher.__init__", "modulename": "weavingspace.symmetry", "qualname": "ShapeMatcher.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span>)</span>"}, {"fullname": "weavingspace.symmetry.ShapeMatcher.shape", "modulename": "weavingspace.symmetry", "qualname": "ShapeMatcher.shape", "kind": "variable", "doc": "<p>The target polygon on to which matching transforms are required.</p>\n", "annotation": ": shapely.geometry.polygon.Polygon"}, {"fullname": "weavingspace.symmetry.ShapeMatcher.s1", "modulename": "weavingspace.symmetry", "qualname": "ShapeMatcher.s1", "kind": "variable", "doc": "<p>The Symmetries of the target polygon.</p>\n", "annotation": ": weavingspace.symmetry.Symmetries"}, {"fullname": "weavingspace.symmetry.ShapeMatcher.get_polygon_matches", "modulename": "weavingspace.symmetry", "qualname": "ShapeMatcher.get_polygon_matches", "kind": "function", "doc": "<p>Return all transforms that match shape2 onto this instance's polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape2 (geom.Polygon):</strong>  polygon for which matching transforms are\nrequested.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Transform]|None: a list of Transforms that will match shape2\n    onto this instance's shape. None is returned if no matching transforms\n    are found.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">shape2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map", "modulename": "weavingspace.tile_map", "kind": "module", "doc": "<p>Classes for tiling maps.</p>\n\n<p><code>weavingspace.tile_map.Tiling</code> and\n<code>weavingspace.tile_map.TiledMap</code> are exposed in the  public API and\nrespectively enable creation of a tiling and plotting of the tiling as a\nmultivariate map.</p>\n"}, {"fullname": "weavingspace.tile_map.CMAPS_SEQUENTIAL", "modulename": "weavingspace.tile_map", "qualname": "CMAPS_SEQUENTIAL", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Greys&#x27;, &#x27;Greys_r&#x27;, &#x27;Purples&#x27;, &#x27;Purples_r&#x27;, &#x27;Blues&#x27;, &#x27;Blues_r&#x27;, &#x27;Greens&#x27;, &#x27;Greens_r&#x27;, &#x27;Oranges&#x27;, &#x27;Oranges_r&#x27;, &#x27;Reds&#x27;, &#x27;Reds_r&#x27;, &#x27;viridis&#x27;, &#x27;viridis_r&#x27;, &#x27;plasma&#x27;, &#x27;plasma_r&#x27;, &#x27;inferno&#x27;, &#x27;inferno_r&#x27;, &#x27;magma&#x27;, &#x27;magma_r&#x27;, &#x27;cividis&#x27;, &#x27;cividis_r&#x27;, &#x27;YlOrBr&#x27;, &#x27;YlOrBr_r&#x27;, &#x27;YlOrRd&#x27;, &#x27;YlOrRd_r&#x27;, &#x27;OrRd&#x27;, &#x27;OrRd_r&#x27;, &#x27;PuRd&#x27;, &#x27;PuRd_r&#x27;, &#x27;RdPu&#x27;, &#x27;RdPu_r&#x27;, &#x27;BuPu&#x27;, &#x27;BuPu_r&#x27;, &#x27;GnBu&#x27;, &#x27;GnBu_r&#x27;, &#x27;PuBu&#x27;, &#x27;PuBu_r&#x27;, &#x27;YlGnBu&#x27;, &#x27;YlGnBu_r&#x27;, &#x27;PuBuGn&#x27;, &#x27;PuBuGn_r&#x27;, &#x27;BuGn&#x27;, &#x27;BuGn_r&#x27;, &#x27;YlGn&#x27;, &#x27;YlGn_r&#x27;, &#x27;binary&#x27;, &#x27;binary_r&#x27;, &#x27;gist_yarg&#x27;, &#x27;gist_yarg_r&#x27;, &#x27;gist_gray&#x27;, &#x27;gist_gray_r&#x27;, &#x27;gray&#x27;, &#x27;gray_r&#x27;, &#x27;bone&#x27;, &#x27;bone_r&#x27;, &#x27;pink&#x27;, &#x27;pink_r&#x27;, &#x27;spring&#x27;, &#x27;spring_r&#x27;, &#x27;summer&#x27;, &#x27;summer_r&#x27;, &#x27;autumn&#x27;, &#x27;autumn_r&#x27;, &#x27;winter&#x27;, &#x27;winter_r&#x27;, &#x27;cool&#x27;, &#x27;cool_r&#x27;, &#x27;Wistia&#x27;, &#x27;Wistia_r&#x27;, &#x27;hot&#x27;, &#x27;hot_r&#x27;, &#x27;afmhot&#x27;, &#x27;afmhot_r&#x27;, &#x27;gist_heat&#x27;, &#x27;gist_heat_r&#x27;, &#x27;copper&#x27;, &#x27;copper_r&#x27;]"}, {"fullname": "weavingspace.tile_map.CMAPS_DIVERGING", "modulename": "weavingspace.tile_map", "qualname": "CMAPS_DIVERGING", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;PiYG&#x27;, &#x27;PiYG_r&#x27;, &#x27;PRGn&#x27;, &#x27;PRGn_r&#x27;, &#x27;BrBG&#x27;, &#x27;BrBG_r&#x27;, &#x27;PuOr&#x27;, &#x27;PuOr_r&#x27;, &#x27;RdGy&#x27;, &#x27;RdGy_r&#x27;, &#x27;RdBu&#x27;, &#x27;RdBu_r&#x27;, &#x27;RdYlBu&#x27;, &#x27;RdYlBu_r&#x27;, &#x27;RdYlGn&#x27;, &#x27;RdYlGn_r&#x27;, &#x27;Spectral&#x27;, &#x27;Spectral_r&#x27;, &#x27;coolwarm&#x27;, &#x27;coolwarm_r&#x27;, &#x27;bwr&#x27;, &#x27;bwr_r&#x27;, &#x27;seismic&#x27;, &#x27;seismic_r&#x27;]"}, {"fullname": "weavingspace.tile_map.CMAPS_CATEGORICAL", "modulename": "weavingspace.tile_map", "qualname": "CMAPS_CATEGORICAL", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;Pastel1&#x27;, &#x27;Pastel1_r&#x27;, &#x27;Pastel2&#x27;, &#x27;Pastel2_r&#x27;, &#x27;Paired&#x27;, &#x27;Paired_r&#x27;, &#x27;Accent&#x27;, &#x27;Accent_r&#x27;, &#x27;Dark2&#x27;, &#x27;Dark2_r&#x27;, &#x27;Set1&#x27;, &#x27;Set1_r&#x27;, &#x27;Set2&#x27;, &#x27;Set2_r&#x27;, &#x27;Set3&#x27;, &#x27;Set3_r&#x27;, &#x27;tab10&#x27;, &#x27;tab10_r&#x27;, &#x27;tab20&#x27;, &#x27;tab20_r&#x27;, &#x27;tab20b&#x27;, &#x27;tab20b_r&#x27;, &#x27;tab20c&#x27;, &#x27;tab20c_r&#x27;]"}, {"fullname": "weavingspace.tile_map.Tiling", "modulename": "weavingspace.tile_map", "qualname": "Tiling", "kind": "class", "doc": "<p>Class that applies a <code>Tileable</code> object to a region to be mapped.</p>\n\n<p>The result of the tiling procedure is stored in the <code>tiles</code> variable and\ncovers a region sufficient that the tiling can be rotated to any desired\nangle. Rotation can be requested when the render method is called.</p>\n"}, {"fullname": "weavingspace.tile_map.Tiling.__init__", "modulename": "weavingspace.tile_map", "qualname": "Tiling.__init__", "kind": "function", "doc": "<p>Construct a tiling by polygons extending beyond supplied region.</p>\n\n<p>The tiling is extended sufficiently to allow for its application at any\nrotation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tileable (Tileable):</strong>  the TileUnit or WeaveUnit to use.</li>\n<li><strong>region (gpd.GeoDataFrame):</strong>  the region to be tiled.</li>\n<li><strong>as_icons (bool, optional):</strong>  if True prototiles will only be placed at the\nregion's zone centroids, one per zone. Defaults to False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tileable</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>,</span><span class=\"param\">\t<span class=\"n\">region</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">as_icons</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "weavingspace.tile_map.Tiling.tileable", "modulename": "weavingspace.tile_map", "qualname": "Tiling.tileable", "kind": "variable", "doc": "<p>Tileable on which the tiling is based.</p>\n", "annotation": ": weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.tile_map.Tiling.region", "modulename": "weavingspace.tile_map", "qualname": "Tiling.region", "kind": "variable", "doc": "<p>the region to be tiled.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame"}, {"fullname": "weavingspace.tile_map.Tiling.region_union", "modulename": "weavingspace.tile_map", "qualname": "Tiling.region_union", "kind": "variable", "doc": "<p>a single polygon of all the areas in the region to be tiled</p>\n", "annotation": ": shapely.geometry.polygon.Polygon"}, {"fullname": "weavingspace.tile_map.Tiling.grid", "modulename": "weavingspace.tile_map", "qualname": "Tiling.grid", "kind": "variable", "doc": "<p>the grid which will be used to apply the tiling.</p>\n", "annotation": ": weavingspace.tile_map._TileGrid"}, {"fullname": "weavingspace.tile_map.Tiling.tiles", "modulename": "weavingspace.tile_map", "qualname": "Tiling.tiles", "kind": "variable", "doc": "<p>the tiles after tiling has been carried out.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame"}, {"fullname": "weavingspace.tile_map.Tiling.prototiles", "modulename": "weavingspace.tile_map", "qualname": "Tiling.prototiles", "kind": "variable", "doc": "<p>the prototiles after tiling has been carried out.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame"}, {"fullname": "weavingspace.tile_map.Tiling.rotation", "modulename": "weavingspace.tile_map", "qualname": "Tiling.rotation", "kind": "variable", "doc": "<p>additional rotation applied to the tiling beyond any that might have\nbeen 'baked in' to the Tileable.</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.Tiling.get_tiled_map", "modulename": "weavingspace.tile_map", "qualname": "Tiling.get_tiled_map", "kind": "function", "doc": "<p>Return a <code>TiledMap</code> filling a region at the requested rotation.</p>\n\n<p>HERE BE DRAGONS! This function took a lot of trial and error to get right,\nso modify with CAUTION!</p>\n\n<p>The <code>proritise_tiles = True</code> option means that the tiling will not break\nup the tiles in <code>TileUnit</code>s at the boundaries between areas in the mapped\nregion, but will instead ensure that tiles remain complete, picking up\ntheir data from the region zone which they overlap the most.</p>\n\n<p>The exact order in which operations are performed affects performance. For\nexample, the final clipping to self.region when ragged_edges = False is\n_much_ slower if it is carried out before the dissolving of tiles into the\nregion zones. So... again... modify CAREFULLY!</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rotation (float, optional):</strong>  Optional rotation to apply. Defaults to 0.</li>\n<li><strong>join_on_prototiles (bool, optional):</strong>  if True data from the region dataset\nare joined to tiles based on the prototile to which they belong. If\nFalse the join is based on the tiles in relation to the region areas.\nFor weave-based tilings False is probably to be preferred. Defaults to\nFalse.</li>\n<li><strong>retain_tileables (bool, optional):</strong>  if True complete tileable units will\nbe retained. If False tile unit elements that do not overlap the map\narea will be discarded.</li>\n<li><strong>prioritise_tiles (bool, optional):</strong>  if True tiles will not be broken at\nboundaries in the region dataset. Defaults to True.</li>\n<li><strong>ragged_edges (bool, optional):</strong>  if True tiles at the edge of the region\nwill not be cut by the region extent - ignored if prioritise_tiles is\nFalse when edges will always be clipped to the region extent. Defaults\nto True.</li>\n<li><strong>use_centroid_lookup_approximation (bool, optional):</strong>  if True use tile\ncentroids for lookup of region data - ignored if prioritise_tiles is\nFalse when it is irrelevant. Defaults to False.</li>\n<li><strong>debug (bool, optional):</strong>  if True prints timing messages. Defaults to\nFalse.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>TiledMap: a TiledMap of the region with attributes attached to tiles.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">join_on_prototiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">retain_tileables</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prioritise_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">ragged_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_centroid_lookup_approximation</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_map</span><span class=\"o\">.</span><span class=\"n\">TiledMap</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.Tiling.make_tiling", "modulename": "weavingspace.tile_map", "qualname": "Tiling.make_tiling", "kind": "function", "doc": "<p>Tile the region with a tile unit, returning a GeoDataFrame.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geopandas.GeoDataFrame: a GeoDataFrame of the region tiled with the\n    tile unit.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.Tiling.rotated", "modulename": "weavingspace.tile_map", "qualname": "Tiling.rotated", "kind": "function", "doc": "<p>Return the stored tiling rotated.</p>\n\n<p>The stored tiling never changes and\nif it was originally made with a Tileable that was rotated it will retain\nthat rotation. The requested rotation is _additional_ to that baseline\nrotation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rotation (float, optional):</strong>  Rotation angle in degrees.\nDefaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoDataFrame: Rotated tiling.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">,</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap", "modulename": "weavingspace.tile_map", "qualname": "TiledMap", "kind": "class", "doc": "<p>Class representing a tiled map.</p>\n\n<p>Should not be accessed directly, but will\nbe created by calling <code>Tiling.get_tiled_map()</code>. After creation the variables\nand colourmaps attributes can be set, and then <code>TiledMap.render()</code> called to\nmake a map. Settable attributes are explained in documentation of the\n<code>TiledMap.render()</code> method.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <p>Recommended usage is as follows. First, make a <code>TiledMap</code> from a <code>Tiling</code>\n  object:</p>\n  \n  <p><code>tm = tiling.get_tiled_map(...)</code></p>\n  \n  <p>Some options in the <code>Tiling</code> constructor affect the map appearance. See\n  <code>Tiling</code> for details.</p>\n  \n  <p>Once a <code>TiledMap</code> object exists, set options on it, either when calling\n  <code>TiledMap.render()</code> or explicitly, i.e.</p>\n  \n  <p>tm.render(opt1 = val1, opt2 = val2, ...)</p>\n  \n  <p>or</p>\n  \n  <p>tm.opt1 = val1\n    tm.opt2 = val2\n    tm.render()</p>\n  \n  <p>Option settings are persistent, i.e. unless a new <code>TiledMap</code> object is\n  created the option settings have to be explicitly reset to new values on\n  subsequent calls to <code>TiledMap.render()</code>.</p>\n  \n  <p>The most important options are the <code>vars_map</code> and <code>colors_to_use</code> settings.</p>\n  \n  <p><code>vars_to_map</code> is a lost of the dataset variable names to match with\n  <code>weavingspace.tileable.Tileable</code> elements with corresponding (ordered)\n  tile_ids (usually \"a\", \"b\", etc.). If you need to control the match, then\n  also supply <code>ids_to_map</code> in matching order. E.g.</p>\n  \n  <p>tm.ids_to_map = ['d', 'c', 'b', 'a']\n    tm.vars_to_map = ['x1', 'x2', 'x3', 'x4']</p>\n  \n  <p>Note that this means that if you really want more than one element in the\n  tiling to represent the same variable more than once, you can do that.</p>\n  \n  <p><code>colors_to_use</code> is a parallel list of named matplotlib colormaps,</p>\n  \n  <p>tm.colors_to_use = [\"Reds\", \"Blues\", \"Greys\", \"Purples\"]</p>\n  \n  <p>Similarly, you can specify the classification <code>schemes_to_use</code> (such as\n  'quantiles') and the number of classes <code>n_classes</code> in each.</p>\n  \n  <p>If data are categorical, this is flagged in the <code>categoricals</code> list of\n  booleans, in which case an appropriate colour map should be used. There is\n  currently no provision for control of which colour in a categorical\n  colour map is applied to which variable level.</p>\n  \n  <p>TODO: better control of categorical mapping schemes.</p>\n</blockquote>\n"}, {"fullname": "weavingspace.tile_map.TiledMap.__init__", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tiling</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_map</span><span class=\"o\">.</span><span class=\"n\">Tiling</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"nb\">map</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ids_to_map</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">vars_to_map</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">colors_to_use</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">categoricals</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schemes_to_use</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_classes</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">_colourspecs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_buffer</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">buffer_colour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;grey&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">legend_zoom</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">legend_dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">legend_dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">use_ellipse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ellipse_magnification</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">radial_key</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">draft_mode</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">dpi</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">72</span></span>)</span>"}, {"fullname": "weavingspace.tile_map.TiledMap.tiling", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.tiling", "kind": "variable", "doc": "<p>the Tiling with the required tiles</p>\n", "annotation": ": weavingspace.tile_map.Tiling"}, {"fullname": "weavingspace.tile_map.TiledMap.map", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.map", "kind": "variable", "doc": "<p>the GeoDataFrame on which this map is based</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame"}, {"fullname": "weavingspace.tile_map.TiledMap.ids_to_map", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.ids_to_map", "kind": "variable", "doc": "<p>tile_ids that are to be used to represent data</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.tile_map.TiledMap.vars_to_map", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.vars_to_map", "kind": "variable", "doc": "<p>dataset variables that are to be symbolised</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.tile_map.TiledMap.colors_to_use", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.colors_to_use", "kind": "variable", "doc": "<p>list of matplotlib colormap names.</p>\n", "annotation": ": list[str | list[str]]"}, {"fullname": "weavingspace.tile_map.TiledMap.categoricals", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.categoricals", "kind": "variable", "doc": "<p>list specifying if each variable is -- or is to be treated as --\ncategorical</p>\n", "annotation": ": list[bool]"}, {"fullname": "weavingspace.tile_map.TiledMap.schemes_to_use", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.schemes_to_use", "kind": "variable", "doc": "<p>mapclassify schemes to use for each variable.</p>\n", "annotation": ": list[str | None]"}, {"fullname": "weavingspace.tile_map.TiledMap.n_classes", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.n_classes", "kind": "variable", "doc": "<p>number of classes to apply; if set to 0 will be unclassed.</p>\n", "annotation": ": list[int | None]"}, {"fullname": "weavingspace.tile_map.TiledMap.add_buffer", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.add_buffer", "kind": "variable", "doc": "<p>if True then include a buffer of all tiles as a background</p>\n", "annotation": ": bool"}, {"fullname": "weavingspace.tile_map.TiledMap.buffer_colour", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.buffer_colour", "kind": "variable", "doc": "<p>colour of any include buffer layer</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.tile_map.TiledMap.legend", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend", "kind": "variable", "doc": "<p>whether or not to show a legend</p>\n", "annotation": ": bool"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_zoom", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_zoom", "kind": "variable", "doc": "<p>&lt;1 zooms out from legend to show more context</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_dx", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_dx", "kind": "variable", "doc": "<p>x shift of legend relative to the map</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.TiledMap.legend_dy", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.legend_dy", "kind": "variable", "doc": "<p>y shift of legend relative to the map</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.TiledMap.use_ellipse", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.use_ellipse", "kind": "variable", "doc": "<p>if True clips legend with an ellipse</p>\n", "annotation": ": bool"}, {"fullname": "weavingspace.tile_map.TiledMap.ellipse_magnification", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.ellipse_magnification", "kind": "variable", "doc": "<p>magnification to apply to clip ellipse</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.TiledMap.radial_key", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.radial_key", "kind": "variable", "doc": "<p>if True use radial key even for ordinal/ratio data (normally these will be\nshown by concentric tile geometries)</p>\n", "annotation": ": bool"}, {"fullname": "weavingspace.tile_map.TiledMap.draft_mode", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.draft_mode", "kind": "variable", "doc": "<p>if True plot the map coloured by tile_id</p>\n", "annotation": ": bool"}, {"fullname": "weavingspace.tile_map.TiledMap.figsize", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.figsize", "kind": "variable", "doc": "<p>maptlotlib figsize</p>\n", "annotation": ": tuple[float, float]"}, {"fullname": "weavingspace.tile_map.TiledMap.dpi", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.dpi", "kind": "variable", "doc": "<p>dpi for bitmap formats</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tile_map.TiledMap.render", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.render", "kind": "function", "doc": "<p>Render the current state to a map.</p>\n\n<p>Note that TiledMap objects will usually be created by calling\n<code>Tiling.get_tiled_map()</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ids_to_map (list[str]):</strong>  tile_ids to be used in the map. Defaults to None.</li>\n<li><strong>vars_to_map (list[str]):</strong>  dataset columns to be mapped. Defaults to None.</li>\n<li><strong>colors_to_use (list[str]):</strong>  list of matplotlib colormaps to be used.\nDefaults to None.</li>\n<li><strong>categoricals (list[bool]):</strong>  list of flags indicating if associated variable\nshould be treated as categorical. Defaults to None.</li>\n<li><strong>schemes_to_use (list[str]):</strong>  list of strings indicating the mapclassify\nscheme to use e.g. 'equalinterval' or 'quantiles'. Defaults to None.</li>\n<li><strong>n_classes (list[int]):</strong>  list of ints indicating number of classes to use in\nmap classification. Defaults to None.</li>\n<li><strong>legend (bool):</strong>  If True a legend will be drawn. Defaults to True.</li>\n<li><strong>legend_zoom (float):</strong>  Zoom factor to apply to the legend. Values &lt;1\nwill show more of the tile context. Defaults to 1.0.</li>\n<li><strong>legend_dx (float):</strong>  x shift to apply to the legend position in plot area\nrelative units, i.e. 1.0 is full width of plot. Defaults to 0.0.</li>\n<li><strong>legend_dy (float):</strong>  x and y shift to apply to the legend position in plot\narea relative units, i.e. 1.0 is full height of plot. Defaults to 0.0.</li>\n<li><strong>use_ellipse (bool):</strong>  If True applies an elliptical clip to the legend.\nDefaults to False.</li>\n<li><strong>ellipse_magnification (float):</strong>  Magnification to apply to ellipse clipped\nlegend. Defaults to 1.0.</li>\n<li><strong>radial_key (bool):</strong>  If True legend key for TileUnit maps will be based on\nradially dissecting the tiles, i.e. pie slices. Defaults to False.</li>\n<li><strong>draft_mode (bool):</strong>  If True a map of the tiled map coloured by tile_ids\n(and with no legend) is returned. Defaults to False.</li>\n<li><strong>figsize (tuple[float,floar]):</strong>  plot dimensions passed to geopandas.\nplot. Defaults to (20, 15).</li>\n<li><strong>dpi (float):</strong>  passed to pyplot.plot. Defaults to 72.</li>\n<li><strong>**kwargs:</strong>  other settings to pass to pyplot/geopandas.plot.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>matplotlib.figure.Figure: figure on which map is plotted.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.to_file", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.to_file", "kind": "function", "doc": "<p>Output the tiled map to a layered GPKG file.</p>\n\n<p>Currently delegates to <code>weavingspace.tiling_utils.write_map_to_layers()</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fname (str):</strong>  Filename to write. Defaults to None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.plot_legend", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.plot_legend", "kind": "function", "doc": "<p>Plot a legend for this tiled map.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (pyplot.Axes, optional):</strong>  axes to draw legend. Defaults to None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_map.TiledMap.explore", "modulename": "weavingspace.tile_map", "qualname": "TiledMap.explore", "kind": "function", "doc": "<p>TODO: add wrapper to make tiled web map via geopandas.explore.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tile_unit", "modulename": "weavingspace.tile_unit", "kind": "module", "doc": "<p><code>TileUnit</code> subclass of <code>weavingspace.tileable.Tileable</code>.</p>\n\n<p>Implements many 'conventional' tilings of the plane.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <p>A <code>TileUnit</code> is initialised like this</p>\n  \n  <p>tile_unit = TileUnit(tiling_type = \"cairo\")</p>\n  \n  <p>The <code>tiling_type</code> may be one of the following</p>\n  \n  <ul>\n  <li>\"cairo\" the Cairo tiling more formally known as the Laves\n  [3<sup>2</sup>.4.3.4] tiling. The author's favourite tiling, hence it has its\n  own tiling_type.</li>\n  <li>\"hex-slice\" a range of dissections of the regular hexagon into, 2, 3, 4, 6,\n  or 12 'pie slices'. The number of slices is set by specifying an additional\n  argument <code>n</code>. Slices are cut either starting at the corners of  the hexagon\n  or from the midpoints of hexagon edges, by specifying an additional argument\n  <code>offset</code> set to either 0 or 1 respectively.</li>\n  <li>\"hex-dissection\" a range of 4, 7 or 9-fold dissections of the hexagon.</li>\n  <li>\"laves\" a range of isohedral tilings. See\n  <a href=\"https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings\">https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings</a>.\n  The desired tiling is specified by the additional argument <code>code</code> which is a\n  string like \"3.3.4.3.4\". Not all the possible Laves tilings are implemented.</li>\n  <li>\"archimedean\" a range of tilings by regular polygons. See\n  <a href=\"https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons\">https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons</a>.\n  Many of these are the dual tilings of the Laves tilings. The desired tiling\n  is specified by the additional argument <code>code</code> which is a string like\n  \"3.3.4.3.4\". Not all the possible Archimedean tilings are implemented.</li>\n  <li>\"hex-colouring\" or \"square-colouring\" colourings of the regular hexagonal\n  and square tilings of between 2 and 10 colours, as specified by the argument\n  <code>n</code>.</li>\n  <li>\"hex-slice\" or \"square-slice\" dissections of the regular hexagonal and\n  square tilings of between 2 and 12 colours, as specified by the arguments <code>n</code>\n  and <code>offset</code>.</li>\n  <li>\"crosses\" colourings of cross-shaped pentominoes of between</li>\n  </ul>\n  \n  <p>Spacing and coordinate reference of the tile unit are specified by the\n  <code>weavingspace.tileable.Tileable</code> superclass variables\n  <code>weavingspace.tileable.Tileable.spacing</code> and\n  <code>weavingspace.tileable.Tileable.crs</code>.</p>\n  \n  <p>Base tilings by squares, hexagons or triangles can also be requested\n  using</p>\n  \n  <p>tile_unit = TileUnit()  # square tiling, the default\n    tile_unit = TileUnit(tile_shape = TileShape.HEXAGON)\n    tile_unit = TileUnit(tile_shape = TileShape.TRIANGLE)</p>\n  \n  <p>The first two of these have only one tile_id value, and so cannot be\n  used for multivariate mapping. The triangle case has two tile_id\n  values so may be useful in its base form.</p>\n  \n  <p>To create custom tilings start from one of the base tiles above, and\n  explicitly set the <code>weavingspace.tileable.Tileable.tiles</code> variable\n  by geometric construction of suitable shapely.geometry.Polygons.\n  TODO: A detailed example of this usage can be found here ....</p>\n</blockquote>\n"}, {"fullname": "weavingspace.tile_unit.TileUnit", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit", "kind": "class", "doc": "<p>Class to represent the tiles of a 'conventional' tiling.</p>\n\n<p>Most of the functionality of TileUnit is either in <code>Tileable</code> superclass\nor, for setup, in the functions in <code>tiling_geometries</code>.</p>\n", "bases": "weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.tile_unit.TileUnit.__init__", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.__init__", "kind": "function", "doc": "<p>Delegate construction to superclass.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "weavingspace.tile_unit.TileUnit.tiling_type", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.tiling_type", "kind": "variable", "doc": "<p>tiling type as detailed in the class documentation preamble.</p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "weavingspace.tile_unit.TileUnit.offset", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.offset", "kind": "variable", "doc": "<p>offset for 'dissection' and 'slice' tilings. Defaults to 1.</p>\n", "annotation": ": float", "default_value": "1"}, {"fullname": "weavingspace.tile_unit.TileUnit.n", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.n", "kind": "variable", "doc": "<p>number of dissections or colours in 'hex-dissection', 'hex-slice' and\n'hex-colouring' tilings. Defaults to 3.</p>\n", "annotation": ": int", "default_value": "3"}, {"fullname": "weavingspace.tile_unit.TileUnit.code", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.code", "kind": "variable", "doc": "<p>the code for 'laves' or 'archimedean' tiling types.</p>\n", "annotation": ": str", "default_value": "&#x27;3.3.4.3.4&#x27;"}, {"fullname": "weavingspace.tile_unit.TileUnit.inset_prototile", "modulename": "weavingspace.tile_unit", "qualname": "TileUnit.inset_prototile", "kind": "function", "doc": "<p>Return new TileUnit clipped by negatively buffered regularised_prototile.</p>\n\n<p>Note that geopandas clip is not order preserving hence we do this one\npolygon at a time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>d (float, optional):</strong>  the inset distance. Defaults to 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>TileUnit: the new TileUnit with inset applied.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tile_unit</span><span class=\"o\">.</span><span class=\"n\">TileUnit</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable", "modulename": "weavingspace.tileable", "kind": "module", "doc": "<p>Implements Tileable and TileShape.</p>\n\n<p><code>Tileable</code> should not be called directly, but is instead accessed from the\n<code>weavingspace.tile_unit.TileUnit</code> or <code>weavingspace.weave_unit.WeaveUnit</code>\nconstructors.</p>\n\n<p>Several methods of <code>weavingspace.tileable.Tileable</code> are generally useful and\ncan be accessed through its subclasses.</p>\n"}, {"fullname": "weavingspace.tileable.TileShape", "modulename": "weavingspace.tileable", "qualname": "TileShape", "kind": "class", "doc": "<p>The available base tile shapes.</p>\n\n<p>NOTE: the TRIANGLE type does not persist, but should be converted to a\nDIAMOND or HEXAGON type during <code>Tileable</code> construction.</p>\n", "bases": "enum.Enum"}, {"fullname": "weavingspace.tileable.TileShape.RECTANGLE", "modulename": "weavingspace.tileable", "qualname": "TileShape.RECTANGLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.RECTANGLE: &#x27;rectangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.HEXAGON", "modulename": "weavingspace.tileable", "qualname": "TileShape.HEXAGON", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.HEXAGON: &#x27;hexagon&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.TRIANGLE", "modulename": "weavingspace.tileable", "qualname": "TileShape.TRIANGLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.TRIANGLE: &#x27;triangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.TileShape.DIAMOND", "modulename": "weavingspace.tileable", "qualname": "TileShape.DIAMOND", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;TileShape.DIAMOND: &#x27;diamond&#x27;&gt;"}, {"fullname": "weavingspace.tileable.Tileable", "modulename": "weavingspace.tileable", "qualname": "Tileable", "kind": "class", "doc": "<p>Class to represent a tileable set of tile geometries.</p>\n"}, {"fullname": "weavingspace.tileable.Tileable.__init__", "modulename": "weavingspace.tileable", "qualname": "Tileable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavingspace.tileable.Tileable.tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.tiles", "kind": "variable", "doc": "<p>the geometries with associated <code>title_id</code> attribute encoding their\ndifferent colouring.</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame | None", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.prototile", "modulename": "weavingspace.tileable", "qualname": "Tileable.prototile", "kind": "variable", "doc": "<p>the tileable polygon (rectangle, hexagon or diamond)</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame | None", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.spacing", "modulename": "weavingspace.tileable", "qualname": "Tileable.spacing", "kind": "variable", "doc": "<p>the tile spacing effectively the resolution of the tiling. Defaults to\n1000</p>\n", "annotation": ": float", "default_value": "1000.0"}, {"fullname": "weavingspace.tileable.Tileable.base_shape", "modulename": "weavingspace.tileable", "qualname": "Tileable.base_shape", "kind": "variable", "doc": "<p>the tile shape. Defaults to 'RECTANGLE'</p>\n", "annotation": ": weavingspace.tileable.TileShape", "default_value": "&lt;TileShape.RECTANGLE: &#x27;rectangle&#x27;&gt;"}, {"fullname": "weavingspace.tileable.Tileable.vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.vectors", "kind": "variable", "doc": "<p>translation vector symmetries of the tiling</p>\n", "annotation": ": dict[tuple[int, ...], tuple[float, ...]] | None", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.regularised_prototile", "modulename": "weavingspace.tileable", "qualname": "Tileable.regularised_prototile", "kind": "variable", "doc": "<p>polygon containing the tiles of this tileable, usually a union of its\ntile polygons</p>\n", "annotation": ": geopandas.geodataframe.GeoDataFrame | None", "default_value": "None"}, {"fullname": "weavingspace.tileable.Tileable.crs", "modulename": "weavingspace.tileable", "qualname": "Tileable.crs", "kind": "variable", "doc": "<p>coordinate reference system of the tile. Most often an ESPG code but\nany valid geopandas CRS specification is valid. Defaults to 3857 (i.e. Web\nMercator).</p>\n", "annotation": ": int", "default_value": "3857"}, {"fullname": "weavingspace.tileable.Tileable.rotation", "modulename": "weavingspace.tileable", "qualname": "Tileable.rotation", "kind": "variable", "doc": "<p>cumulative rotation of the tileable.</p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "weavingspace.tileable.Tileable.debug", "modulename": "weavingspace.tileable", "qualname": "Tileable.debug", "kind": "variable", "doc": "<p>if True prints debug messages. Defaults to False.</p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "weavingspace.tileable.Tileable.setup_vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.setup_vectors", "kind": "function", "doc": "<p>Set up translation vectors of a Tileable.</p>\n\n<p>Initialised from either two or three supplied tuples. Two non-parallel\nvectors are sufficient for a tiling to work, but usually three will be\nsupplied for tiles with a hexagonal base tile. We also store the reverse\nvectors - this is for convenience when finding a 'local patch'. This method\nis preferred during Tileable initialisation.</p>\n\n<p>The vectors are stored in a dictionary indexed by their\ncoordinates, e.g.</p>\n\n<p>{( 1,  0): ( 100, 0), ( 0,  1): (0,  100),\n   (-1,  0): (-100, 0), ( 0, -1): (0, -100)}</p>\n\n<p>For a tileable of type <code>TileShape.HEXAGON</code>, the indexing tuples\nhave three components. See <a href=\"https://www.redblobgames.com/grids/hexagons/\">https://www.redblobgames.com/grids/hexagons/</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.get_vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.get_vectors", "kind": "function", "doc": "<p>Return symmetry translation vectors as floating point pairs.</p>\n\n<p>Optionally returns the vectors in a dictionary indexed by offsets in grid\ncoordinates, e.g.</p>\n\n<p>{( 1,  0): ( 100, 0), ( 0,  1): (0,  100),\n   (-1,  0): (-100, 0), ( 0, -1): (0, -100)}</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[tuple[int],tuple[float]]|list[tuple[float]]: either the vectors as a\n    list of float tuples, or a dictionary of those vectors indexed by\n    integer coordinate tuples.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">as_dict</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.get_prototile_from_vectors", "modulename": "weavingspace.tileable", "qualname": "Tileable.get_prototile_from_vectors", "kind": "function", "doc": "<p>Contruct and returns a prototile unit based on vectors of the Tileable.</p>\n\n<p>For rectangular tilings the prototile is formed by points\nat diagonal corners defined by the halved vectors. By inspection, each edge\nof the prototile is the resultant of adding two of the four vectors.</p>\n\n<hr />\n\n<p>|\\  /|\n | \\/ |\n | /\\ |\n |/  \\|</p>\n\n<hr />\n\n<p>In the hexagonal case we form three such quadrilaterals (but don't halve the\nvectors, because we need the extended length) and intersect them to find a\nhexagonal shape. This guarantees that each vector will connect two opposite\nfaces of the hexagon, as desired. This seems the most elegant approach by\ngeometric construction.</p>\n\n<p>The prototile is not uniquely defined. The shape returned by this method is\nnot guaranteed to be the most 'obvious' one that a human might construct!</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoDataFrame: A suitable prototile shape for the tiling wrapped in a\n    GeoDataFrame.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.get_local_patch", "modulename": "weavingspace.tileable", "qualname": "Tileable.get_local_patch", "kind": "function", "doc": "<p>Return a GeoDataFrame with translated copies of the Tileable.</p>\n\n<p>The geodataframe takes the same form as the <code>Tileable.tile</code> attribute.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>r (int, optional):</strong>  the number of 'layers' out from the unit to\nwhich the translate copies will extendt. Defaults to <code>1</code>.</li>\n<li><strong>include_0 (bool, optional):</strong>  If True includes the Tileable itself at\n(0, 0). Defaults to <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoDataFrame: A GeoDataframe of the tiles extended by a number\n    of 'layers'.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">include_0</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.inset_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.inset_tiles", "kind": "function", "doc": "<p>Return a new Tileable with an inset applied around the tiles.</p>\n\n<p>Works by applying a negative buffer of specfied size to all tiles.\nTiles that collapse to zero area are removed and the tile_id\nattribute updated accordingly.</p>\n\n<p>NOTE: this method is likely to not preserve the relative area of tiles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>inset (float, optional):</strong>  The distance to inset. Defaults to <code>0</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>\"Tileable\": the new inset Tileable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">inset</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.scale_tiles", "modulename": "weavingspace.tileable", "qualname": "Tileable.scale_tiles", "kind": "function", "doc": "<p>Scales the tiles by the specified factor, centred on (0, 0).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sf (float, optional):</strong>  scale factor to apply. Defaults to 1.</li>\n<li><strong>individually (bool, optional):</strong>  if True scaling is applied to each tiling\nelement centred on its centre, rather than with respect to the Tileable.\nDefaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>TileUnit: the scaled TileUnit.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sf</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">individually</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_scale", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_scale", "kind": "function", "doc": "<p>Transform tileable by scaling.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>xscale (float, optional):</strong>  x scale factor. Defaults to 1.0.</li>\n<li><strong>yscale (float, optional):</strong>  y scale factor. Defaults to 1.0.</li>\n<li><strong>independent_of_tiling (bool, optional):</strong>  if True Tileable is scaled while\nleaving the translation vectors untouched, so that it can change size\nindependent from its spacing when tiled. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tileable: the transformed Tileable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xscale</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">yscale</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">independent_of_tiling</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_rotate", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_rotate", "kind": "function", "doc": "<p>Transform tiling by rotation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle (float, optional):</strong>  angle to rotate by. Defaults to 0.0.</li>\n<li><strong>independent_of_tiling (bool, optional):</strong>  if True Tileable is rotated while\nleaving the translation vectors untouched, so that it can change\norientation independent from its position when tiled. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tileable: the transformed Tileable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">independent_of_tiling</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.transform_skew", "modulename": "weavingspace.tileable", "qualname": "Tileable.transform_skew", "kind": "function", "doc": "<p>Transform tiling by skewing.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>xa (float, optional):</strong>  x direction skew. Defaults to 0.0.</li>\n<li><strong>ya (float, optional):</strong>  y direction skew. Defaults to 0.0.</li>\n<li><strong>independent_of_tiling (bool, optional):</strong>  if True Tileable is skewed while\nleaving the translation vectors untouched, so that it can change shape\nindependent from its situation when tiled. Defaults to False.</li>\n<li><strong>rescale (bool, optional):</strong>  if True rescales the result so that overall\nsize and extent is more or less unaffected by the skew, otherwise the\nsimultaneous application of both x and y shears may dramatically alter\nthe size of tiling. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tileable: the transformed Tileable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xa</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">ya</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">independent_of_tiling</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">rescale</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tileable.Tileable.plot", "modulename": "weavingspace.tileable", "qualname": "Tileable.plot", "kind": "function", "doc": "<p>Plot Tileable on the supplied axis.</p>\n\n<p>**kwargs are passed on to matplotlib.plot()</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ax (_type_, optional):</strong>  matplotlib axis to draw to. Defaults to None.</li>\n<li><strong>show_prototile (bool, optional):</strong>  if <code>True</code> show the tile outline.\nDefaults to <code>True</code>.</li>\n<li><strong>show_reg_prototile (bool, optional):</strong>  if <code>True</code> show the regularised tile\noutline. Defaults to <code>True</code>.</li>\n<li><strong>show_ids (str, optional):</strong>  if <code>tile_id</code> show the tile_ids. If\n<code>id</code> show index number. If None or <code>''</code> don't label tiles.\nDefaults to <code>tile_id</code>.</li>\n<li><strong>show_vectors (bool, optional):</strong>  if <code>True</code> show the translation\nvectors (not the minimal pair, but those used by\n<code>get_local_patch()</code>). Defaults to <code>False</code>.</li>\n<li><strong>r (int, optional):</strong>  passed to <code>get_local_patch()</code> to show context if\ngreater than 0. Defaults to <code>0</code>.</li>\n<li><strong>r_alpha (float, optional):</strong>  alpha setting for units other than the\ncentral one. Defaults to 0.5.</li>\n<li><strong>prototile_edgecolour (str, optional):</strong>  outline colour for the tile.\nDefaults to <code>\"k\"</code>.</li>\n<li><strong>reg_prototile_edgecolour (str, optional):</strong>  outline colour for the\nregularised. Defaults to <code>\"r\"</code>.</li>\n<li><strong>vector_edgecolour (str, optional):</strong>  colour for the translation vectors.\nDefaults to <code>\"k\"</code>.</li>\n<li><strong>cmap (list[str], optional):</strong>  colour map to apply to the central\ntiles. Defaults to <code>None</code>.</li>\n<li><strong>figsize (tuple[float], optional):</strong>  size of the figure.\nDefaults to <code>(8, 8)</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pyplot.axes: to which calling context may add things.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_prototile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_reg_prototile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_ids</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;tile_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show_vectors</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">prototile_edgecolour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;k&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">reg_prototile_edgecolour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;r&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vector_edgecolour</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;k&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">r_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils", "modulename": "weavingspace.tiling_utils", "kind": "module", "doc": "<p>Utility functions for the <code>weavingspace</code> module.</p>\n\n<p>Most are geometric convenience functions for commonly applied\noperations.</p>\n"}, {"fullname": "weavingspace.tiling_utils.PRECISION", "modulename": "weavingspace.tiling_utils", "qualname": "PRECISION", "kind": "variable", "doc": "<p></p>\n", "default_value": "6"}, {"fullname": "weavingspace.tiling_utils.RESOLUTION", "modulename": "weavingspace.tiling_utils", "qualname": "RESOLUTION", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-06"}, {"fullname": "weavingspace.tiling_utils.get_strand_ids", "modulename": "weavingspace.tiling_utils", "qualname": "get_strand_ids", "kind": "function", "doc": "<p>Convert strands specification string to list of lists of strand labels.</p>\n\n<p>String format is \"a|bc|(de)f\" where | separates strands in each\ndirection and () designates combining labels into a single strand that\nwill be sliced lengthwise. Example output:</p>\n\n<pre><code>  \"a|bc|(de)f\" -&gt; ([\"a\"], [\"b\", \"c\"], [\"de\", \"f\"])\n</code></pre>\n\n<p>Superflous parentheses are removed, but no other error-checks are\napplied.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>strands_spec (str):</strong>  the strands specification to be parsed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[str]: tuple of lists of labels for each set of strands.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">strands_spec</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_regular_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_regular_polygon", "kind": "function", "doc": "<p>Return regular n-gon centered on (0, 0) with height specified.</p>\n\n<p>n-gon has horizontal base and height given by spacing. Generation is based on\nequally spaced points around a circle with a radius calculated slightly\ndifferently, depending on whether the number of sides is even or odd.</p>\n\n<pre><code>      Even         Odd\n  \\  /    \\  /      |\n   \\/   ___\\/___    |\n   /\\      /\\      / \\\n  /  \\    /  \\    /   \\\n</code></pre>\n\n<p>The returned polygon is gridified. Note also that shapely silently reorders\nthe coordinates clockwise from the lower left corner, regardless of the CCW\norder in which we supply them.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spacing (_type_):</strong>  required height.</li>\n<li><strong>n (int):</strong>  number of sides.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: required geom.Polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacing</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_corners", "modulename": "weavingspace.tiling_utils", "qualname": "get_corners", "kind": "function", "doc": "<p>Return list of geom.Points on boundary of a polygon.</p>\n\n<p>The first point is optionally repeated. No simplification is carried out\n(e.g. if a line segment has a 'corner' along its length, it is NOT removed;\nsee get_clean_polygon for that). Points have precision set to the\npackagedefault tiling_utils.RESOLUTION.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon whose corners are required.</li>\n<li><strong>repeat_first (bool, optional):</strong>  if True the first corner is repeated in the\nreturned list, if False it is omitted. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[geom.Point]: list of geom.Point vertices of the polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">repeat_first</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_sides", "modulename": "weavingspace.tiling_utils", "qualname": "get_sides", "kind": "function", "doc": "<p>Return polygon sides as list of geom.LineStrings.</p>\n\n<p>Resolution is set to the package default tiling_utils.RESOLUTION. No\nsimplification for successive colinear sides is carried out.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon whose edges are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[geom.LineString]: list of geom.LineString sides of the polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_side_lengths", "modulename": "weavingspace.tiling_utils", "qualname": "get_side_lengths", "kind": "function", "doc": "<p>Return list of lengths of polygon sides.</p>\n\n<p>No simplification for corners along sides is carried out.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon whose edge lengths are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: list of side lengths.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_side_bearings", "modulename": "weavingspace.tiling_utils", "qualname": "get_side_bearings", "kind": "function", "doc": "<p>Return list of angles between sides of polygon and the positive x-axis.</p>\n\n<p>Angle is in degrees and calculated when proceeding from the first point in\neach side to its end point. This should usually be CW around the polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon whose side bearings are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[float,...]: tuple of bearings of each edge.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_interior_angles", "modulename": "weavingspace.tiling_utils", "qualname": "get_interior_angles", "kind": "function", "doc": "<p>Return angles (in degrees) between successive edges of a polygon.</p>\n\n<p>No polygon simplification is carried out so some angles may be 180 (i.e. a\n'corner' along a side, such that successive sides are colinear).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon whose angles are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: list of angles.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_clean_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_clean_polygon", "kind": "function", "doc": "<p>Return polygon with successive co-linear or very close corners removed.</p>\n\n<p>Particularly useful for tidying polygons weave tilings that have been\nassembled from multiple 'cells' in the weave grid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.MultiPolygon|geom.Polygon):</strong>  polygon to clean.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: cleaned polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">multipolygon</span><span class=\"o\">.</span><span class=\"n\">MultiPolygon</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">multipolygon</span><span class=\"o\">.</span><span class=\"n\">MultiPolygon</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.rotate_preserving_order", "modulename": "weavingspace.tiling_utils", "qualname": "rotate_preserving_order", "kind": "function", "doc": "<p>Return supplied polygon rotated with order of corners preserved.</p>\n\n<p>Order of polygon corners is not guaranteed to be preserved by shapely.\naffinity.rotate).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>polygon (geom.Polygon):</strong>  polygon to rotate.</li>\n<li><strong>angle (float):</strong>  desired angle of rotation (in degrees).</li>\n<li><strong>centre (geom.Point):</strong>  the rotation centre (passed on to shapely.affinity.\nrotate).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: rotated polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.ensure_cw", "modulename": "weavingspace.tiling_utils", "qualname": "ensure_cw", "kind": "function", "doc": "<p>Return the polygon with its outer boundary vertices in clockwise order.</p>\n\n<p>It is important to note that shapely.set_precision() imposes clockwise order\non polygons, and since it is used widely throughout theses modules, it makes\nsense to impose this order.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  the polygon.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: the polygon in clockwise order.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_inner_angle", "modulename": "weavingspace.tiling_utils", "qualname": "get_inner_angle", "kind": "function", "doc": "<p>Return angle between line p1-p2 and p2-p3, i.e., the angle A below.</p>\n\n<pre><code>      p2\n     / \\\n    / A \\\n  p1     p3\n</code></pre>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p1 (geom.Point):</strong>  first point.</li>\n<li><strong>p2 (geom.Point):</strong>  second 'corner' point.</li>\n<li><strong>p3 (geom.Point):</strong>  third point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: angle in degrees.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p3</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.is_regular_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "is_regular_polygon", "kind": "function", "doc": "<p>Test if supplied polygon is regular (i.e. equal sides and angles).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon to test.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if polygon is regular, False if not.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.is_tangential", "modulename": "weavingspace.tiling_utils", "qualname": "is_tangential", "kind": "function", "doc": "<p>Determine if supplied polygon is tangential.</p>\n\n<p>A tangential polygon can have a circle inscribed tangential to all its sides.</p>\n\n<p>NOTE: not currently used but retained in case incentre is restored to use\n'home made' code rather than polylabel.polylabel.</p>\n\n<p>Note that this will fail for polygons with successive colinear sides, meaning\nthat polygons should be fully simplified...</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  polygon to test.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if polygon is tangential, False if not.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_incentre", "modulename": "weavingspace.tiling_utils", "qualname": "get_incentre", "kind": "function", "doc": "<p>Get a polygon incentre.</p>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Incenter\">https://en.wikipedia.org/wiki/Incenter</a>.</p>\n\n<p>This method relies on the polygon being tangential, i.e. there is an\ninscribed circle to which all sides of the polygon are tangent. It will work\non all the polygons encountered in the Laves tilings, but is not guaranteed\nto work on all polygons.</p>\n\n<p>Given that the polygon is tangential, the radius of the inscribed circle is\nthe <a href=\"https://en.wikipedia.org/wiki/Apothem\">apothem of the polygon</a> given by\n2 x Area / Perimeter. We apply a parallel offset of this size to two sides of\nthe polygon and find their intersection to determine the centre of the circle\ngivng the incentre of the polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  the polygon.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Point: the incentre of the polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_incircle", "modulename": "weavingspace.tiling_utils", "qualname": "get_incircle", "kind": "function", "doc": "<p>Return incircle of supplied polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape(geom.Polygon):</strong>  polygon for which incircle is required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: a polygon representation of the incircle</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_apothem", "modulename": "weavingspace.tiling_utils", "qualname": "get_apothem", "kind": "function", "doc": "<p>Return length of the apothem of supplied polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape(geom.Polygon):</strong>  polygon for which apothem length is required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: an estimate of the apothem length.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_angle_bisector", "modulename": "weavingspace.tiling_utils", "qualname": "get_angle_bisector", "kind": "function", "doc": "<p>Return angle bisector of specified corner of supplied polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  the polygon</li>\n<li><strong>v (int, optional):</strong>  index of the corner whose bisector is required.</li>\n<li>Defaults to 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.LineString: line which bisects the specified corner.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.gridify", "modulename": "weavingspace.tiling_utils", "qualname": "gridify", "kind": "function", "doc": "<p>Return supplied GeoSeries rounded to tiling_utils.RESOLUTION.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gs (gpd.GeoSeries):</strong>  geometries to gridify.</li>\n<li><strong>precision (int, optional):</strong>  digits of precision. Defaults to 6.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoSeries: the rounded geometries.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">Geometry</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">Geometry</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_dual_tile_unit", "modulename": "weavingspace.tiling_utils", "qualname": "get_dual_tile_unit", "kind": "function", "doc": "<p>Convert supplied TileUnit to candidate GeoDataFrame of its dual TileUnit.</p>\n\n<p>NOTE: this is complicated and not remotely guaranteed to work!\na particular issue is that where to place the vertices of the faces\nof the dual with respect to the tiles in the original is ill-defined.\nThis is because the dual process is topologically not metrically defined,\nso that exact vertex locations are ambiguous. Tiling duality is defined in\nSection 4.2 of Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H.\nFreeman and Company, New York)</p>\n\n<p>NOTE: In general, this method will work only if all supplied tiles are\nregular polygons. A known exception is if the only non-regular polygons are\ntriangles.</p>\n\n<p>NOTE: 'clean' polygons are required. If supplied polygons have messy\nvertices with multiple points where there is only one proper point, bad\nthings are likely to happen! Consider using <code>clean_polygon()</code> on the\ntile geometries.</p>\n\n<p>Because of the above limitations, we only return a GeoDataFrame\nfor inspection. However some <code>weavingspace.tile_unit.TileUnit</code> setup\nmethods in <code>weavingspace.tiling_geometries</code> use this method, where we are\nconfident the returned dual is valid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unit (TileUnit):</strong>  the tiling for which the dual is required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoDataFrame: GeoDataFrame that could be the tiles attribute for\n    a TileUnit of the dual tiling.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.write_map_to_layers", "modulename": "weavingspace.tiling_utils", "qualname": "write_map_to_layers", "kind": "function", "doc": "<p>Write supplied GeoDataFrame to a GPKG file.</p>\n\n<p>Geopackage file layers will be based on the <code>tile_var</code> attribute.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gdf (gpd.GeoDataFrame):</strong>  the GeoDataFrame.</li>\n<li><strong>fname (str, optional):</strong>  filename to write.</li>\n<li><strong>tile_var (str, optional):</strong>  the attribute to use to separate\noutput file into layers. Defaults to \"tile_id\".</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gdf</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;output.gpkg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tile_var</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;tile_id&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_collapse_distance", "modulename": "weavingspace.tiling_utils", "qualname": "get_collapse_distance", "kind": "function", "doc": "<p>Return distance under which polygon will disappear if negatively buffered.</p>\n\n<p>Performs a binary search between an upper bound based on the radius of circle\nof equal area to the polygon, and 0.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>geometry (geom.Polygon):</strong>  the polygon.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: its collapse distance.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_largest_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "get_largest_polygon", "kind": "function", "doc": "<p>Return largest polygon in a GeoSeries as a GeoSeries of one polygon.</p>\n\n<p>NOT CURRENTLY USED ANYWHERE IN MODULE.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>polygons (gpd.GeoSeries):</strong>  the set of polygons to pick from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoSeries: the largest polygon.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.touch_along_an_edge", "modulename": "weavingspace.tiling_utils", "qualname": "touch_along_an_edge", "kind": "function", "doc": "<p>Test if two polygons touch along an edge.</p>\n\n<p>Checks that the intersection area of the two polygons buffered by\na small amount is large enough to indicate that they neighbour at more\nthan a corner.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p1 (geom.Polygon):</strong>  First polygon</li>\n<li><strong>p2 (geom.Polygon):</strong>  Second polygon</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if they neighbour along an edge</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_width_height_left_bottom", "modulename": "weavingspace.tiling_utils", "qualname": "get_width_height_left_bottom", "kind": "function", "doc": "<p>Return width, height, left and bottom limits of a GeoSeries.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gs (geopandas.GeoSeries):</strong>  GeoSeries for which limits are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: four float values of width, height, left and bottom of gs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_bounding_ellipse", "modulename": "weavingspace.tiling_utils", "qualname": "get_bounding_ellipse", "kind": "function", "doc": "<p>Return an ellipse containing the supplied shapes.</p>\n\n<p>The method used is to calculate the size of square that would contain\nthe shapes, if they had an aspect ratio 1, then stretch the circle in\nthe x, y directions according to the actual aspect ratio of the shapes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes (gpd.GeoSeries):</strong>  the shapes to be contained.</li>\n<li><strong>mag (float, optional):</strong>  optionally increase the size of the returned\nellipse by this scale factor. Defaults to 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoSeries: the set of shapes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>,</span><span class=\"param\">\t<span class=\"n\">mag</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_tiling_edges", "modulename": "weavingspace.tiling_utils", "qualname": "get_tiling_edges", "kind": "function", "doc": "<p>Return linestring GeoSeries from supplied polygon GeoSeries.</p>\n\n<p>This is used to allow display of edges of tiles in legend when they are\nmasked by an ellipse (if we instead clip polygons then the ellipse edge\nwill also show in the result.)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tiles (gpd.GeoSeries):</strong>  Polygons to convert.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoSeries: LineStrings from the supplied Polygons.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_polygon_sector", "modulename": "weavingspace.tiling_utils", "qualname": "get_polygon_sector", "kind": "function", "doc": "<p>Return a sector of the provided Polygon.</p>\n\n<p>The returned sector is a section of the polygon boundary between the\nnormalized start and end positions, and including the polygon centroid.\nShould (probably) only be applied to convex polygons.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape (geom.Polygon):</strong>  the Polygon.</li>\n<li><strong>start (float):</strong>  normalized start position along the boundary. Defaults to\n0.</li>\n<li><strong>end (float):</strong>  normalized start position along the boundary. Defaults to\n1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon: the requested polygon sector.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.repair_polygon", "modulename": "weavingspace.tiling_utils", "qualname": "repair_polygon", "kind": "function", "doc": "<p>Repair a polyon or GeoSeries by double buffering.</p>\n\n<p>This is method is often unofficially recommended (on stackexchange etc.)\neven in the shapely docs, to resolve topology issues and extraneous\nadditional vertices appearing when spatial operations are repeatedly\napplied.</p>\n\n<p>Optionally the buffer may be applied in the opposite order (i.e. grow then\nshrink). This operation may also convert a MultiPolygon that has some 'stray'\nparts to a Polygon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>polygon(geom.Polygon|gpd.GeoSeries):</strong>  Polygon or GeoSeries to clean.</li>\n<li><strong>res (float, optional):</strong>  buffer size to use. Defaults to 1e-3.</li>\n<li><strong>shrink_then_grow (bool, optional):</strong>  if True the negative buffer is\napplied first, otherwise the buffer operations are applied in\nreverse. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Polygon|gpd.GeoSeries: the cleaned Polygon or GeoSeries.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">multipolygon</span><span class=\"o\">.</span><span class=\"n\">MultiPolygon</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>,</span><span class=\"param\">\t<span class=\"n\">shrink_then_grow</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span> <span class=\"o\">|</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.safe_union", "modulename": "weavingspace.tiling_utils", "qualname": "safe_union", "kind": "function", "doc": "<p>Union supplied GeoSeries buffering to avoid gaps and internal edges.</p>\n\n<p>Optionally returns a Polygon or a GeoSeries.</p>\n\n<p>NOTE: APPEARS NOT TO BE VERY SAFE... find workarounds for the few occasions\non which it is used.</p>\n\n<p>Frequently when unioning polygons that are ostensibly adjacent 'rogue'\ninternal boundaries remain in the result. We can avoid this by buffering the\npolygons before unioning them, then reversing the buffer on the unioned\nshape.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gs (gpd.GeoSeries):</strong>  the Polygons to union.</li>\n<li><strong>res (float, optional):</strong>  size of the buffer to use. Defaults to 1e-3.</li>\n<li><strong>as_polygon (bool, optional):</strong>  if True returns a Polygon, otherwise\nreturns a one Polygon GeoSeries. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gpd.GeoSeries|geom.Polygon: the resulting union of supplied\n    polygons.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gs</span><span class=\"p\">:</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span>,</span><span class=\"param\">\t<span class=\"n\">as_polygon</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geoseries</span><span class=\"o\">.</span><span class=\"n\">GeoSeries</span> <span class=\"o\">|</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_translation_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_translation_transform", "kind": "function", "doc": "<p>Return shapely affine transform tuple for a translation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dx (float):</strong>  translation distance in x direction.</li>\n<li><strong>dy (float):</strong>  translation distance in y direction.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: a six item list of floats, per the shapely.affinity.\n  affine_transform method, see\n    <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_rotation_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_rotation_transform", "kind": "function", "doc": "<p>Return the shapely affine transform tuple for a rotation.</p>\n\n<p>Rotation is optionally about a supplied centre point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle (float):</strong>  the angle of rotation (in degrees).</li>\n<li><strong>centre (tuple[float], optional):</strong>  An option centre location. Defaults to</li>\n<li>None, which will in turn be converted to (0, 0).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: a six item list of floats, per the shapely.affinity.\n    affine_transform method, see\n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_reflection_transform", "modulename": "weavingspace.tiling_utils", "qualname": "get_reflection_transform", "kind": "function", "doc": "<p>Return a shapely affine reflection transform.</p>\n\n<p>Reflection is in a line at the specified angle, optionally through a\nspecified centre point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle (float):</strong>  angle to the x-axis of the line of reflection.</li>\n<li><strong>centre (tuple[float], optional):</strong>  point through which the line of\nreflection passes. Defaults to None, which\nwill in turn be converted to (0, 0).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: a six item list of floats, per the shapely.affinity.\n    affine_transform method, see\n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.combine_transforms", "modulename": "weavingspace.tiling_utils", "qualname": "combine_transforms", "kind": "function", "doc": "<p>Return shapely affine transform that combines supplied list of transforms.</p>\n\n<p>Transforms are applied in the order of the supplied list</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transforms (list[list[float]]):</strong>  sequence of transforms to combine.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: a transform tuple combining the supplied transforms applied\n    in order, see\n      <a href=\"https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations\">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transforms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.reverse_transform", "modulename": "weavingspace.tiling_utils", "qualname": "reverse_transform", "kind": "function", "doc": "<p>Return inverse shapely affine transform of the supplied transform.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transform (list[float]):</strong>  the transform for which the inverse is desired.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: shapely affine transform tuple that will invert the supplied\n    transform.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.as_shapely_transform", "modulename": "weavingspace.tiling_utils", "qualname": "as_shapely_transform", "kind": "function", "doc": "<p>Return shapely affine transform equivalent to supplied numpy matrix.</p>\n\n<p>The numpy matrix is a conventional augmented (i.e. 3x3) affine transform\nmatrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  augmented affine transform matrix of the desired\ntransform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[float]: desired shapely affine transform list of floats.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.as_numpy_matrix", "modulename": "weavingspace.tiling_utils", "qualname": "as_numpy_matrix", "kind": "function", "doc": "<p>Convert shapely affine transform to augmented affine transform matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transform (list[float]):</strong>  the transform in shapely format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: the transform in numpy matrix format.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.StraightLine", "modulename": "weavingspace.tiling_utils", "qualname": "StraightLine", "kind": "class", "doc": "<p>Straight line in canonical Ax+By+C=0 form.</p>\n", "bases": "typing.NamedTuple"}, {"fullname": "weavingspace.tiling_utils.StraightLine.__init__", "modulename": "weavingspace.tiling_utils", "qualname": "StraightLine.__init__", "kind": "function", "doc": "<p>Create new instance of StraightLine(A, B, C)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">C</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "weavingspace.tiling_utils.StraightLine.A", "modulename": "weavingspace.tiling_utils", "qualname": "StraightLine.A", "kind": "variable", "doc": "<p>Alias for field number 0</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tiling_utils.StraightLine.B", "modulename": "weavingspace.tiling_utils", "qualname": "StraightLine.B", "kind": "variable", "doc": "<p>Alias for field number 1</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tiling_utils.StraightLine.C", "modulename": "weavingspace.tiling_utils", "qualname": "StraightLine.C", "kind": "variable", "doc": "<p>Alias for field number 2</p>\n", "annotation": ": float"}, {"fullname": "weavingspace.tiling_utils.get_straight_line", "modulename": "weavingspace.tiling_utils", "qualname": "get_straight_line", "kind": "function", "doc": "<p>Return StraightLine p1-p2, optionally perpendicular through the midpoint.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p1 (geom.Point):</strong>  First point.</li>\n<li><strong>p2 (geom.Point):</strong>  Second point</li>\n<li><strong>perpendicular (bool, optional):</strong>  If True the perpendicular bisector is\nreturned. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>StraightLine: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">perpendicular</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tiling_utils</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.tiling_utils.get_intersection", "modulename": "weavingspace.tiling_utils", "qualname": "get_intersection", "kind": "function", "doc": "<p>Return point of intersection of straight lines.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>line1 (StraightLine):</strong>  First straight line.</li>\n<li><strong>line2 (StraightLine):</strong>  Second straight line.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.Point|None: Point is returned if the lines intersect, otherwise None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">line1</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tiling_utils</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span>,</span><span class=\"param\">\t<span class=\"n\">line2</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tiling_utils</span><span class=\"o\">.</span><span class=\"n\">StraightLine</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology", "modulename": "weavingspace.topology", "kind": "module", "doc": "<p>Classes for working with topology of tilings.</p>\n\n<p>Together the <code>Topology</code>, <code>Tile</code>, <code>Vertex</code>, <code>Edge</code>, and\n<code>weavingspace.symmetry.Symmetries</code> classes enable extraction of the topological\nstructure of periodic <code>weavingspace.tileable.Tileable</code> objects so that\nmodification of equivalent tiles can be carried out while retaining\ntileability.</p>\n\n<p>It is important to note that these are not fully generalised classes and\nmethods, that is, the Topology object that is supported is not a permanent\n'backing' data structure for our Tileable objects. While it might become that\nin time, it is not yet such a data structure. Instead usage is</p>\n\n<pre><code>tile = TileUnit(...)\ntopology = Topology(tile)\ntopology = topology.transform_*(...)\nnew_tile = topology.tile_unit\n</code></pre>\n\n<p>A Topology plot function is provided for a user to be able to see what they are\ndoing, because how edges and vertices in a tiling are labelled under tile\nequivalences is an essential step in the process.</p>\n\n<p>Note that these classes do not precisely represent the distinctions made in the\nmathematical literature between tiling vertices and tile corners, or between\ntiling edges and tile sides.</p>\n"}, {"fullname": "weavingspace.topology.LABELS", "modulename": "weavingspace.topology", "qualname": "LABELS", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;AB&#x27;, &#x27;AC&#x27;, &#x27;AD&#x27;, &#x27;AE&#x27;, &#x27;AF&#x27;, &#x27;AG&#x27;, &#x27;AH&#x27;, &#x27;AI&#x27;, &#x27;AJ&#x27;, &#x27;AK&#x27;, &#x27;AL&#x27;, &#x27;AM&#x27;, &#x27;AN&#x27;, &#x27;AO&#x27;, &#x27;AP&#x27;, &#x27;AQ&#x27;, &#x27;AR&#x27;, &#x27;AS&#x27;, &#x27;AT&#x27;, &#x27;AU&#x27;, &#x27;AV&#x27;, &#x27;AW&#x27;, &#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;AA&#x27;, &#x27;AB&#x27;, &#x27;AC&#x27;, &#x27;AD&#x27;, &#x27;AE&#x27;, &#x27;AF&#x27;, &#x27;AG&#x27;, &#x27;AH&#x27;, &#x27;AI&#x27;, &#x27;AJ&#x27;, &#x27;AK&#x27;, &#x27;AL&#x27;, &#x27;AM&#x27;, &#x27;AN&#x27;, &#x27;AO&#x27;, &#x27;AP&#x27;, &#x27;AQ&#x27;, &#x27;AR&#x27;, &#x27;AS&#x27;, &#x27;AT&#x27;, &#x27;AU&#x27;, &#x27;AV&#x27;, &#x27;AW&#x27;, &#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BC&#x27;, &#x27;BD&#x27;, &#x27;BE&#x27;, &#x27;BF&#x27;, &#x27;BG&#x27;, &#x27;BH&#x27;, &#x27;BI&#x27;, &#x27;BJ&#x27;, &#x27;BK&#x27;, &#x27;BL&#x27;, &#x27;BM&#x27;, &#x27;BN&#x27;, &#x27;BO&#x27;, &#x27;BP&#x27;, &#x27;BQ&#x27;, &#x27;BR&#x27;, &#x27;BS&#x27;, &#x27;BT&#x27;, &#x27;BU&#x27;, &#x27;BV&#x27;, &#x27;BW&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;BA&#x27;, &#x27;BB&#x27;, &#x27;BC&#x27;, &#x27;BD&#x27;, &#x27;BE&#x27;, &#x27;BF&#x27;, &#x27;BG&#x27;, &#x27;BH&#x27;, &#x27;BI&#x27;, &#x27;BJ&#x27;, &#x27;BK&#x27;, &#x27;BL&#x27;, &#x27;BM&#x27;, &#x27;BN&#x27;, &#x27;BO&#x27;, &#x27;BP&#x27;, &#x27;BQ&#x27;, &#x27;BR&#x27;, &#x27;BS&#x27;, &#x27;BT&#x27;, &#x27;BU&#x27;, &#x27;BV&#x27;, &#x27;BW&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CD&#x27;, &#x27;CE&#x27;, &#x27;CF&#x27;, &#x27;CG&#x27;, &#x27;CH&#x27;, &#x27;CI&#x27;, &#x27;CJ&#x27;, &#x27;CK&#x27;, &#x27;CL&#x27;, &#x27;CM&#x27;, &#x27;CN&#x27;, &#x27;CO&#x27;, &#x27;CP&#x27;, &#x27;CQ&#x27;, &#x27;CR&#x27;, &#x27;CS&#x27;, &#x27;CT&#x27;, &#x27;CU&#x27;, &#x27;CV&#x27;, &#x27;CW&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;, &#x27;CA&#x27;, &#x27;CB&#x27;, &#x27;CC&#x27;, &#x27;CD&#x27;, &#x27;CE&#x27;, &#x27;CF&#x27;, &#x27;CG&#x27;, &#x27;CH&#x27;, &#x27;CI&#x27;, &#x27;CJ&#x27;, &#x27;CK&#x27;, &#x27;CL&#x27;, &#x27;CM&#x27;, &#x27;CN&#x27;, &#x27;CO&#x27;, &#x27;CP&#x27;, &#x27;CQ&#x27;, &#x27;CR&#x27;, &#x27;CS&#x27;, &#x27;CT&#x27;, &#x27;CU&#x27;, &#x27;CV&#x27;, &#x27;CW&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;, &#x27;DE&#x27;, &#x27;DF&#x27;, &#x27;DG&#x27;, &#x27;DH&#x27;, &#x27;DI&#x27;, &#x27;DJ&#x27;, &#x27;DK&#x27;, &#x27;DL&#x27;, &#x27;DM&#x27;, &#x27;DN&#x27;, &#x27;DO&#x27;, &#x27;DP&#x27;, &#x27;DQ&#x27;, &#x27;DR&#x27;, &#x27;DS&#x27;, &#x27;DT&#x27;, &#x27;DU&#x27;, &#x27;DV&#x27;, &#x27;DW&#x27;, &#x27;DX&#x27;, &#x27;DY&#x27;, &#x27;DZ&#x27;, &#x27;DA&#x27;, &#x27;DB&#x27;, &#x27;DC&#x27;, &#x27;DD&#x27;, &#x27;DE&#x27;, &#x27;DF&#x27;, &#x27;DG&#x27;, &#x27;DH&#x27;, &#x27;DI&#x27;, &#x27;DJ&#x27;, &#x27;DK&#x27;, &#x27;DL&#x27;, &#x27;DM&#x27;, &#x27;DN&#x27;, &#x27;DO&#x27;, &#x27;DP&#x27;, &#x27;DQ&#x27;, &#x27;DR&#x27;, &#x27;DS&#x27;, &#x27;DT&#x27;, &#x27;DU&#x27;, &#x27;DV&#x27;, &#x27;DW&#x27;, &#x27;DX&#x27;, &#x27;DY&#x27;, &#x27;DZ&#x27;, &#x27;EF&#x27;, &#x27;EG&#x27;, &#x27;EH&#x27;, &#x27;EI&#x27;, &#x27;EJ&#x27;, &#x27;EK&#x27;, &#x27;EL&#x27;, &#x27;EM&#x27;, &#x27;EN&#x27;, &#x27;EO&#x27;, &#x27;EP&#x27;, &#x27;EQ&#x27;, &#x27;ER&#x27;, &#x27;ES&#x27;, &#x27;ET&#x27;, &#x27;EU&#x27;, &#x27;EV&#x27;, &#x27;EW&#x27;, &#x27;EX&#x27;, &#x27;EY&#x27;, &#x27;EZ&#x27;, &#x27;EA&#x27;, &#x27;EB&#x27;, &#x27;EC&#x27;, &#x27;ED&#x27;, &#x27;EE&#x27;, &#x27;EF&#x27;, &#x27;EG&#x27;, &#x27;EH&#x27;, &#x27;EI&#x27;, &#x27;EJ&#x27;, &#x27;EK&#x27;, &#x27;EL&#x27;, &#x27;EM&#x27;, &#x27;EN&#x27;, &#x27;EO&#x27;, &#x27;EP&#x27;, &#x27;EQ&#x27;, &#x27;ER&#x27;, &#x27;ES&#x27;, &#x27;ET&#x27;, &#x27;EU&#x27;, &#x27;EV&#x27;, &#x27;EW&#x27;, &#x27;EX&#x27;, &#x27;EY&#x27;, &#x27;EZ&#x27;, &#x27;FG&#x27;, &#x27;FH&#x27;, &#x27;FI&#x27;, &#x27;FJ&#x27;, &#x27;FK&#x27;, &#x27;FL&#x27;, &#x27;FM&#x27;, &#x27;FN&#x27;, &#x27;FO&#x27;, &#x27;FP&#x27;, &#x27;FQ&#x27;, &#x27;FR&#x27;, &#x27;FS&#x27;, &#x27;FT&#x27;, &#x27;FU&#x27;, &#x27;FV&#x27;, &#x27;FW&#x27;, &#x27;FX&#x27;, &#x27;FY&#x27;, &#x27;FZ&#x27;, &#x27;FA&#x27;, &#x27;FB&#x27;, &#x27;FC&#x27;, &#x27;FD&#x27;, &#x27;FE&#x27;, &#x27;FF&#x27;, &#x27;FG&#x27;, &#x27;FH&#x27;, &#x27;FI&#x27;, &#x27;FJ&#x27;, &#x27;FK&#x27;, &#x27;FL&#x27;, &#x27;FM&#x27;, &#x27;FN&#x27;, &#x27;FO&#x27;, &#x27;FP&#x27;, &#x27;FQ&#x27;, &#x27;FR&#x27;, &#x27;FS&#x27;, &#x27;FT&#x27;, &#x27;FU&#x27;, &#x27;FV&#x27;, &#x27;FW&#x27;, &#x27;FX&#x27;, &#x27;FY&#x27;, &#x27;FZ&#x27;, &#x27;GH&#x27;, &#x27;GI&#x27;, &#x27;GJ&#x27;, &#x27;GK&#x27;, &#x27;GL&#x27;, &#x27;GM&#x27;, &#x27;GN&#x27;, &#x27;GO&#x27;, &#x27;GP&#x27;, &#x27;GQ&#x27;, &#x27;GR&#x27;, &#x27;GS&#x27;, &#x27;GT&#x27;, &#x27;GU&#x27;, &#x27;GV&#x27;, &#x27;GW&#x27;, &#x27;GX&#x27;, &#x27;GY&#x27;, &#x27;GZ&#x27;, &#x27;GA&#x27;, &#x27;GB&#x27;, &#x27;GC&#x27;, &#x27;GD&#x27;, &#x27;GE&#x27;, &#x27;GF&#x27;, &#x27;GG&#x27;, &#x27;GH&#x27;, &#x27;GI&#x27;, &#x27;GJ&#x27;, &#x27;GK&#x27;, &#x27;GL&#x27;, &#x27;GM&#x27;, &#x27;GN&#x27;, &#x27;GO&#x27;, &#x27;GP&#x27;, &#x27;GQ&#x27;, &#x27;GR&#x27;, &#x27;GS&#x27;, &#x27;GT&#x27;, &#x27;GU&#x27;, &#x27;GV&#x27;, &#x27;GW&#x27;, &#x27;GX&#x27;, &#x27;GY&#x27;, &#x27;GZ&#x27;, &#x27;HI&#x27;, &#x27;HJ&#x27;, &#x27;HK&#x27;, &#x27;HL&#x27;, &#x27;HM&#x27;, &#x27;HN&#x27;, &#x27;HO&#x27;, &#x27;HP&#x27;, &#x27;HQ&#x27;, &#x27;HR&#x27;, &#x27;HS&#x27;, &#x27;HT&#x27;, &#x27;HU&#x27;, &#x27;HV&#x27;, &#x27;HW&#x27;, &#x27;HX&#x27;, &#x27;HY&#x27;, &#x27;HZ&#x27;, &#x27;HA&#x27;, &#x27;HB&#x27;, &#x27;HC&#x27;, &#x27;HD&#x27;, &#x27;HE&#x27;, &#x27;HF&#x27;, &#x27;HG&#x27;, &#x27;HH&#x27;, &#x27;HI&#x27;, &#x27;HJ&#x27;, &#x27;HK&#x27;, &#x27;HL&#x27;, &#x27;HM&#x27;, &#x27;HN&#x27;, &#x27;HO&#x27;, &#x27;HP&#x27;, &#x27;HQ&#x27;, &#x27;HR&#x27;, &#x27;HS&#x27;, &#x27;HT&#x27;, &#x27;HU&#x27;, &#x27;HV&#x27;, &#x27;HW&#x27;, &#x27;HX&#x27;, &#x27;HY&#x27;, &#x27;HZ&#x27;, &#x27;IJ&#x27;, &#x27;IK&#x27;, &#x27;IL&#x27;, &#x27;IM&#x27;, &#x27;IN&#x27;, &#x27;IO&#x27;, &#x27;IP&#x27;, &#x27;IQ&#x27;, &#x27;IR&#x27;, &#x27;IS&#x27;, &#x27;IT&#x27;, &#x27;IU&#x27;, &#x27;IV&#x27;, &#x27;IW&#x27;, &#x27;IX&#x27;, &#x27;IY&#x27;, &#x27;IZ&#x27;, &#x27;IA&#x27;, &#x27;IB&#x27;, &#x27;IC&#x27;, &#x27;ID&#x27;, &#x27;IE&#x27;, &#x27;IF&#x27;, &#x27;IG&#x27;, &#x27;IH&#x27;, &#x27;II&#x27;, &#x27;IJ&#x27;, &#x27;IK&#x27;, &#x27;IL&#x27;, &#x27;IM&#x27;, &#x27;IN&#x27;, &#x27;IO&#x27;, &#x27;IP&#x27;, &#x27;IQ&#x27;, &#x27;IR&#x27;, &#x27;IS&#x27;, &#x27;IT&#x27;, &#x27;IU&#x27;, &#x27;IV&#x27;, &#x27;IW&#x27;, &#x27;IX&#x27;, &#x27;IY&#x27;, &#x27;IZ&#x27;, &#x27;JK&#x27;, &#x27;JL&#x27;, &#x27;JM&#x27;, &#x27;JN&#x27;, &#x27;JO&#x27;, &#x27;JP&#x27;, &#x27;JQ&#x27;, &#x27;JR&#x27;, &#x27;JS&#x27;, &#x27;JT&#x27;, &#x27;JU&#x27;, &#x27;JV&#x27;, &#x27;JW&#x27;, &#x27;JX&#x27;, &#x27;JY&#x27;, &#x27;JZ&#x27;, &#x27;JA&#x27;, &#x27;JB&#x27;, &#x27;JC&#x27;, &#x27;JD&#x27;, &#x27;JE&#x27;, &#x27;JF&#x27;, &#x27;JG&#x27;, &#x27;JH&#x27;, &#x27;JI&#x27;, &#x27;JJ&#x27;, &#x27;JK&#x27;, &#x27;JL&#x27;, &#x27;JM&#x27;, &#x27;JN&#x27;, &#x27;JO&#x27;, &#x27;JP&#x27;, &#x27;JQ&#x27;, &#x27;JR&#x27;, &#x27;JS&#x27;, &#x27;JT&#x27;, &#x27;JU&#x27;, &#x27;JV&#x27;, &#x27;JW&#x27;, &#x27;JX&#x27;, &#x27;JY&#x27;, &#x27;JZ&#x27;, &#x27;KL&#x27;, &#x27;KM&#x27;, &#x27;KN&#x27;, &#x27;KO&#x27;, &#x27;KP&#x27;, &#x27;KQ&#x27;, &#x27;KR&#x27;, &#x27;KS&#x27;, &#x27;KT&#x27;, &#x27;KU&#x27;, &#x27;KV&#x27;, &#x27;KW&#x27;, &#x27;KX&#x27;, &#x27;KY&#x27;, &#x27;KZ&#x27;, &#x27;KA&#x27;, &#x27;KB&#x27;, &#x27;KC&#x27;, &#x27;KD&#x27;, &#x27;KE&#x27;, &#x27;KF&#x27;, &#x27;KG&#x27;, &#x27;KH&#x27;, &#x27;KI&#x27;, &#x27;KJ&#x27;, &#x27;KK&#x27;, &#x27;KL&#x27;, &#x27;KM&#x27;, &#x27;KN&#x27;, &#x27;KO&#x27;, &#x27;KP&#x27;, &#x27;KQ&#x27;, &#x27;KR&#x27;, &#x27;KS&#x27;, &#x27;KT&#x27;, &#x27;KU&#x27;, &#x27;KV&#x27;, &#x27;KW&#x27;, &#x27;KX&#x27;, &#x27;KY&#x27;, &#x27;KZ&#x27;, &#x27;LM&#x27;, &#x27;LN&#x27;, &#x27;LO&#x27;, &#x27;LP&#x27;, &#x27;LQ&#x27;, &#x27;LR&#x27;, &#x27;LS&#x27;, &#x27;LT&#x27;, &#x27;LU&#x27;, &#x27;LV&#x27;, &#x27;LW&#x27;, &#x27;LX&#x27;, &#x27;LY&#x27;, &#x27;LZ&#x27;, &#x27;LA&#x27;, &#x27;LB&#x27;, &#x27;LC&#x27;, &#x27;LD&#x27;, &#x27;LE&#x27;, &#x27;LF&#x27;, &#x27;LG&#x27;, &#x27;LH&#x27;, &#x27;LI&#x27;, &#x27;LJ&#x27;, &#x27;LK&#x27;, &#x27;LL&#x27;, &#x27;LM&#x27;, &#x27;LN&#x27;, &#x27;LO&#x27;, &#x27;LP&#x27;, &#x27;LQ&#x27;, &#x27;LR&#x27;, &#x27;LS&#x27;, &#x27;LT&#x27;, &#x27;LU&#x27;, &#x27;LV&#x27;, &#x27;LW&#x27;, &#x27;LX&#x27;, &#x27;LY&#x27;, &#x27;LZ&#x27;, &#x27;MN&#x27;, &#x27;MO&#x27;, &#x27;MP&#x27;, &#x27;MQ&#x27;, &#x27;MR&#x27;, &#x27;MS&#x27;, &#x27;MT&#x27;, &#x27;MU&#x27;, &#x27;MV&#x27;, &#x27;MW&#x27;, &#x27;MX&#x27;, &#x27;MY&#x27;, &#x27;MZ&#x27;, &#x27;MA&#x27;, &#x27;MB&#x27;, &#x27;MC&#x27;, &#x27;MD&#x27;, &#x27;ME&#x27;, &#x27;MF&#x27;, &#x27;MG&#x27;, &#x27;MH&#x27;, &#x27;MI&#x27;, &#x27;MJ&#x27;, &#x27;MK&#x27;, &#x27;ML&#x27;, &#x27;MM&#x27;, &#x27;MN&#x27;, &#x27;MO&#x27;, &#x27;MP&#x27;, &#x27;MQ&#x27;, &#x27;MR&#x27;, &#x27;MS&#x27;, &#x27;MT&#x27;, &#x27;MU&#x27;, &#x27;MV&#x27;, &#x27;MW&#x27;, &#x27;MX&#x27;, &#x27;MY&#x27;, &#x27;MZ&#x27;, &#x27;NO&#x27;, &#x27;NP&#x27;, &#x27;NQ&#x27;, &#x27;NR&#x27;, &#x27;NS&#x27;, &#x27;NT&#x27;, &#x27;NU&#x27;, &#x27;NV&#x27;, &#x27;NW&#x27;, &#x27;NX&#x27;, &#x27;NY&#x27;, &#x27;NZ&#x27;, &#x27;NA&#x27;, &#x27;NB&#x27;, &#x27;NC&#x27;, &#x27;ND&#x27;, &#x27;NE&#x27;, &#x27;NF&#x27;, &#x27;NG&#x27;, &#x27;NH&#x27;, &#x27;NI&#x27;, &#x27;NJ&#x27;, &#x27;NK&#x27;, &#x27;NL&#x27;, &#x27;NM&#x27;, &#x27;NN&#x27;, &#x27;NO&#x27;, &#x27;NP&#x27;, &#x27;NQ&#x27;, &#x27;NR&#x27;, &#x27;NS&#x27;, &#x27;NT&#x27;, &#x27;NU&#x27;, &#x27;NV&#x27;, &#x27;NW&#x27;, &#x27;NX&#x27;, &#x27;NY&#x27;, &#x27;NZ&#x27;, &#x27;OP&#x27;, &#x27;OQ&#x27;, &#x27;OR&#x27;, &#x27;OS&#x27;, &#x27;OT&#x27;, &#x27;OU&#x27;, &#x27;OV&#x27;, &#x27;OW&#x27;, &#x27;OX&#x27;, &#x27;OY&#x27;, &#x27;OZ&#x27;, &#x27;OA&#x27;, &#x27;OB&#x27;, &#x27;OC&#x27;, &#x27;OD&#x27;, &#x27;OE&#x27;, &#x27;OF&#x27;, &#x27;OG&#x27;, &#x27;OH&#x27;, &#x27;OI&#x27;, &#x27;OJ&#x27;, &#x27;OK&#x27;, &#x27;OL&#x27;, &#x27;OM&#x27;, &#x27;ON&#x27;, &#x27;OO&#x27;, &#x27;OP&#x27;, &#x27;OQ&#x27;, &#x27;OR&#x27;, &#x27;OS&#x27;, &#x27;OT&#x27;, &#x27;OU&#x27;, &#x27;OV&#x27;, &#x27;OW&#x27;, &#x27;OX&#x27;, &#x27;OY&#x27;, &#x27;OZ&#x27;, &#x27;PQ&#x27;, &#x27;PR&#x27;, &#x27;PS&#x27;, &#x27;PT&#x27;, &#x27;PU&#x27;, &#x27;PV&#x27;, &#x27;PW&#x27;, &#x27;PX&#x27;, &#x27;PY&#x27;, &#x27;PZ&#x27;, &#x27;PA&#x27;, &#x27;PB&#x27;, &#x27;PC&#x27;, &#x27;PD&#x27;, &#x27;PE&#x27;, &#x27;PF&#x27;, &#x27;PG&#x27;, &#x27;PH&#x27;, &#x27;PI&#x27;, &#x27;PJ&#x27;, &#x27;PK&#x27;, &#x27;PL&#x27;, &#x27;PM&#x27;, &#x27;PN&#x27;, &#x27;PO&#x27;, &#x27;PP&#x27;, &#x27;PQ&#x27;, &#x27;PR&#x27;, &#x27;PS&#x27;, &#x27;PT&#x27;, &#x27;PU&#x27;, &#x27;PV&#x27;, &#x27;PW&#x27;, &#x27;PX&#x27;, &#x27;PY&#x27;, &#x27;PZ&#x27;, &#x27;QR&#x27;, &#x27;QS&#x27;, &#x27;QT&#x27;, &#x27;QU&#x27;, &#x27;QV&#x27;, &#x27;QW&#x27;, &#x27;QX&#x27;, &#x27;QY&#x27;, &#x27;QZ&#x27;, &#x27;QA&#x27;, &#x27;QB&#x27;, &#x27;QC&#x27;, &#x27;QD&#x27;, &#x27;QE&#x27;, &#x27;QF&#x27;, &#x27;QG&#x27;, &#x27;QH&#x27;, &#x27;QI&#x27;, &#x27;QJ&#x27;, &#x27;QK&#x27;, &#x27;QL&#x27;, &#x27;QM&#x27;, &#x27;QN&#x27;, &#x27;QO&#x27;, &#x27;QP&#x27;, &#x27;QQ&#x27;, &#x27;QR&#x27;, &#x27;QS&#x27;, &#x27;QT&#x27;, &#x27;QU&#x27;, &#x27;QV&#x27;, &#x27;QW&#x27;, &#x27;QX&#x27;, &#x27;QY&#x27;, &#x27;QZ&#x27;, &#x27;RS&#x27;, &#x27;RT&#x27;, &#x27;RU&#x27;, &#x27;RV&#x27;, &#x27;RW&#x27;, &#x27;RX&#x27;, &#x27;RY&#x27;, &#x27;RZ&#x27;, &#x27;RA&#x27;, &#x27;RB&#x27;, &#x27;RC&#x27;, &#x27;RD&#x27;, &#x27;RE&#x27;, &#x27;RF&#x27;, &#x27;RG&#x27;, &#x27;RH&#x27;, &#x27;RI&#x27;, &#x27;RJ&#x27;, &#x27;RK&#x27;, &#x27;RL&#x27;, &#x27;RM&#x27;, &#x27;RN&#x27;, &#x27;RO&#x27;, &#x27;RP&#x27;, &#x27;RQ&#x27;, &#x27;RR&#x27;, &#x27;RS&#x27;, &#x27;RT&#x27;, &#x27;RU&#x27;, &#x27;RV&#x27;, &#x27;RW&#x27;, &#x27;RX&#x27;, &#x27;RY&#x27;, &#x27;RZ&#x27;, &#x27;ST&#x27;, &#x27;SU&#x27;, &#x27;SV&#x27;, &#x27;SW&#x27;, &#x27;SX&#x27;, &#x27;SY&#x27;, &#x27;SZ&#x27;, &#x27;SA&#x27;, &#x27;SB&#x27;, &#x27;SC&#x27;, &#x27;SD&#x27;, &#x27;SE&#x27;, &#x27;SF&#x27;, &#x27;SG&#x27;, &#x27;SH&#x27;, &#x27;SI&#x27;, &#x27;SJ&#x27;, &#x27;SK&#x27;, &#x27;SL&#x27;, &#x27;SM&#x27;, &#x27;SN&#x27;, &#x27;SO&#x27;, &#x27;SP&#x27;, &#x27;SQ&#x27;, &#x27;SR&#x27;, &#x27;SS&#x27;, &#x27;ST&#x27;, &#x27;SU&#x27;, &#x27;SV&#x27;, &#x27;SW&#x27;, &#x27;SX&#x27;, &#x27;SY&#x27;, &#x27;SZ&#x27;, &#x27;TU&#x27;, &#x27;TV&#x27;, &#x27;TW&#x27;, &#x27;TX&#x27;, &#x27;TY&#x27;, &#x27;TZ&#x27;, &#x27;TA&#x27;, &#x27;TB&#x27;, &#x27;TC&#x27;, &#x27;TD&#x27;, &#x27;TE&#x27;, &#x27;TF&#x27;, &#x27;TG&#x27;, &#x27;TH&#x27;, &#x27;TI&#x27;, &#x27;TJ&#x27;, &#x27;TK&#x27;, &#x27;TL&#x27;, &#x27;TM&#x27;, &#x27;TN&#x27;, &#x27;TO&#x27;, &#x27;TP&#x27;, &#x27;TQ&#x27;, &#x27;TR&#x27;, &#x27;TS&#x27;, &#x27;TT&#x27;, &#x27;TU&#x27;, &#x27;TV&#x27;, &#x27;TW&#x27;, &#x27;TX&#x27;, &#x27;TY&#x27;, &#x27;TZ&#x27;, &#x27;UV&#x27;, &#x27;UW&#x27;, &#x27;UX&#x27;, &#x27;UY&#x27;, &#x27;UZ&#x27;, &#x27;UA&#x27;, &#x27;UB&#x27;, &#x27;UC&#x27;, &#x27;UD&#x27;, &#x27;UE&#x27;, &#x27;UF&#x27;, &#x27;UG&#x27;, &#x27;UH&#x27;, &#x27;UI&#x27;, &#x27;UJ&#x27;, &#x27;UK&#x27;, &#x27;UL&#x27;, &#x27;UM&#x27;, &#x27;UN&#x27;, &#x27;UO&#x27;, &#x27;UP&#x27;, &#x27;UQ&#x27;, &#x27;UR&#x27;, &#x27;US&#x27;, &#x27;UT&#x27;, &#x27;UU&#x27;, &#x27;UV&#x27;, &#x27;UW&#x27;, &#x27;UX&#x27;, &#x27;UY&#x27;, &#x27;UZ&#x27;, &#x27;VW&#x27;, &#x27;VX&#x27;, &#x27;VY&#x27;, &#x27;VZ&#x27;, &#x27;VA&#x27;, &#x27;VB&#x27;, &#x27;VC&#x27;, &#x27;VD&#x27;, &#x27;VE&#x27;, &#x27;VF&#x27;, &#x27;VG&#x27;, &#x27;VH&#x27;, &#x27;VI&#x27;, &#x27;VJ&#x27;, &#x27;VK&#x27;, &#x27;VL&#x27;, &#x27;VM&#x27;, &#x27;VN&#x27;, &#x27;VO&#x27;, &#x27;VP&#x27;, &#x27;VQ&#x27;, &#x27;VR&#x27;, &#x27;VS&#x27;, &#x27;VT&#x27;, &#x27;VU&#x27;, &#x27;VV&#x27;, &#x27;VW&#x27;, &#x27;VX&#x27;, &#x27;VY&#x27;, &#x27;VZ&#x27;, &#x27;WX&#x27;, &#x27;WY&#x27;, &#x27;WZ&#x27;, &#x27;WA&#x27;, &#x27;WB&#x27;, &#x27;WC&#x27;, &#x27;WD&#x27;, &#x27;WE&#x27;, &#x27;WF&#x27;, &#x27;WG&#x27;, &#x27;WH&#x27;, &#x27;WI&#x27;, &#x27;WJ&#x27;, &#x27;WK&#x27;, &#x27;WL&#x27;, &#x27;WM&#x27;, &#x27;WN&#x27;, &#x27;WO&#x27;, &#x27;WP&#x27;, &#x27;WQ&#x27;, &#x27;WR&#x27;, &#x27;WS&#x27;, &#x27;WT&#x27;, &#x27;WU&#x27;, &#x27;WV&#x27;, &#x27;WW&#x27;, &#x27;WX&#x27;, &#x27;WY&#x27;, &#x27;WZ&#x27;, &#x27;XY&#x27;, &#x27;XZ&#x27;, &#x27;XA&#x27;, &#x27;XB&#x27;, &#x27;XC&#x27;, &#x27;XD&#x27;, &#x27;XE&#x27;, &#x27;XF&#x27;, &#x27;XG&#x27;, &#x27;XH&#x27;, &#x27;XI&#x27;, &#x27;XJ&#x27;, &#x27;XK&#x27;, &#x27;XL&#x27;, &#x27;XM&#x27;, &#x27;XN&#x27;, &#x27;XO&#x27;, &#x27;XP&#x27;, &#x27;XQ&#x27;, &#x27;XR&#x27;, &#x27;XS&#x27;, &#x27;XT&#x27;, &#x27;XU&#x27;, &#x27;XV&#x27;, &#x27;XW&#x27;, &#x27;XX&#x27;, &#x27;XY&#x27;, &#x27;XZ&#x27;, &#x27;YZ&#x27;, &#x27;YA&#x27;, &#x27;YB&#x27;, &#x27;YC&#x27;, &#x27;YD&#x27;, &#x27;YE&#x27;, &#x27;YF&#x27;, &#x27;YG&#x27;, &#x27;YH&#x27;, &#x27;YI&#x27;, &#x27;YJ&#x27;, &#x27;YK&#x27;, &#x27;YL&#x27;, &#x27;YM&#x27;, &#x27;YN&#x27;, &#x27;YO&#x27;, &#x27;YP&#x27;, &#x27;YQ&#x27;, &#x27;YR&#x27;, &#x27;YS&#x27;, &#x27;YT&#x27;, &#x27;YU&#x27;, &#x27;YV&#x27;, &#x27;YW&#x27;, &#x27;YX&#x27;, &#x27;YY&#x27;, &#x27;YZ&#x27;, &#x27;ZA&#x27;, &#x27;ZB&#x27;, &#x27;ZC&#x27;, &#x27;ZD&#x27;, &#x27;ZE&#x27;, &#x27;ZF&#x27;, &#x27;ZG&#x27;, &#x27;ZH&#x27;, &#x27;ZI&#x27;, &#x27;ZJ&#x27;, &#x27;ZK&#x27;, &#x27;ZL&#x27;, &#x27;ZM&#x27;, &#x27;ZN&#x27;, &#x27;ZO&#x27;, &#x27;ZP&#x27;, &#x27;ZQ&#x27;, &#x27;ZR&#x27;, &#x27;ZS&#x27;, &#x27;ZT&#x27;, &#x27;ZU&#x27;, &#x27;ZV&#x27;, &#x27;ZW&#x27;, &#x27;ZX&#x27;, &#x27;ZY&#x27;, &#x27;ZZ&#x27;, &#x27;AB&#x27;, &#x27;AC&#x27;, &#x27;AD&#x27;, &#x27;AE&#x27;, &#x27;AF&#x27;, &#x27;AG&#x27;, &#x27;AH&#x27;, &#x27;AI&#x27;, &#x27;AJ&#x27;, &#x27;AK&#x27;, &#x27;AL&#x27;, &#x27;AM&#x27;, &#x27;AN&#x27;, &#x27;AO&#x27;, &#x27;AP&#x27;, &#x27;AQ&#x27;, &#x27;AR&#x27;, &#x27;AS&#x27;, &#x27;AT&#x27;, &#x27;AU&#x27;, &#x27;AV&#x27;, &#x27;AW&#x27;, &#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BC&#x27;, &#x27;BD&#x27;, &#x27;BE&#x27;, &#x27;BF&#x27;, &#x27;BG&#x27;, &#x27;BH&#x27;, &#x27;BI&#x27;, &#x27;BJ&#x27;, &#x27;BK&#x27;, &#x27;BL&#x27;, &#x27;BM&#x27;, &#x27;BN&#x27;, &#x27;BO&#x27;, &#x27;BP&#x27;, &#x27;BQ&#x27;, &#x27;BR&#x27;, &#x27;BS&#x27;, &#x27;BT&#x27;, &#x27;BU&#x27;, &#x27;BV&#x27;, &#x27;BW&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CD&#x27;, &#x27;CE&#x27;, &#x27;CF&#x27;, &#x27;CG&#x27;, &#x27;CH&#x27;, &#x27;CI&#x27;, &#x27;CJ&#x27;, &#x27;CK&#x27;, &#x27;CL&#x27;, &#x27;CM&#x27;, &#x27;CN&#x27;, &#x27;CO&#x27;, &#x27;CP&#x27;, &#x27;CQ&#x27;, &#x27;CR&#x27;, &#x27;CS&#x27;, &#x27;CT&#x27;, &#x27;CU&#x27;, &#x27;CV&#x27;, &#x27;CW&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;, &#x27;DE&#x27;, &#x27;DF&#x27;, &#x27;DG&#x27;, &#x27;DH&#x27;, &#x27;DI&#x27;, &#x27;DJ&#x27;, &#x27;DK&#x27;, &#x27;DL&#x27;, &#x27;DM&#x27;, &#x27;DN&#x27;, &#x27;DO&#x27;, &#x27;DP&#x27;, &#x27;DQ&#x27;, &#x27;DR&#x27;, &#x27;DS&#x27;, &#x27;DT&#x27;, &#x27;DU&#x27;, &#x27;DV&#x27;, &#x27;DW&#x27;, &#x27;DX&#x27;, &#x27;DY&#x27;, &#x27;DZ&#x27;, &#x27;EF&#x27;, &#x27;EG&#x27;, &#x27;EH&#x27;, &#x27;EI&#x27;, &#x27;EJ&#x27;, &#x27;EK&#x27;, &#x27;EL&#x27;, &#x27;EM&#x27;, &#x27;EN&#x27;, &#x27;EO&#x27;, &#x27;EP&#x27;, &#x27;EQ&#x27;, &#x27;ER&#x27;, &#x27;ES&#x27;, &#x27;ET&#x27;, &#x27;EU&#x27;, &#x27;EV&#x27;, &#x27;EW&#x27;, &#x27;EX&#x27;, &#x27;EY&#x27;, &#x27;EZ&#x27;, &#x27;FG&#x27;, &#x27;FH&#x27;, &#x27;FI&#x27;, &#x27;FJ&#x27;, &#x27;FK&#x27;, &#x27;FL&#x27;, &#x27;FM&#x27;, &#x27;FN&#x27;, &#x27;FO&#x27;, &#x27;FP&#x27;, &#x27;FQ&#x27;, &#x27;FR&#x27;, &#x27;FS&#x27;, &#x27;FT&#x27;, &#x27;FU&#x27;, &#x27;FV&#x27;, &#x27;FW&#x27;, &#x27;FX&#x27;, &#x27;FY&#x27;, &#x27;FZ&#x27;, &#x27;GH&#x27;, &#x27;GI&#x27;, &#x27;GJ&#x27;, &#x27;GK&#x27;, &#x27;GL&#x27;, &#x27;GM&#x27;, &#x27;GN&#x27;, &#x27;GO&#x27;, &#x27;GP&#x27;, &#x27;GQ&#x27;, &#x27;GR&#x27;, &#x27;GS&#x27;, &#x27;GT&#x27;, &#x27;GU&#x27;, &#x27;GV&#x27;, &#x27;GW&#x27;, &#x27;GX&#x27;, &#x27;GY&#x27;, &#x27;GZ&#x27;, &#x27;HI&#x27;, &#x27;HJ&#x27;, &#x27;HK&#x27;, &#x27;HL&#x27;, &#x27;HM&#x27;, &#x27;HN&#x27;, &#x27;HO&#x27;, &#x27;HP&#x27;, &#x27;HQ&#x27;, &#x27;HR&#x27;, &#x27;HS&#x27;, &#x27;HT&#x27;, &#x27;HU&#x27;, &#x27;HV&#x27;, &#x27;HW&#x27;, &#x27;HX&#x27;, &#x27;HY&#x27;, &#x27;HZ&#x27;, &#x27;IJ&#x27;, &#x27;IK&#x27;, &#x27;IL&#x27;, &#x27;IM&#x27;, &#x27;IN&#x27;, &#x27;IO&#x27;, &#x27;IP&#x27;, &#x27;IQ&#x27;, &#x27;IR&#x27;, &#x27;IS&#x27;, &#x27;IT&#x27;, &#x27;IU&#x27;, &#x27;IV&#x27;, &#x27;IW&#x27;, &#x27;IX&#x27;, &#x27;IY&#x27;, &#x27;IZ&#x27;, &#x27;JK&#x27;, &#x27;JL&#x27;, &#x27;JM&#x27;, &#x27;JN&#x27;, &#x27;JO&#x27;, &#x27;JP&#x27;, &#x27;JQ&#x27;, &#x27;JR&#x27;, &#x27;JS&#x27;, &#x27;JT&#x27;, &#x27;JU&#x27;, &#x27;JV&#x27;, &#x27;JW&#x27;, &#x27;JX&#x27;, &#x27;JY&#x27;, &#x27;JZ&#x27;, &#x27;KL&#x27;, &#x27;KM&#x27;, &#x27;KN&#x27;, &#x27;KO&#x27;, &#x27;KP&#x27;, &#x27;KQ&#x27;, &#x27;KR&#x27;, &#x27;KS&#x27;, &#x27;KT&#x27;, &#x27;KU&#x27;, &#x27;KV&#x27;, &#x27;KW&#x27;, &#x27;KX&#x27;, &#x27;KY&#x27;, &#x27;KZ&#x27;, &#x27;LM&#x27;, &#x27;LN&#x27;, &#x27;LO&#x27;, &#x27;LP&#x27;, &#x27;LQ&#x27;, &#x27;LR&#x27;, &#x27;LS&#x27;, &#x27;LT&#x27;, &#x27;LU&#x27;, &#x27;LV&#x27;, &#x27;LW&#x27;, &#x27;LX&#x27;, &#x27;LY&#x27;, &#x27;LZ&#x27;, &#x27;MN&#x27;, &#x27;MO&#x27;, &#x27;MP&#x27;, &#x27;MQ&#x27;, &#x27;MR&#x27;, &#x27;MS&#x27;, &#x27;MT&#x27;, &#x27;MU&#x27;, &#x27;MV&#x27;, &#x27;MW&#x27;, &#x27;MX&#x27;, &#x27;MY&#x27;, &#x27;MZ&#x27;, &#x27;NO&#x27;, &#x27;NP&#x27;, &#x27;NQ&#x27;, &#x27;NR&#x27;, &#x27;NS&#x27;, &#x27;NT&#x27;, &#x27;NU&#x27;, &#x27;NV&#x27;, &#x27;NW&#x27;, &#x27;NX&#x27;, &#x27;NY&#x27;, &#x27;NZ&#x27;, &#x27;OP&#x27;, &#x27;OQ&#x27;, &#x27;OR&#x27;, &#x27;OS&#x27;, &#x27;OT&#x27;, &#x27;OU&#x27;, &#x27;OV&#x27;, &#x27;OW&#x27;, &#x27;OX&#x27;, &#x27;OY&#x27;, &#x27;OZ&#x27;, &#x27;PQ&#x27;, &#x27;PR&#x27;, &#x27;PS&#x27;, &#x27;PT&#x27;, &#x27;PU&#x27;, &#x27;PV&#x27;, &#x27;PW&#x27;, &#x27;PX&#x27;, &#x27;PY&#x27;, &#x27;PZ&#x27;, &#x27;QR&#x27;, &#x27;QS&#x27;, &#x27;QT&#x27;, &#x27;QU&#x27;, &#x27;QV&#x27;, &#x27;QW&#x27;, &#x27;QX&#x27;, &#x27;QY&#x27;, &#x27;QZ&#x27;, &#x27;RS&#x27;, &#x27;RT&#x27;, &#x27;RU&#x27;, &#x27;RV&#x27;, &#x27;RW&#x27;, &#x27;RX&#x27;, &#x27;RY&#x27;, &#x27;RZ&#x27;, &#x27;ST&#x27;, &#x27;SU&#x27;, &#x27;SV&#x27;, &#x27;SW&#x27;, &#x27;SX&#x27;, &#x27;SY&#x27;, &#x27;SZ&#x27;, &#x27;TU&#x27;, &#x27;TV&#x27;, &#x27;TW&#x27;, &#x27;TX&#x27;, &#x27;TY&#x27;, &#x27;TZ&#x27;, &#x27;UV&#x27;, &#x27;UW&#x27;, &#x27;UX&#x27;, &#x27;UY&#x27;, &#x27;UZ&#x27;, &#x27;VW&#x27;, &#x27;VX&#x27;, &#x27;VY&#x27;, &#x27;VZ&#x27;, &#x27;WX&#x27;, &#x27;WY&#x27;, &#x27;WZ&#x27;, &#x27;XY&#x27;, &#x27;XZ&#x27;, &#x27;YZ&#x27;]"}, {"fullname": "weavingspace.topology.labels", "modulename": "weavingspace.topology", "qualname": "labels", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;, &#x27;ad&#x27;, &#x27;ae&#x27;, &#x27;af&#x27;, &#x27;ag&#x27;, &#x27;ah&#x27;, &#x27;ai&#x27;, &#x27;aj&#x27;, &#x27;ak&#x27;, &#x27;al&#x27;, &#x27;am&#x27;, &#x27;an&#x27;, &#x27;ao&#x27;, &#x27;ap&#x27;, &#x27;aq&#x27;, &#x27;ar&#x27;, &#x27;as&#x27;, &#x27;at&#x27;, &#x27;au&#x27;, &#x27;av&#x27;, &#x27;aw&#x27;, &#x27;ax&#x27;, &#x27;ay&#x27;, &#x27;az&#x27;, &#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;, &#x27;ad&#x27;, &#x27;ae&#x27;, &#x27;af&#x27;, &#x27;ag&#x27;, &#x27;ah&#x27;, &#x27;ai&#x27;, &#x27;aj&#x27;, &#x27;ak&#x27;, &#x27;al&#x27;, &#x27;am&#x27;, &#x27;an&#x27;, &#x27;ao&#x27;, &#x27;ap&#x27;, &#x27;aq&#x27;, &#x27;ar&#x27;, &#x27;as&#x27;, &#x27;at&#x27;, &#x27;au&#x27;, &#x27;av&#x27;, &#x27;aw&#x27;, &#x27;ax&#x27;, &#x27;ay&#x27;, &#x27;az&#x27;, &#x27;bc&#x27;, &#x27;bd&#x27;, &#x27;be&#x27;, &#x27;bf&#x27;, &#x27;bg&#x27;, &#x27;bh&#x27;, &#x27;bi&#x27;, &#x27;bj&#x27;, &#x27;bk&#x27;, &#x27;bl&#x27;, &#x27;bm&#x27;, &#x27;bn&#x27;, &#x27;bo&#x27;, &#x27;bp&#x27;, &#x27;bq&#x27;, &#x27;br&#x27;, &#x27;bs&#x27;, &#x27;bt&#x27;, &#x27;bu&#x27;, &#x27;bv&#x27;, &#x27;bw&#x27;, &#x27;bx&#x27;, &#x27;by&#x27;, &#x27;bz&#x27;, &#x27;ba&#x27;, &#x27;bb&#x27;, &#x27;bc&#x27;, &#x27;bd&#x27;, &#x27;be&#x27;, &#x27;bf&#x27;, &#x27;bg&#x27;, &#x27;bh&#x27;, &#x27;bi&#x27;, &#x27;bj&#x27;, &#x27;bk&#x27;, &#x27;bl&#x27;, &#x27;bm&#x27;, &#x27;bn&#x27;, &#x27;bo&#x27;, &#x27;bp&#x27;, &#x27;bq&#x27;, &#x27;br&#x27;, &#x27;bs&#x27;, &#x27;bt&#x27;, &#x27;bu&#x27;, &#x27;bv&#x27;, &#x27;bw&#x27;, &#x27;bx&#x27;, &#x27;by&#x27;, &#x27;bz&#x27;, &#x27;cd&#x27;, &#x27;ce&#x27;, &#x27;cf&#x27;, &#x27;cg&#x27;, &#x27;ch&#x27;, &#x27;ci&#x27;, &#x27;cj&#x27;, &#x27;ck&#x27;, &#x27;cl&#x27;, &#x27;cm&#x27;, &#x27;cn&#x27;, &#x27;co&#x27;, &#x27;cp&#x27;, &#x27;cq&#x27;, &#x27;cr&#x27;, &#x27;cs&#x27;, &#x27;ct&#x27;, &#x27;cu&#x27;, &#x27;cv&#x27;, &#x27;cw&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;, &#x27;cz&#x27;, &#x27;ca&#x27;, &#x27;cb&#x27;, &#x27;cc&#x27;, &#x27;cd&#x27;, &#x27;ce&#x27;, &#x27;cf&#x27;, &#x27;cg&#x27;, &#x27;ch&#x27;, &#x27;ci&#x27;, &#x27;cj&#x27;, &#x27;ck&#x27;, &#x27;cl&#x27;, &#x27;cm&#x27;, &#x27;cn&#x27;, &#x27;co&#x27;, &#x27;cp&#x27;, &#x27;cq&#x27;, &#x27;cr&#x27;, &#x27;cs&#x27;, &#x27;ct&#x27;, &#x27;cu&#x27;, &#x27;cv&#x27;, &#x27;cw&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;, &#x27;cz&#x27;, &#x27;de&#x27;, &#x27;df&#x27;, &#x27;dg&#x27;, &#x27;dh&#x27;, &#x27;di&#x27;, &#x27;dj&#x27;, &#x27;dk&#x27;, &#x27;dl&#x27;, &#x27;dm&#x27;, &#x27;dn&#x27;, &#x27;do&#x27;, &#x27;dp&#x27;, &#x27;dq&#x27;, &#x27;dr&#x27;, &#x27;ds&#x27;, &#x27;dt&#x27;, &#x27;du&#x27;, &#x27;dv&#x27;, &#x27;dw&#x27;, &#x27;dx&#x27;, &#x27;dy&#x27;, &#x27;dz&#x27;, &#x27;da&#x27;, &#x27;db&#x27;, &#x27;dc&#x27;, &#x27;dd&#x27;, &#x27;de&#x27;, &#x27;df&#x27;, &#x27;dg&#x27;, &#x27;dh&#x27;, &#x27;di&#x27;, &#x27;dj&#x27;, &#x27;dk&#x27;, &#x27;dl&#x27;, &#x27;dm&#x27;, &#x27;dn&#x27;, &#x27;do&#x27;, &#x27;dp&#x27;, &#x27;dq&#x27;, &#x27;dr&#x27;, &#x27;ds&#x27;, &#x27;dt&#x27;, &#x27;du&#x27;, &#x27;dv&#x27;, &#x27;dw&#x27;, &#x27;dx&#x27;, &#x27;dy&#x27;, &#x27;dz&#x27;, &#x27;ef&#x27;, &#x27;eg&#x27;, &#x27;eh&#x27;, &#x27;ei&#x27;, &#x27;ej&#x27;, &#x27;ek&#x27;, &#x27;el&#x27;, &#x27;em&#x27;, &#x27;en&#x27;, &#x27;eo&#x27;, &#x27;ep&#x27;, &#x27;eq&#x27;, &#x27;er&#x27;, &#x27;es&#x27;, &#x27;et&#x27;, &#x27;eu&#x27;, &#x27;ev&#x27;, &#x27;ew&#x27;, &#x27;ex&#x27;, &#x27;ey&#x27;, &#x27;ez&#x27;, &#x27;ea&#x27;, &#x27;eb&#x27;, &#x27;ec&#x27;, &#x27;ed&#x27;, &#x27;ee&#x27;, &#x27;ef&#x27;, &#x27;eg&#x27;, &#x27;eh&#x27;, &#x27;ei&#x27;, &#x27;ej&#x27;, &#x27;ek&#x27;, &#x27;el&#x27;, &#x27;em&#x27;, &#x27;en&#x27;, &#x27;eo&#x27;, &#x27;ep&#x27;, &#x27;eq&#x27;, &#x27;er&#x27;, &#x27;es&#x27;, &#x27;et&#x27;, &#x27;eu&#x27;, &#x27;ev&#x27;, &#x27;ew&#x27;, &#x27;ex&#x27;, &#x27;ey&#x27;, &#x27;ez&#x27;, &#x27;fg&#x27;, &#x27;fh&#x27;, &#x27;fi&#x27;, &#x27;fj&#x27;, &#x27;fk&#x27;, &#x27;fl&#x27;, &#x27;fm&#x27;, &#x27;fn&#x27;, &#x27;fo&#x27;, &#x27;fp&#x27;, &#x27;fq&#x27;, &#x27;fr&#x27;, &#x27;fs&#x27;, &#x27;ft&#x27;, &#x27;fu&#x27;, &#x27;fv&#x27;, &#x27;fw&#x27;, &#x27;fx&#x27;, &#x27;fy&#x27;, &#x27;fz&#x27;, &#x27;fa&#x27;, &#x27;fb&#x27;, &#x27;fc&#x27;, &#x27;fd&#x27;, &#x27;fe&#x27;, &#x27;ff&#x27;, &#x27;fg&#x27;, &#x27;fh&#x27;, &#x27;fi&#x27;, &#x27;fj&#x27;, &#x27;fk&#x27;, &#x27;fl&#x27;, &#x27;fm&#x27;, &#x27;fn&#x27;, &#x27;fo&#x27;, &#x27;fp&#x27;, &#x27;fq&#x27;, &#x27;fr&#x27;, &#x27;fs&#x27;, &#x27;ft&#x27;, &#x27;fu&#x27;, &#x27;fv&#x27;, &#x27;fw&#x27;, &#x27;fx&#x27;, &#x27;fy&#x27;, &#x27;fz&#x27;, &#x27;gh&#x27;, &#x27;gi&#x27;, &#x27;gj&#x27;, &#x27;gk&#x27;, &#x27;gl&#x27;, &#x27;gm&#x27;, &#x27;gn&#x27;, &#x27;go&#x27;, &#x27;gp&#x27;, &#x27;gq&#x27;, &#x27;gr&#x27;, &#x27;gs&#x27;, &#x27;gt&#x27;, &#x27;gu&#x27;, &#x27;gv&#x27;, &#x27;gw&#x27;, &#x27;gx&#x27;, &#x27;gy&#x27;, &#x27;gz&#x27;, &#x27;ga&#x27;, &#x27;gb&#x27;, &#x27;gc&#x27;, &#x27;gd&#x27;, &#x27;ge&#x27;, &#x27;gf&#x27;, &#x27;gg&#x27;, &#x27;gh&#x27;, &#x27;gi&#x27;, &#x27;gj&#x27;, &#x27;gk&#x27;, &#x27;gl&#x27;, &#x27;gm&#x27;, &#x27;gn&#x27;, &#x27;go&#x27;, &#x27;gp&#x27;, &#x27;gq&#x27;, &#x27;gr&#x27;, &#x27;gs&#x27;, &#x27;gt&#x27;, &#x27;gu&#x27;, &#x27;gv&#x27;, &#x27;gw&#x27;, &#x27;gx&#x27;, &#x27;gy&#x27;, &#x27;gz&#x27;, &#x27;hi&#x27;, &#x27;hj&#x27;, &#x27;hk&#x27;, &#x27;hl&#x27;, &#x27;hm&#x27;, &#x27;hn&#x27;, &#x27;ho&#x27;, &#x27;hp&#x27;, &#x27;hq&#x27;, &#x27;hr&#x27;, &#x27;hs&#x27;, &#x27;ht&#x27;, &#x27;hu&#x27;, &#x27;hv&#x27;, &#x27;hw&#x27;, &#x27;hx&#x27;, &#x27;hy&#x27;, &#x27;hz&#x27;, &#x27;ha&#x27;, &#x27;hb&#x27;, &#x27;hc&#x27;, &#x27;hd&#x27;, &#x27;he&#x27;, &#x27;hf&#x27;, &#x27;hg&#x27;, &#x27;hh&#x27;, &#x27;hi&#x27;, &#x27;hj&#x27;, &#x27;hk&#x27;, &#x27;hl&#x27;, &#x27;hm&#x27;, &#x27;hn&#x27;, &#x27;ho&#x27;, &#x27;hp&#x27;, &#x27;hq&#x27;, &#x27;hr&#x27;, &#x27;hs&#x27;, &#x27;ht&#x27;, &#x27;hu&#x27;, &#x27;hv&#x27;, &#x27;hw&#x27;, &#x27;hx&#x27;, &#x27;hy&#x27;, &#x27;hz&#x27;, &#x27;ij&#x27;, &#x27;ik&#x27;, &#x27;il&#x27;, &#x27;im&#x27;, &#x27;in&#x27;, &#x27;io&#x27;, &#x27;ip&#x27;, &#x27;iq&#x27;, &#x27;ir&#x27;, &#x27;is&#x27;, &#x27;it&#x27;, &#x27;iu&#x27;, &#x27;iv&#x27;, &#x27;iw&#x27;, &#x27;ix&#x27;, &#x27;iy&#x27;, &#x27;iz&#x27;, &#x27;ia&#x27;, &#x27;ib&#x27;, &#x27;ic&#x27;, &#x27;id&#x27;, &#x27;ie&#x27;, &#x27;if&#x27;, &#x27;ig&#x27;, &#x27;ih&#x27;, &#x27;ii&#x27;, &#x27;ij&#x27;, &#x27;ik&#x27;, &#x27;il&#x27;, &#x27;im&#x27;, &#x27;in&#x27;, &#x27;io&#x27;, &#x27;ip&#x27;, &#x27;iq&#x27;, &#x27;ir&#x27;, &#x27;is&#x27;, &#x27;it&#x27;, &#x27;iu&#x27;, &#x27;iv&#x27;, &#x27;iw&#x27;, &#x27;ix&#x27;, &#x27;iy&#x27;, &#x27;iz&#x27;, &#x27;jk&#x27;, &#x27;jl&#x27;, &#x27;jm&#x27;, &#x27;jn&#x27;, &#x27;jo&#x27;, &#x27;jp&#x27;, &#x27;jq&#x27;, &#x27;jr&#x27;, &#x27;js&#x27;, &#x27;jt&#x27;, &#x27;ju&#x27;, &#x27;jv&#x27;, &#x27;jw&#x27;, &#x27;jx&#x27;, &#x27;jy&#x27;, &#x27;jz&#x27;, &#x27;ja&#x27;, &#x27;jb&#x27;, &#x27;jc&#x27;, &#x27;jd&#x27;, &#x27;je&#x27;, &#x27;jf&#x27;, &#x27;jg&#x27;, &#x27;jh&#x27;, &#x27;ji&#x27;, &#x27;jj&#x27;, &#x27;jk&#x27;, &#x27;jl&#x27;, &#x27;jm&#x27;, &#x27;jn&#x27;, &#x27;jo&#x27;, &#x27;jp&#x27;, &#x27;jq&#x27;, &#x27;jr&#x27;, &#x27;js&#x27;, &#x27;jt&#x27;, &#x27;ju&#x27;, &#x27;jv&#x27;, &#x27;jw&#x27;, &#x27;jx&#x27;, &#x27;jy&#x27;, &#x27;jz&#x27;, &#x27;kl&#x27;, &#x27;km&#x27;, &#x27;kn&#x27;, &#x27;ko&#x27;, &#x27;kp&#x27;, &#x27;kq&#x27;, &#x27;kr&#x27;, &#x27;ks&#x27;, &#x27;kt&#x27;, &#x27;ku&#x27;, &#x27;kv&#x27;, &#x27;kw&#x27;, &#x27;kx&#x27;, &#x27;ky&#x27;, &#x27;kz&#x27;, &#x27;ka&#x27;, &#x27;kb&#x27;, &#x27;kc&#x27;, &#x27;kd&#x27;, &#x27;ke&#x27;, &#x27;kf&#x27;, &#x27;kg&#x27;, &#x27;kh&#x27;, &#x27;ki&#x27;, &#x27;kj&#x27;, &#x27;kk&#x27;, &#x27;kl&#x27;, &#x27;km&#x27;, &#x27;kn&#x27;, &#x27;ko&#x27;, &#x27;kp&#x27;, &#x27;kq&#x27;, &#x27;kr&#x27;, &#x27;ks&#x27;, &#x27;kt&#x27;, &#x27;ku&#x27;, &#x27;kv&#x27;, &#x27;kw&#x27;, &#x27;kx&#x27;, &#x27;ky&#x27;, &#x27;kz&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;lo&#x27;, &#x27;lp&#x27;, &#x27;lq&#x27;, &#x27;lr&#x27;, &#x27;ls&#x27;, &#x27;lt&#x27;, &#x27;lu&#x27;, &#x27;lv&#x27;, &#x27;lw&#x27;, &#x27;lx&#x27;, &#x27;ly&#x27;, &#x27;lz&#x27;, &#x27;la&#x27;, &#x27;lb&#x27;, &#x27;lc&#x27;, &#x27;ld&#x27;, &#x27;le&#x27;, &#x27;lf&#x27;, &#x27;lg&#x27;, &#x27;lh&#x27;, &#x27;li&#x27;, &#x27;lj&#x27;, &#x27;lk&#x27;, &#x27;ll&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;lo&#x27;, &#x27;lp&#x27;, &#x27;lq&#x27;, &#x27;lr&#x27;, &#x27;ls&#x27;, &#x27;lt&#x27;, &#x27;lu&#x27;, &#x27;lv&#x27;, &#x27;lw&#x27;, &#x27;lx&#x27;, &#x27;ly&#x27;, &#x27;lz&#x27;, &#x27;mn&#x27;, &#x27;mo&#x27;, &#x27;mp&#x27;, &#x27;mq&#x27;, &#x27;mr&#x27;, &#x27;ms&#x27;, &#x27;mt&#x27;, &#x27;mu&#x27;, &#x27;mv&#x27;, &#x27;mw&#x27;, &#x27;mx&#x27;, &#x27;my&#x27;, &#x27;mz&#x27;, &#x27;ma&#x27;, &#x27;mb&#x27;, &#x27;mc&#x27;, &#x27;md&#x27;, &#x27;me&#x27;, &#x27;mf&#x27;, &#x27;mg&#x27;, &#x27;mh&#x27;, &#x27;mi&#x27;, &#x27;mj&#x27;, &#x27;mk&#x27;, &#x27;ml&#x27;, &#x27;mm&#x27;, &#x27;mn&#x27;, &#x27;mo&#x27;, &#x27;mp&#x27;, &#x27;mq&#x27;, &#x27;mr&#x27;, &#x27;ms&#x27;, &#x27;mt&#x27;, &#x27;mu&#x27;, &#x27;mv&#x27;, &#x27;mw&#x27;, &#x27;mx&#x27;, &#x27;my&#x27;, &#x27;mz&#x27;, &#x27;no&#x27;, &#x27;np&#x27;, &#x27;nq&#x27;, &#x27;nr&#x27;, &#x27;ns&#x27;, &#x27;nt&#x27;, &#x27;nu&#x27;, &#x27;nv&#x27;, &#x27;nw&#x27;, &#x27;nx&#x27;, &#x27;ny&#x27;, &#x27;nz&#x27;, &#x27;na&#x27;, &#x27;nb&#x27;, &#x27;nc&#x27;, &#x27;nd&#x27;, &#x27;ne&#x27;, &#x27;nf&#x27;, &#x27;ng&#x27;, &#x27;nh&#x27;, &#x27;ni&#x27;, &#x27;nj&#x27;, &#x27;nk&#x27;, &#x27;nl&#x27;, &#x27;nm&#x27;, &#x27;nn&#x27;, &#x27;no&#x27;, &#x27;np&#x27;, &#x27;nq&#x27;, &#x27;nr&#x27;, &#x27;ns&#x27;, &#x27;nt&#x27;, &#x27;nu&#x27;, &#x27;nv&#x27;, &#x27;nw&#x27;, &#x27;nx&#x27;, &#x27;ny&#x27;, &#x27;nz&#x27;, &#x27;op&#x27;, &#x27;oq&#x27;, &#x27;or&#x27;, &#x27;os&#x27;, &#x27;ot&#x27;, &#x27;ou&#x27;, &#x27;ov&#x27;, &#x27;ow&#x27;, &#x27;ox&#x27;, &#x27;oy&#x27;, &#x27;oz&#x27;, &#x27;oa&#x27;, &#x27;ob&#x27;, &#x27;oc&#x27;, &#x27;od&#x27;, &#x27;oe&#x27;, &#x27;of&#x27;, &#x27;og&#x27;, &#x27;oh&#x27;, &#x27;oi&#x27;, &#x27;oj&#x27;, &#x27;ok&#x27;, &#x27;ol&#x27;, &#x27;om&#x27;, &#x27;on&#x27;, &#x27;oo&#x27;, &#x27;op&#x27;, &#x27;oq&#x27;, &#x27;or&#x27;, &#x27;os&#x27;, &#x27;ot&#x27;, &#x27;ou&#x27;, &#x27;ov&#x27;, &#x27;ow&#x27;, &#x27;ox&#x27;, &#x27;oy&#x27;, &#x27;oz&#x27;, &#x27;pq&#x27;, &#x27;pr&#x27;, &#x27;ps&#x27;, &#x27;pt&#x27;, &#x27;pu&#x27;, &#x27;pv&#x27;, &#x27;pw&#x27;, &#x27;px&#x27;, &#x27;py&#x27;, &#x27;pz&#x27;, &#x27;pa&#x27;, &#x27;pb&#x27;, &#x27;pc&#x27;, &#x27;pd&#x27;, &#x27;pe&#x27;, &#x27;pf&#x27;, &#x27;pg&#x27;, &#x27;ph&#x27;, &#x27;pi&#x27;, &#x27;pj&#x27;, &#x27;pk&#x27;, &#x27;pl&#x27;, &#x27;pm&#x27;, &#x27;pn&#x27;, &#x27;po&#x27;, &#x27;pp&#x27;, &#x27;pq&#x27;, &#x27;pr&#x27;, &#x27;ps&#x27;, &#x27;pt&#x27;, &#x27;pu&#x27;, &#x27;pv&#x27;, &#x27;pw&#x27;, &#x27;px&#x27;, &#x27;py&#x27;, &#x27;pz&#x27;, &#x27;qr&#x27;, &#x27;qs&#x27;, &#x27;qt&#x27;, &#x27;qu&#x27;, &#x27;qv&#x27;, &#x27;qw&#x27;, &#x27;qx&#x27;, &#x27;qy&#x27;, &#x27;qz&#x27;, &#x27;qa&#x27;, &#x27;qb&#x27;, &#x27;qc&#x27;, &#x27;qd&#x27;, &#x27;qe&#x27;, &#x27;qf&#x27;, &#x27;qg&#x27;, &#x27;qh&#x27;, &#x27;qi&#x27;, &#x27;qj&#x27;, &#x27;qk&#x27;, &#x27;ql&#x27;, &#x27;qm&#x27;, &#x27;qn&#x27;, &#x27;qo&#x27;, &#x27;qp&#x27;, &#x27;qq&#x27;, &#x27;qr&#x27;, &#x27;qs&#x27;, &#x27;qt&#x27;, &#x27;qu&#x27;, &#x27;qv&#x27;, &#x27;qw&#x27;, &#x27;qx&#x27;, &#x27;qy&#x27;, &#x27;qz&#x27;, &#x27;rs&#x27;, &#x27;rt&#x27;, &#x27;ru&#x27;, &#x27;rv&#x27;, &#x27;rw&#x27;, &#x27;rx&#x27;, &#x27;ry&#x27;, &#x27;rz&#x27;, &#x27;ra&#x27;, &#x27;rb&#x27;, &#x27;rc&#x27;, &#x27;rd&#x27;, &#x27;re&#x27;, &#x27;rf&#x27;, &#x27;rg&#x27;, &#x27;rh&#x27;, &#x27;ri&#x27;, &#x27;rj&#x27;, &#x27;rk&#x27;, &#x27;rl&#x27;, &#x27;rm&#x27;, &#x27;rn&#x27;, &#x27;ro&#x27;, &#x27;rp&#x27;, &#x27;rq&#x27;, &#x27;rr&#x27;, &#x27;rs&#x27;, &#x27;rt&#x27;, &#x27;ru&#x27;, &#x27;rv&#x27;, &#x27;rw&#x27;, &#x27;rx&#x27;, &#x27;ry&#x27;, &#x27;rz&#x27;, &#x27;st&#x27;, &#x27;su&#x27;, &#x27;sv&#x27;, &#x27;sw&#x27;, &#x27;sx&#x27;, &#x27;sy&#x27;, &#x27;sz&#x27;, &#x27;sa&#x27;, &#x27;sb&#x27;, &#x27;sc&#x27;, &#x27;sd&#x27;, &#x27;se&#x27;, &#x27;sf&#x27;, &#x27;sg&#x27;, &#x27;sh&#x27;, &#x27;si&#x27;, &#x27;sj&#x27;, &#x27;sk&#x27;, &#x27;sl&#x27;, &#x27;sm&#x27;, &#x27;sn&#x27;, &#x27;so&#x27;, &#x27;sp&#x27;, &#x27;sq&#x27;, &#x27;sr&#x27;, &#x27;ss&#x27;, &#x27;st&#x27;, &#x27;su&#x27;, &#x27;sv&#x27;, &#x27;sw&#x27;, &#x27;sx&#x27;, &#x27;sy&#x27;, &#x27;sz&#x27;, &#x27;tu&#x27;, &#x27;tv&#x27;, &#x27;tw&#x27;, &#x27;tx&#x27;, &#x27;ty&#x27;, &#x27;tz&#x27;, &#x27;ta&#x27;, &#x27;tb&#x27;, &#x27;tc&#x27;, &#x27;td&#x27;, &#x27;te&#x27;, &#x27;tf&#x27;, &#x27;tg&#x27;, &#x27;th&#x27;, &#x27;ti&#x27;, &#x27;tj&#x27;, &#x27;tk&#x27;, &#x27;tl&#x27;, &#x27;tm&#x27;, &#x27;tn&#x27;, &#x27;to&#x27;, &#x27;tp&#x27;, &#x27;tq&#x27;, &#x27;tr&#x27;, &#x27;ts&#x27;, &#x27;tt&#x27;, &#x27;tu&#x27;, &#x27;tv&#x27;, &#x27;tw&#x27;, &#x27;tx&#x27;, &#x27;ty&#x27;, &#x27;tz&#x27;, &#x27;uv&#x27;, &#x27;uw&#x27;, &#x27;ux&#x27;, &#x27;uy&#x27;, &#x27;uz&#x27;, &#x27;ua&#x27;, &#x27;ub&#x27;, &#x27;uc&#x27;, &#x27;ud&#x27;, &#x27;ue&#x27;, &#x27;uf&#x27;, &#x27;ug&#x27;, &#x27;uh&#x27;, &#x27;ui&#x27;, &#x27;uj&#x27;, &#x27;uk&#x27;, &#x27;ul&#x27;, &#x27;um&#x27;, &#x27;un&#x27;, &#x27;uo&#x27;, &#x27;up&#x27;, &#x27;uq&#x27;, &#x27;ur&#x27;, &#x27;us&#x27;, &#x27;ut&#x27;, &#x27;uu&#x27;, &#x27;uv&#x27;, &#x27;uw&#x27;, &#x27;ux&#x27;, &#x27;uy&#x27;, &#x27;uz&#x27;, &#x27;vw&#x27;, &#x27;vx&#x27;, &#x27;vy&#x27;, &#x27;vz&#x27;, &#x27;va&#x27;, &#x27;vb&#x27;, &#x27;vc&#x27;, &#x27;vd&#x27;, &#x27;ve&#x27;, &#x27;vf&#x27;, &#x27;vg&#x27;, &#x27;vh&#x27;, &#x27;vi&#x27;, &#x27;vj&#x27;, &#x27;vk&#x27;, &#x27;vl&#x27;, &#x27;vm&#x27;, &#x27;vn&#x27;, &#x27;vo&#x27;, &#x27;vp&#x27;, &#x27;vq&#x27;, &#x27;vr&#x27;, &#x27;vs&#x27;, &#x27;vt&#x27;, &#x27;vu&#x27;, &#x27;vv&#x27;, &#x27;vw&#x27;, &#x27;vx&#x27;, &#x27;vy&#x27;, &#x27;vz&#x27;, &#x27;wx&#x27;, &#x27;wy&#x27;, &#x27;wz&#x27;, &#x27;wa&#x27;, &#x27;wb&#x27;, &#x27;wc&#x27;, &#x27;wd&#x27;, &#x27;we&#x27;, &#x27;wf&#x27;, &#x27;wg&#x27;, &#x27;wh&#x27;, &#x27;wi&#x27;, &#x27;wj&#x27;, &#x27;wk&#x27;, &#x27;wl&#x27;, &#x27;wm&#x27;, &#x27;wn&#x27;, &#x27;wo&#x27;, &#x27;wp&#x27;, &#x27;wq&#x27;, &#x27;wr&#x27;, &#x27;ws&#x27;, &#x27;wt&#x27;, &#x27;wu&#x27;, &#x27;wv&#x27;, &#x27;ww&#x27;, &#x27;wx&#x27;, &#x27;wy&#x27;, &#x27;wz&#x27;, &#x27;xy&#x27;, &#x27;xz&#x27;, &#x27;xa&#x27;, &#x27;xb&#x27;, &#x27;xc&#x27;, &#x27;xd&#x27;, &#x27;xe&#x27;, &#x27;xf&#x27;, &#x27;xg&#x27;, &#x27;xh&#x27;, &#x27;xi&#x27;, &#x27;xj&#x27;, &#x27;xk&#x27;, &#x27;xl&#x27;, &#x27;xm&#x27;, &#x27;xn&#x27;, &#x27;xo&#x27;, &#x27;xp&#x27;, &#x27;xq&#x27;, &#x27;xr&#x27;, &#x27;xs&#x27;, &#x27;xt&#x27;, &#x27;xu&#x27;, &#x27;xv&#x27;, &#x27;xw&#x27;, &#x27;xx&#x27;, &#x27;xy&#x27;, &#x27;xz&#x27;, &#x27;yz&#x27;, &#x27;ya&#x27;, &#x27;yb&#x27;, &#x27;yc&#x27;, &#x27;yd&#x27;, &#x27;ye&#x27;, &#x27;yf&#x27;, &#x27;yg&#x27;, &#x27;yh&#x27;, &#x27;yi&#x27;, &#x27;yj&#x27;, &#x27;yk&#x27;, &#x27;yl&#x27;, &#x27;ym&#x27;, &#x27;yn&#x27;, &#x27;yo&#x27;, &#x27;yp&#x27;, &#x27;yq&#x27;, &#x27;yr&#x27;, &#x27;ys&#x27;, &#x27;yt&#x27;, &#x27;yu&#x27;, &#x27;yv&#x27;, &#x27;yw&#x27;, &#x27;yx&#x27;, &#x27;yy&#x27;, &#x27;yz&#x27;, &#x27;za&#x27;, &#x27;zb&#x27;, &#x27;zc&#x27;, &#x27;zd&#x27;, &#x27;ze&#x27;, &#x27;zf&#x27;, &#x27;zg&#x27;, &#x27;zh&#x27;, &#x27;zi&#x27;, &#x27;zj&#x27;, &#x27;zk&#x27;, &#x27;zl&#x27;, &#x27;zm&#x27;, &#x27;zn&#x27;, &#x27;zo&#x27;, &#x27;zp&#x27;, &#x27;zq&#x27;, &#x27;zr&#x27;, &#x27;zs&#x27;, &#x27;zt&#x27;, &#x27;zu&#x27;, &#x27;zv&#x27;, &#x27;zw&#x27;, &#x27;zx&#x27;, &#x27;zy&#x27;, &#x27;zz&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;, &#x27;ad&#x27;, &#x27;ae&#x27;, &#x27;af&#x27;, &#x27;ag&#x27;, &#x27;ah&#x27;, &#x27;ai&#x27;, &#x27;aj&#x27;, &#x27;ak&#x27;, &#x27;al&#x27;, &#x27;am&#x27;, &#x27;an&#x27;, &#x27;ao&#x27;, &#x27;ap&#x27;, &#x27;aq&#x27;, &#x27;ar&#x27;, &#x27;as&#x27;, &#x27;at&#x27;, &#x27;au&#x27;, &#x27;av&#x27;, &#x27;aw&#x27;, &#x27;ax&#x27;, &#x27;ay&#x27;, &#x27;az&#x27;, &#x27;bc&#x27;, &#x27;bd&#x27;, &#x27;be&#x27;, &#x27;bf&#x27;, &#x27;bg&#x27;, &#x27;bh&#x27;, &#x27;bi&#x27;, &#x27;bj&#x27;, &#x27;bk&#x27;, &#x27;bl&#x27;, &#x27;bm&#x27;, &#x27;bn&#x27;, &#x27;bo&#x27;, &#x27;bp&#x27;, &#x27;bq&#x27;, &#x27;br&#x27;, &#x27;bs&#x27;, &#x27;bt&#x27;, &#x27;bu&#x27;, &#x27;bv&#x27;, &#x27;bw&#x27;, &#x27;bx&#x27;, &#x27;by&#x27;, &#x27;bz&#x27;, &#x27;cd&#x27;, &#x27;ce&#x27;, &#x27;cf&#x27;, &#x27;cg&#x27;, &#x27;ch&#x27;, &#x27;ci&#x27;, &#x27;cj&#x27;, &#x27;ck&#x27;, &#x27;cl&#x27;, &#x27;cm&#x27;, &#x27;cn&#x27;, &#x27;co&#x27;, &#x27;cp&#x27;, &#x27;cq&#x27;, &#x27;cr&#x27;, &#x27;cs&#x27;, &#x27;ct&#x27;, &#x27;cu&#x27;, &#x27;cv&#x27;, &#x27;cw&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;, &#x27;cz&#x27;, &#x27;de&#x27;, &#x27;df&#x27;, &#x27;dg&#x27;, &#x27;dh&#x27;, &#x27;di&#x27;, &#x27;dj&#x27;, &#x27;dk&#x27;, &#x27;dl&#x27;, &#x27;dm&#x27;, &#x27;dn&#x27;, &#x27;do&#x27;, &#x27;dp&#x27;, &#x27;dq&#x27;, &#x27;dr&#x27;, &#x27;ds&#x27;, &#x27;dt&#x27;, &#x27;du&#x27;, &#x27;dv&#x27;, &#x27;dw&#x27;, &#x27;dx&#x27;, &#x27;dy&#x27;, &#x27;dz&#x27;, &#x27;ef&#x27;, &#x27;eg&#x27;, &#x27;eh&#x27;, &#x27;ei&#x27;, &#x27;ej&#x27;, &#x27;ek&#x27;, &#x27;el&#x27;, &#x27;em&#x27;, &#x27;en&#x27;, &#x27;eo&#x27;, &#x27;ep&#x27;, &#x27;eq&#x27;, &#x27;er&#x27;, &#x27;es&#x27;, &#x27;et&#x27;, &#x27;eu&#x27;, &#x27;ev&#x27;, &#x27;ew&#x27;, &#x27;ex&#x27;, &#x27;ey&#x27;, &#x27;ez&#x27;, &#x27;fg&#x27;, &#x27;fh&#x27;, &#x27;fi&#x27;, &#x27;fj&#x27;, &#x27;fk&#x27;, &#x27;fl&#x27;, &#x27;fm&#x27;, &#x27;fn&#x27;, &#x27;fo&#x27;, &#x27;fp&#x27;, &#x27;fq&#x27;, &#x27;fr&#x27;, &#x27;fs&#x27;, &#x27;ft&#x27;, &#x27;fu&#x27;, &#x27;fv&#x27;, &#x27;fw&#x27;, &#x27;fx&#x27;, &#x27;fy&#x27;, &#x27;fz&#x27;, &#x27;gh&#x27;, &#x27;gi&#x27;, &#x27;gj&#x27;, &#x27;gk&#x27;, &#x27;gl&#x27;, &#x27;gm&#x27;, &#x27;gn&#x27;, &#x27;go&#x27;, &#x27;gp&#x27;, &#x27;gq&#x27;, &#x27;gr&#x27;, &#x27;gs&#x27;, &#x27;gt&#x27;, &#x27;gu&#x27;, &#x27;gv&#x27;, &#x27;gw&#x27;, &#x27;gx&#x27;, &#x27;gy&#x27;, &#x27;gz&#x27;, &#x27;hi&#x27;, &#x27;hj&#x27;, &#x27;hk&#x27;, &#x27;hl&#x27;, &#x27;hm&#x27;, &#x27;hn&#x27;, &#x27;ho&#x27;, &#x27;hp&#x27;, &#x27;hq&#x27;, &#x27;hr&#x27;, &#x27;hs&#x27;, &#x27;ht&#x27;, &#x27;hu&#x27;, &#x27;hv&#x27;, &#x27;hw&#x27;, &#x27;hx&#x27;, &#x27;hy&#x27;, &#x27;hz&#x27;, &#x27;ij&#x27;, &#x27;ik&#x27;, &#x27;il&#x27;, &#x27;im&#x27;, &#x27;in&#x27;, &#x27;io&#x27;, &#x27;ip&#x27;, &#x27;iq&#x27;, &#x27;ir&#x27;, &#x27;is&#x27;, &#x27;it&#x27;, &#x27;iu&#x27;, &#x27;iv&#x27;, &#x27;iw&#x27;, &#x27;ix&#x27;, &#x27;iy&#x27;, &#x27;iz&#x27;, &#x27;jk&#x27;, &#x27;jl&#x27;, &#x27;jm&#x27;, &#x27;jn&#x27;, &#x27;jo&#x27;, &#x27;jp&#x27;, &#x27;jq&#x27;, &#x27;jr&#x27;, &#x27;js&#x27;, &#x27;jt&#x27;, &#x27;ju&#x27;, &#x27;jv&#x27;, &#x27;jw&#x27;, &#x27;jx&#x27;, &#x27;jy&#x27;, &#x27;jz&#x27;, &#x27;kl&#x27;, &#x27;km&#x27;, &#x27;kn&#x27;, &#x27;ko&#x27;, &#x27;kp&#x27;, &#x27;kq&#x27;, &#x27;kr&#x27;, &#x27;ks&#x27;, &#x27;kt&#x27;, &#x27;ku&#x27;, &#x27;kv&#x27;, &#x27;kw&#x27;, &#x27;kx&#x27;, &#x27;ky&#x27;, &#x27;kz&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;lo&#x27;, &#x27;lp&#x27;, &#x27;lq&#x27;, &#x27;lr&#x27;, &#x27;ls&#x27;, &#x27;lt&#x27;, &#x27;lu&#x27;, &#x27;lv&#x27;, &#x27;lw&#x27;, &#x27;lx&#x27;, &#x27;ly&#x27;, &#x27;lz&#x27;, &#x27;mn&#x27;, &#x27;mo&#x27;, &#x27;mp&#x27;, &#x27;mq&#x27;, &#x27;mr&#x27;, &#x27;ms&#x27;, &#x27;mt&#x27;, &#x27;mu&#x27;, &#x27;mv&#x27;, &#x27;mw&#x27;, &#x27;mx&#x27;, &#x27;my&#x27;, &#x27;mz&#x27;, &#x27;no&#x27;, &#x27;np&#x27;, &#x27;nq&#x27;, &#x27;nr&#x27;, &#x27;ns&#x27;, &#x27;nt&#x27;, &#x27;nu&#x27;, &#x27;nv&#x27;, &#x27;nw&#x27;, &#x27;nx&#x27;, &#x27;ny&#x27;, &#x27;nz&#x27;, &#x27;op&#x27;, &#x27;oq&#x27;, &#x27;or&#x27;, &#x27;os&#x27;, &#x27;ot&#x27;, &#x27;ou&#x27;, &#x27;ov&#x27;, &#x27;ow&#x27;, &#x27;ox&#x27;, &#x27;oy&#x27;, &#x27;oz&#x27;, &#x27;pq&#x27;, &#x27;pr&#x27;, &#x27;ps&#x27;, &#x27;pt&#x27;, &#x27;pu&#x27;, &#x27;pv&#x27;, &#x27;pw&#x27;, &#x27;px&#x27;, &#x27;py&#x27;, &#x27;pz&#x27;, &#x27;qr&#x27;, &#x27;qs&#x27;, &#x27;qt&#x27;, &#x27;qu&#x27;, &#x27;qv&#x27;, &#x27;qw&#x27;, &#x27;qx&#x27;, &#x27;qy&#x27;, &#x27;qz&#x27;, &#x27;rs&#x27;, &#x27;rt&#x27;, &#x27;ru&#x27;, &#x27;rv&#x27;, &#x27;rw&#x27;, &#x27;rx&#x27;, &#x27;ry&#x27;, &#x27;rz&#x27;, &#x27;st&#x27;, &#x27;su&#x27;, &#x27;sv&#x27;, &#x27;sw&#x27;, &#x27;sx&#x27;, &#x27;sy&#x27;, &#x27;sz&#x27;, &#x27;tu&#x27;, &#x27;tv&#x27;, &#x27;tw&#x27;, &#x27;tx&#x27;, &#x27;ty&#x27;, &#x27;tz&#x27;, &#x27;uv&#x27;, &#x27;uw&#x27;, &#x27;ux&#x27;, &#x27;uy&#x27;, &#x27;uz&#x27;, &#x27;vw&#x27;, &#x27;vx&#x27;, &#x27;vy&#x27;, &#x27;vz&#x27;, &#x27;wx&#x27;, &#x27;wy&#x27;, &#x27;wz&#x27;, &#x27;xy&#x27;, &#x27;xz&#x27;, &#x27;yz&#x27;]"}, {"fullname": "weavingspace.topology.Topology", "modulename": "weavingspace.topology", "qualname": "Topology", "kind": "class", "doc": "<p>Class to represent topology of a Tileable object.</p>\n\n<p>NOTE: It is important that get_local_patch return the tileable elements and\nthe translated copies in consistent sequence, i.e. if there are (say) four\ntiles in the unit, the local patch should be 1 2 3 4 1 2 3 4 1 2 3 4 ... and\nso on. This is because self.tiles[i % n_tiles] is frequently used to\nreference the base unit Tile which corresponds to self.tiles[i].</p>\n"}, {"fullname": "weavingspace.topology.Topology.__init__", "modulename": "weavingspace.topology", "qualname": "Topology.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unit (Tileable):</strong>  the Tileable whose topology is required.</li>\n<li><strong>ignore_tile_ids (bool):</strong>  (EXPERIMENTAL) if True then only consider the tile\nshapes, not labels. If False consider any labels. Defaults to True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">tileable</span><span class=\"o\">.</span><span class=\"n\">Tileable</span>, </span><span class=\"param\"><span class=\"n\">ignore_tile_ids</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "weavingspace.topology.Topology.tileable", "modulename": "weavingspace.topology", "qualname": "Topology.tileable", "kind": "variable", "doc": "<p>the Tileable on which the topology will be based.</p>\n", "annotation": ": weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.topology.Topology.tiles", "modulename": "weavingspace.topology", "qualname": "Topology.tiles", "kind": "variable", "doc": "<p>list of the Tiles in the topology. We use polygons returned by the\ntileable.get_local_patch method for these. That is the base tiles and 8\nadjacent copies (for a rectangular tiling), or 6 adjacent copies (for a\nhexagonal tiling).</p>\n", "annotation": ": list[weavingspace.topology.Tile]"}, {"fullname": "weavingspace.topology.Topology.points", "modulename": "weavingspace.topology", "qualname": "Topology.points", "kind": "variable", "doc": "<p>dictionary of all points (vertices and corners) in the tiling, keyed by\nVertex ID.</p>\n", "annotation": ": dict[int, weavingspace.topology.Vertex]"}, {"fullname": "weavingspace.topology.Topology.edges", "modulename": "weavingspace.topology", "qualname": "Topology.edges", "kind": "variable", "doc": "<p>dictionary of the tiling edges, keyed by Edge ID.</p>\n", "annotation": ": dict[tuple[int, int], weavingspace.topology.Edge]"}, {"fullname": "weavingspace.topology.Topology.unique_tile_shapes", "modulename": "weavingspace.topology", "qualname": "Topology.unique_tile_shapes", "kind": "variable", "doc": "<p>a 'reference' tile shape one per tile shape (up to vertices, so two tiles\nmight be the same shape, but one might have extra vertices induced by the\ntiling and hence is a different shape under this definition).</p>\n", "annotation": ": list[shapely.geometry.polygon.Polygon]"}, {"fullname": "weavingspace.topology.Topology.dual_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.dual_tiles", "kind": "variable", "doc": "<p>list of geom.Polygons from which a dual tiling might be constructed.</p>\n", "annotation": ": list[shapely.geometry.polygon.Polygon]"}, {"fullname": "weavingspace.topology.Topology.n_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.n_tiles", "kind": "variable", "doc": "<p>number of tiles in the base Tileable (retained for convenience).</p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "weavingspace.topology.Topology.shape_groups", "modulename": "weavingspace.topology", "qualname": "Topology.shape_groups", "kind": "variable", "doc": "<p>list of lists of tile IDs distinguished by shape and optionally tile_id</p>\n", "annotation": ": list[list[int]]"}, {"fullname": "weavingspace.topology.Topology.tile_matching_transforms", "modulename": "weavingspace.topology", "qualname": "Topology.tile_matching_transforms", "kind": "variable", "doc": "<p>shapely transform tuples that map tiles onto other tiles</p>\n", "annotation": ": list[tuple[float]]"}, {"fullname": "weavingspace.topology.Topology.tile_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.tile_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of tile IDs in each transitivity class</p>\n", "annotation": ": list[tuple[int]]"}, {"fullname": "weavingspace.topology.Topology.vertex_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.vertex_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of vertex IDs in each transitivity class</p>\n", "annotation": ": list[list[int]]"}, {"fullname": "weavingspace.topology.Topology.edge_transitivity_classes", "modulename": "weavingspace.topology", "qualname": "Topology.edge_transitivity_classes", "kind": "variable", "doc": "<p>list of lists of edge IDs in each transitivity class</p>\n", "annotation": ": list[list[tuple[int]]]"}, {"fullname": "weavingspace.topology.Topology.get_potential_symmetries", "modulename": "weavingspace.topology", "qualname": "Topology.get_potential_symmetries", "kind": "function", "doc": "<p>Assemble potential symmetries from symmetries of prototile and tiles.</p>\n\n<p>Also remove any duplicates that result. The result is assigned to the\ntile_matching_transforms attribute.</p>\n\n<p>TODO: consider retaining the Symmetry objects as these carry additional\ninformation that might facilitate labelling under a limited number of the\nsymmetries not all of them.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[int, tuple[float]]: dictionary of the symmetries (transforms\n    actually) in shapely affine transform 6-tuple format.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_tile_id_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">symmetry</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.vertices_in_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.vertices_in_tiles", "kind": "function", "doc": "<p>Get vertices incident on tiles in supplied list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tiles (list[Tile]):</strong>  tiles whose vertices are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Vertex]: the required vertices.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Tile</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.edges_in_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.edges_in_tiles", "kind": "function", "doc": "<p>Get edges that are part of the boundary of tiles in supplied list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tiles (list[Tile]):</strong>  tiles whose edges are required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Edge]: the required edges.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Tile</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.generate_dual", "modulename": "weavingspace.topology", "qualname": "Topology.generate_dual", "kind": "function", "doc": "<p>Create the dual tiiing for the tiling of this Topology.</p>\n\n<p>TODO: make this a viable replacement for the existing dual tiling\ngeneration.</p>\n\n<p>TODO: also need to ensure that this finds a set of dual tiles that exhaust\nthe plane...</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[geom.Polygon]: a list of polygon objects.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.get_dual_tiles", "modulename": "weavingspace.topology", "qualname": "Topology.get_dual_tiles", "kind": "function", "doc": "<p>Return dual tiles as GeoDataFrame.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.add_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.add_vertex", "kind": "function", "doc": "<p>Add and return Vertex at the specified point location.</p>\n\n<p>No attempt is made to ensure Vertex IDs are an unbroken sequence: a new ID\nis generated one greater than the existing highest ID. IDs will usually be\nan unbroken sequence up to removals when geometry transformations are\napplied.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (geom.Point):</strong>  point location of the Vertex.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Vertex: the added Vertex object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.add_edge", "modulename": "weavingspace.topology", "qualname": "Topology.add_edge", "kind": "function", "doc": "<p>Create an Edge from the suppled vertices and return it.</p>\n\n<p>The new Edge is added to the edges dictionary. Edges are self indexing by\nthe IDs of their end Vertices.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vs (list[Vertex]):</strong>  list of Vertices in the Edge to be created.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Edge: the added Edge.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">vs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.polygon_matches", "modulename": "weavingspace.topology", "qualname": "Topology.polygon_matches", "kind": "function", "doc": "<p>Test if supplied polygons match geometrically.</p>\n\n<p>Tests for equality of area, and equality of their area of overlap to their\nshared area, i.e. Area1 == Area2 == (Area 1 intersection 2).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>geom1 (geom.Polygon):</strong>  first polygon.</li>\n<li><strong>geom2 (geom.Polygon):</strong>  second polygon.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the polygons are the same, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span>,</span><span class=\"param\">\t<span class=\"n\">geom2</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">polygon</span><span class=\"o\">.</span><span class=\"n\">Polygon</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.plot", "modulename": "weavingspace.topology", "qualname": "Topology.plot", "kind": "function", "doc": "<p>Delegate plotting of requested elements and return plt.Axes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>show_original_tiles (bool, optional):</strong>  if True show the tiles. Defaults to\nTrue.</li>\n<li><strong>show_tile_centres (bool, optional):</strong>  if True show tile centres with upper\ncase alphabetical labels. Defaults to False.</li>\n<li><strong>show_vertex_labels (bool, optional):</strong>  if True show tiling vertices labelled\nto show their equivalence classes. Defaults to True.</li>\n<li><strong>show_vertex_ids (bool, optional):</strong>  if True show vertex IDs (i.e., sequence\nnumbers) which is useful for debugging. Defaults to False.</li>\n<li><strong>show_edges (bool, optional):</strong>  if True show tiling edges (not tile sides).\nDefaults to True.</li>\n<li><strong>offset_edges (bool, optional):</strong>  if True offset edges a little from and\nparallel to their geometric position. Defaults to True.</li>\n<li><strong>show_edge_labels (bool, optional):</strong>  if true show lower case alphabetical\nlabels identifying edge equivalence classes. Defaults to False.</li>\n<li><strong>show_dual_tiles (bool, optional):</strong>  if True show a candidate set of dual\ntiles as an overlay. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>plt.Axes: a plot of the Topology as requested.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">show_original_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_tile_centres</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_vertex_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_vertex_ids</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">offset_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_edge_labels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_dual_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.plot_tiling_symmetries", "modulename": "weavingspace.topology", "qualname": "Topology.plot_tiling_symmetries", "kind": "function", "doc": "<p>Plot the symmetries of Topology's tiling.</p>\n\n<p>Most of the work here is delegated to <code>_plot_tiling_symmetry</code> which is run\nonce per symmetry on a grid of plt.Axes built by this function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>kwargs:</strong>  passed through to <code>_plot_tiling_symmetry</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.transform_geometry", "modulename": "weavingspace.topology", "qualname": "Topology.transform_geometry", "kind": "function", "doc": "<p>Get a new Topology by applying specified transformation.</p>\n\n<p>A transformation specified by <code>transform_type</code> and keyword arguments is\napplied to elements in the Topology whose labels match the selector\nparameter. The transform is optionally applied to update tiles and\noptionally requests a new Topology object.</p>\n\n<p>Implemented in this way so that transformations can be applied one at a time\nwithout creating an intermediate set of new tiles, which may be invalid and\nfail. So, if you wish to apply (say) 3 transforms and generate a new</p>\n\n<h6 id=\"topology-leaving-the-existing-one-intact\">Topology leaving the existing one intact:</h6>\n\n<blockquote>\n  <p>new_topo = old_topo.transform_geometry(True,  False, \"a\", ...) \\\n                     .transform_geometry(False, False, \"B\", ...) \\\n                     .transform_geometry(False, True,  \"C\", ...)</p>\n</blockquote>\n\n<p>The first transform requests a new Topology, subsequent steps do not, and it\nis only the last step which attempts to create the new tile polygons.</p>\n\n<p>**kwargs supply named parameters for the requested transformation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>new_topology (bool):</strong>  if True returns a new Topology object, else returns\nthe current Topology modified.</li>\n<li><strong>apply_to_tiles (bool):</strong>  if True attempts to create new Tiles after the\ntransformation has been applied. Usually set to False, unless the last\ntransformation in a pipeline, to avoid problems of topologically invalid\ntiles at intermediate steps.</li>\n<li><strong>selector (str):</strong>  label of elements to which to apply the transformation.\nNote that all letters in the supplied string are checked, so you can\nuse e.g. \"abc\" to apply a transformation to edges labelled \"a\", \"b\" or\n\"c\", or \"AB\" for vertices labelled \"A\" or \"B\".</li>\n<li><strong>transform_type (str):</strong>  name of the type of transformation requested.\nCurrently supported are <code>zigzag_edge</code>, <code>rotate_edge</code>, <code>scale_edge</code>,\n<code>push_vertex</code>, and <code>nudge_vertex</code>. Keyword arguments for each are\ndocumented in the corresponding methods.</li>\n<li><strong>kwargs:</strong>  contains any needed arguments of the requested transform_type.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Topology: if new_topology is True a new Topology based on this one with\n    after transformation, if False this Topology is returned after the\n    transformation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">new_topology</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_tiles</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">transform_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Topology</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.get_kwargs", "modulename": "weavingspace.topology", "qualname": "Topology.get_kwargs", "kind": "function", "doc": "<p>Filter the supplied kwargs to only contain arguments required by fn.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fn (Callable):</strong>  the function that is to be inspected.</li>\n<li><strong>**kwargs (str|float):</strong>  kwargs to be filtered.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str|float: filtered dictionary of kwargs.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.zigzag_edge", "modulename": "weavingspace.topology", "qualname": "Topology.zigzag_edge", "kind": "function", "doc": "<p>Apply zigzag transformation to supplied Edge.</p>\n\n<p>Currently this will only work correctly if h is even.</p>\n\n<p>TODO: make it possible for odd numbers of 'peaks' to work (this may require\nallowing bidirectional Edges, i.e. storing Edges in both directions so that\nall Tile edges are drawn CW). The <code>start</code> parameter is a temporary hack for\nthis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>edge (Edge):</strong>  Edge to transform</li>\n<li><strong>start (str, optional):</strong>  label at one end of edge which is used to determine\nthe sense of h, enabling C-curves with an odd number n of zigs and zags\nto be applied. Defaults to 'A'.</li>\n<li><strong>n (int, optional):</strong>  number of zigs and zags in the edge. Defaults to 2.</li>\n<li><strong>h (float, optional):</strong>  width of the zig zags relative to edge length.\nDefaults to 0.5.</li>\n<li><strong>smoothness (int, optional):</strong>  spline smoothness. 0 gives a zig zag proper,\nhigher values will produce a sinusoid. Defaults to 0.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;A&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">smoothness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.zigzag_between_points", "modulename": "weavingspace.topology", "qualname": "Topology.zigzag_between_points", "kind": "function", "doc": "<p>Return a zig zag line optionally smoothed as a spline between two points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p0 (geom.Point):</strong>  start point.</li>\n<li><strong>p1 (geom.Point):</strong>  end point.</li>\n<li><strong>n (int):</strong>  number of zig zags.</li>\n<li><strong>h (float, optional):</strong>  amplitude of zig zags relative to distance between\npoints. Defaults to 1.0.</li>\n<li><strong>smoothness (int, optional):</strong>  number of spline smoothed points to add. If\nset to 0 a straight line zig zag is produced. Defaults to 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.LineString: the resulting zig zag line.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p0</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">smoothness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.rotate_edge", "modulename": "weavingspace.topology", "qualname": "Topology.rotate_edge", "kind": "function", "doc": "<p>Rotate edge.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>edge (Edge):</strong>  the edge to rotate.</li>\n<li><strong>centre (str):</strong>  centre of rotation which should be label of one of its\nend point vertices or \"\" when rotation will be about the Edge centroid.\nDefaults to \"\".</li>\n<li><strong>angle (float):</strong>  angle of rotation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span>,</span><span class=\"param\">\t<span class=\"n\">centre</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.scale_edge", "modulename": "weavingspace.topology", "qualname": "Topology.scale_edge", "kind": "function", "doc": "<p>Scale edge.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>edge (Edge):</strong>  the edge to scale.</li>\n<li><strong>sf (float):</strong>  amount by which to scale the edge.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span>, </span><span class=\"param\"><span class=\"n\">sf</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.push_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.push_vertex", "kind": "function", "doc": "<p>Return displacement vector to push a vertex based on incident edges.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vertex (Vertex):</strong>  the vertex to push.</li>\n<li><strong>push_d (float):</strong>  the distance to push it.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">vertex</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">push_d</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Topology.nudge_vertex", "modulename": "weavingspace.topology", "qualname": "Topology.nudge_vertex", "kind": "function", "doc": "<p>Nudge vertex by specified displacement.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vertex (Vertex):</strong>  the vertext to nudge.</li>\n<li><strong>dx (float):</strong>  x displacement.</li>\n<li><strong>dy (float):</strong>  y displacement.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vertex</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>, </span><span class=\"param\"><span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile", "modulename": "weavingspace.topology", "qualname": "Tile", "kind": "class", "doc": "<p>Class to represent essential features of polygons in a tiling.</p>\n"}, {"fullname": "weavingspace.topology.Tile.__init__", "modulename": "weavingspace.topology", "qualname": "Tile.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ID (int):</strong>  sequence number ID of this vertex in the Topology.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ID</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "weavingspace.topology.Tile.ID", "modulename": "weavingspace.topology", "qualname": "Tile.ID", "kind": "variable", "doc": "<p>integer ID number which indexes the Tile in the containing Topology tiles\nlist.</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology.Tile.base_ID", "modulename": "weavingspace.topology", "qualname": "Tile.base_ID", "kind": "variable", "doc": "<p>ID of corresponding Tile in the base tileable unit</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology.Tile.corners", "modulename": "weavingspace.topology", "qualname": "Tile.corners", "kind": "variable", "doc": "<p>list of Vertex objects. This includes all corners of the original polygon\nand any tiling vertices induced by (for example) a the corner of an adjacent\ntile lying halfway along an edge of the original polygon on which this tile\nis based. Vertex objects are stored in strictly clockwise sequence.</p>\n", "annotation": ": list[weavingspace.topology.Vertex]"}, {"fullname": "weavingspace.topology.Tile.edges", "modulename": "weavingspace.topology", "qualname": "Tile.edges", "kind": "variable", "doc": "<p>list of Edge objects that together compose the tile boundary.</p>\n", "annotation": ": list[weavingspace.topology.Edge]"}, {"fullname": "weavingspace.topology.Tile.edges_CW", "modulename": "weavingspace.topology", "qualname": "Tile.edges_CW", "kind": "variable", "doc": "<p>list of Edge direction. Edges are stored only once in a Topology so some\nedges are in clockwise order and others  are in counter-clockwise order.\nThese boolean flags are True if the corresponding Edge is clockwise, False if\ncounter-clockwise.</p>\n", "annotation": ": list[bool]"}, {"fullname": "weavingspace.topology.Tile.label", "modulename": "weavingspace.topology", "qualname": "Tile.label", "kind": "variable", "doc": "<p>tile_id label from the tileable source</p>\n", "annotation": ": str"}, {"fullname": "weavingspace.topology.Tile.vertex_labels", "modulename": "weavingspace.topology", "qualname": "Tile.vertex_labels", "kind": "variable", "doc": "<p>list of (upper case) letter labels of the tile corners (i.e. all corners,\nnot only tiling vertices).</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.topology.Tile.edge_labels", "modulename": "weavingspace.topology", "qualname": "Tile.edge_labels", "kind": "variable", "doc": "<p>list of (lower case) letter labels of the tile edges (tiling edges, not\ntile sides).</p>\n", "annotation": ": list[str]"}, {"fullname": "weavingspace.topology.Tile.shape", "modulename": "weavingspace.topology", "qualname": "Tile.shape", "kind": "variable", "doc": "<p>the tile geometry (which may include some redundant points along sides\nwhere neighbouring tiles induce a tiling vertex). So for example a rectangle\nmight have additional points along its sides:</p>\n\n<pre><code>  +---+-------+\n  |   |   2   |\n  | 1 A---B---E---+\n  |   |   |   4   |\n  +---C 3 D-------+\n      |   |\n      +---+\n</code></pre>\n\n<p>In the above Tile 1 has additional point A, 2 has B and 3 has C and D induced\nby the corners of neighbouring tiles.</p>\n", "annotation": ": shapely.geometry.polygon.Polygon", "default_value": "None"}, {"fullname": "weavingspace.topology.Tile.centre", "modulename": "weavingspace.topology", "qualname": "Tile.centre", "kind": "variable", "doc": "<p>a point centre for the Tile (determined by weavingspace.tiling_utils.\nincentre).</p>\n", "annotation": ": shapely.geometry.point.Point", "default_value": "None"}, {"fullname": "weavingspace.topology.Tile.shape_group", "modulename": "weavingspace.topology", "qualname": "Tile.shape_group", "kind": "variable", "doc": "<p>the tile shape group of this tile in its containing Topology.</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology.Tile.transitivity_class", "modulename": "weavingspace.topology", "qualname": "Tile.transitivity_class", "kind": "variable", "doc": "<p>the tile transitivity class of this tile its containing Topology</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology.Tile.get_corner_IDs", "modulename": "weavingspace.topology", "qualname": "Tile.get_corner_IDs", "kind": "function", "doc": "<p>Return list of corner IDs (not Vertex objects).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[int]: list of integer IDs of tile corners.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_edge_IDs", "modulename": "weavingspace.topology", "qualname": "Tile.get_edge_IDs", "kind": "function", "doc": "<p>Return list of edge IDs (not Edge objects).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[tuple[int]]: list of 2-element tuples of the start and end Vertex IDs\n    of each edge.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.set_shape_from_corners", "modulename": "weavingspace.topology", "qualname": "Tile.set_shape_from_corners", "kind": "function", "doc": "<p>Set the shape attribute based on corners, and associated tile centre.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.set_corners_from_edges", "modulename": "weavingspace.topology", "qualname": "Tile.set_corners_from_edges", "kind": "function", "doc": "<p>Set corners attribute from the edges attribute.</p>\n\n<p>Typically called after modification of topology edges. Optionally the shape\nattribute is NOT updated, which may save time when multiple changes to the\nedges of a tile are in process (i.e., only update the shape after all\nchanges are complete).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>update_shape (bool, optional):</strong>  if True the shape attribute will be\nupdated, otherwise not. Defaults to True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">update_shape</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.set_edge_directions", "modulename": "weavingspace.topology", "qualname": "Tile.set_edge_directions", "kind": "function", "doc": "<p>Set up edges_CW attribute by inspection of the edges list.</p>\n\n<p>It is (frankly!) hard to keep track of the correct sequence of CW/CCW order\nof edges as new ones are created or old ones merged. This method inspects\nthe 'tail-head' relations between consecutive edges to set these flags\ncorrectly.</p>\n\n<p>The test is simply to check if the 'tail' Vertex ID in each edge appears\nin the ID tuple of the following edge, i.e. if successive edge\nIDs are (0, 1) (2, 1) or (0, 1) (1, 2), then edge (0, 1) is in clockwise\ndirection, but if we have (0, 1) (2, 3) then it is not.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.insert_vertex_at", "modulename": "weavingspace.topology", "qualname": "Tile.insert_vertex_at", "kind": "function", "doc": "<p>Insert the Vertex into tile at index position i.</p>\n\n<p>Both corners and edges attributes are updated, and the old edge IDs for\nremoval and the new edge itself are returned to the calling context (the\ncontaining Topology) for update of its edges collection. Optionally update\nthe shape attribute.</p>\n\n<p>This is NOT a generic vertex insertion method: it is only for use during\nTopology initialisation, and does not guarantee correct maintenance of\nall tile, edge and vertex relations in the general case---at any rate it\nhas not been tested for this!</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  the Vertex to insert.</li>\n<li><strong>i (int):</strong>  index position in current corners after which to insert\nsupplied Vertex.</li>\n<li><strong>update_shape (bool, optional):</strong>  if True shape attribute is updated.\nDefaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the (tuple) ID of the old edge which should be deleted, and\n    the new Edges arising from insertion of this Vertex.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">update_shape</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.merge_edges_at_vertex", "modulename": "weavingspace.topology", "qualname": "Tile.merge_edges_at_vertex", "kind": "function", "doc": "<p>Merge edges that meet at the supplied Vertex.</p>\n\n<p>It is assumed that only two tiles are impacted this one, and its neighbour\nacross the Edge on which v lies. Both are updated. For this reason the work\nis delegated to <code>get_updated_edges_from_merge</code> which is run on both affected\ntiles, but only determines the edges to remove and the new edge to be added\nonce. See that method for details.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  Vertex at which to merge Edges. This should currently be an\nend</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: 2 item list of the edge IDs to be removed and a new Edge object to\n    be added by the calling context (i.e. the containing Topology).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_updated_edges_from_merge", "modulename": "weavingspace.topology", "qualname": "Tile.get_updated_edges_from_merge", "kind": "function", "doc": "<p>Update edges and edges_CW attributes based on insertion of Vertex.</p>\n\n<p>If new_edge is supplied then the neighbour tile at v has already created\nthe needed new Edge and this Edge is the one that will be 'slotted in' at\nthe appropriate spot in the edges list.</p>\n\n<p>The edges_CW is also updated to maintain correct directions of the edges.\nThe corners attribute is unaffected by these changes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  existing Vertex at which to carry out the merge.</li>\n<li><strong>new_edge (Edge, optional):</strong>  if another Tile has already carried out this\nmerge this should be the resulting new Edge for insertion into this\nTile. Defaults to None (when the new Edge will be constructed).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None|tuple: either None (if a new edge was supplied) or a tuple\n    of the two edge IDs to be removed and the new edge added for return to\n    the calling context (i.e. the containing Topology).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">new_edge</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_edge_IDs_including_vertex", "modulename": "weavingspace.topology", "qualname": "Tile.get_edge_IDs_including_vertex", "kind": "function", "doc": "<p>Get the (two) index positions of the edges that include supplied Vertex.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  Vertex of interest.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[int]: two index positions of Edges in edges list that contain v.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_merged_edge", "modulename": "weavingspace.topology", "qualname": "Tile.get_merged_edge", "kind": "function", "doc": "<p>Return edge made by merging existing edges at i and j in the edges list.</p>\n\n<p>For example, if the current list of edge IDs was</p>\n\n<pre><code>(0 1 2) (4 2) (4 5) (5 0)\n</code></pre>\n\n<p>and the merge requested is 0 and 1, the resulting new edge is constructed\nfrom vertices (0 1 2 4).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Edge: the requested new Edge.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">j</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.offset_corners", "modulename": "weavingspace.topology", "qualname": "Tile.offset_corners", "kind": "function", "doc": "<p>Shift shape, corners, edges, and edges_CW by an offset amount.</p>\n\n<p>This is used to align tiles that are similar, which is required for correct\ntransfer of 'base' tile labelling on to 'radius 1' tiles during Topology\nconstruction.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>offset (int):</strong>  the number of positions to shift the lists.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_edge_label", "modulename": "weavingspace.topology", "qualname": "Tile.get_edge_label", "kind": "function", "doc": "<p>Return edge label of specified edge.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>e (Edge):</strong>  Edge whose label is required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: requested edge label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.get_corner_label", "modulename": "weavingspace.topology", "qualname": "Tile.get_corner_label", "kind": "function", "doc": "<p>Return corner label of specified corner.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  corner whose label is required.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: requested corner label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Tile.angle_at", "modulename": "weavingspace.topology", "qualname": "Tile.angle_at", "kind": "function", "doc": "<p>Return interior angle at the specified corner (in degrees).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>v (Vertex):</strong>  corner where angle is requested.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: angle at corner v in degrees.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Vertex", "modulename": "weavingspace.topology", "qualname": "Vertex", "kind": "class", "doc": "<p>Class to store attributes of a vertex in a tiling.</p>\n"}, {"fullname": "weavingspace.topology.Vertex.__init__", "modulename": "weavingspace.topology", "qualname": "Vertex.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>point (geom.Point):</strong>  point location of the vertex.</li>\n<li><strong>ID (int):</strong>  a unique integer ID (which will be its key in the containing\nTopology points dictionary).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span><span class=\"p\">:</span> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">Point</span>, </span><span class=\"param\"><span class=\"n\">ID</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "weavingspace.topology.Vertex.point", "modulename": "weavingspace.topology", "qualname": "Vertex.point", "kind": "variable", "doc": "<p>point (geom.Point): point location of the vertex.</p>\n", "annotation": ": shapely.geometry.point.Point"}, {"fullname": "weavingspace.topology.Vertex.ID", "modulename": "weavingspace.topology", "qualname": "Vertex.ID", "kind": "variable", "doc": "<p>integer (mostly but not necessarily in sequence) of vertex keyed into the\npoints dictionary of the containing Topology.</p>\n", "annotation": ": int"}, {"fullname": "weavingspace.topology.Vertex.tiles", "modulename": "weavingspace.topology", "qualname": "Vertex.tiles", "kind": "variable", "doc": "<p>list of Tiles incident on this vertex.</p>\n", "annotation": ": list[weavingspace.topology.Tile]"}, {"fullname": "weavingspace.topology.Vertex.neighbours", "modulename": "weavingspace.topology", "qualname": "Vertex.neighbours", "kind": "variable", "doc": "<p>list of the immediately adjacent other corner IDs. Only required to\ndetermine if a point is a tiling vertex (when it will have) three or more\nneighbours, so only IDs are stored.</p>\n", "annotation": ": list[int]"}, {"fullname": "weavingspace.topology.Vertex.base_ID", "modulename": "weavingspace.topology", "qualname": "Vertex.base_ID", "kind": "variable", "doc": "<p>ID of corresponding Vertex in the tileable base_unit</p>\n", "annotation": ": int", "default_value": "1000000"}, {"fullname": "weavingspace.topology.Vertex.transitivity_class", "modulename": "weavingspace.topology", "qualname": "Vertex.transitivity_class", "kind": "variable", "doc": "<p>transitivity class of the vertex under symmetries of the tiling</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology.Vertex.label", "modulename": "weavingspace.topology", "qualname": "Vertex.label", "kind": "variable", "doc": "<p>the (upper case letter) label of the vertex under the symmetries of the\ntiling.</p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "weavingspace.topology.Vertex.is_tiling_vertex", "modulename": "weavingspace.topology", "qualname": "Vertex.is_tiling_vertex", "kind": "variable", "doc": "<p>is_tiling_vertex (bool): True if this is a tiling vertex, rather than a\ntile corner. E.g., A below is a corner, not a tiling vertex. B is a tiling\nvertex:</p>\n\n<pre><code>+-------+\n| 1     |\n|   A---B---+\n|   | 2     |\n+---C   +---+\n    |   |\n    +---+\n</code></pre>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "weavingspace.topology.Vertex.get_tile_IDs", "modulename": "weavingspace.topology", "qualname": "Vertex.get_tile_IDs", "kind": "function", "doc": "<p>Return list of Tile IDs (not the Tiles themselves).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[int]: list of Tile IDs</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Vertex.add_tile", "modulename": "weavingspace.topology", "qualname": "Vertex.add_tile", "kind": "function", "doc": "<p>Add supplied Tile to the tiles list if it is not already present.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tile (Tile):</strong>  Tile to add.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tile</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Tile</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Vertex.add_neighbour", "modulename": "weavingspace.topology", "qualname": "Vertex.add_neighbour", "kind": "function", "doc": "<p>Add supplied ID to the neighbours list if it is not already present.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vertex_id (int):</strong>  ID to add to the neighbours list.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vertex_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Vertex.clockwise_order_incident_tiles", "modulename": "weavingspace.topology", "qualname": "Vertex.clockwise_order_incident_tiles", "kind": "function", "doc": "<p>Reorder tiles list clockwise (this is for dual tiling construction).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Vertex.is_interior", "modulename": "weavingspace.topology", "qualname": "Vertex.is_interior", "kind": "function", "doc": "<p>Test if vertex is completely enclosed by its incident Tiles.</p>\n\n<p>Based on summing the interior angles of the incident tiles at this vertex.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if vertex is completely enclosed by incident Tiles.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Edge", "modulename": "weavingspace.topology", "qualname": "Edge", "kind": "class", "doc": "<p>Class to represent edges in a tiling (not tile sides).</p>\n"}, {"fullname": "weavingspace.topology.Edge.__init__", "modulename": "weavingspace.topology", "qualname": "Edge.__init__", "kind": "function", "doc": "<p>Class constructor.</p>\n\n<p>Initialises the corners and vertices lists and sets ID to (vertices[0].ID,\nvertices[1].ID). The vertices list is all the corners with is_tiling_vertex\nproperty True -- Note that during initialisation the default of this\nproperty is True until after the relations between tiles and vertices have\nbeen determined.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>corners (list[Vertex]):</strong>  list of all corners along the edge.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">corners</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "weavingspace.topology.Edge.ID", "modulename": "weavingspace.topology", "qualname": "Edge.ID", "kind": "variable", "doc": "<p>IDs of the vertices at ends of the edge. Used as key in the containing\nTopology's edges dictionary.</p>\n", "annotation": ": tuple[int]"}, {"fullname": "weavingspace.topology.Edge.vertices", "modulename": "weavingspace.topology", "qualname": "Edge.vertices", "kind": "variable", "doc": "<p>two item list of the end vertices.</p>\n", "annotation": ": list[weavingspace.topology.Vertex]"}, {"fullname": "weavingspace.topology.Edge.corners", "modulename": "weavingspace.topology", "qualname": "Edge.corners", "kind": "variable", "doc": "<p>list of all the vertices in the edge (including its end vertices). In a\n'normal' edge to edge tiling corners and vertices will be identical.</p>\n", "annotation": ": list[weavingspace.topology.Vertex]"}, {"fullname": "weavingspace.topology.Edge.right_tile", "modulename": "weavingspace.topology", "qualname": "Edge.right_tile", "kind": "variable", "doc": "<p>the tile to the right of the edge traversed from its first to its last\nvertex. Given clockwise winding default, all edges will have a right_tile.</p>\n", "annotation": ": weavingspace.topology.Tile", "default_value": "None"}, {"fullname": "weavingspace.topology.Edge.left_tile", "modulename": "weavingspace.topology", "qualname": "Edge.left_tile", "kind": "variable", "doc": "<p>the tile to the left of the edge traversed from its first to its last\nvertex. Exterior edges of the tiles in a Topology will not have a left_tile.</p>\n", "annotation": ": weavingspace.topology.Tile", "default_value": "None"}, {"fullname": "weavingspace.topology.Edge.base_ID", "modulename": "weavingspace.topology", "qualname": "Edge.base_ID", "kind": "variable", "doc": "<p>ID of corresponding edge in the base tileable</p>\n", "annotation": ": tuple[int]", "default_value": "(1000000, 1000000)"}, {"fullname": "weavingspace.topology.Edge.transitivity_class", "modulename": "weavingspace.topology", "qualname": "Edge.transitivity_class", "kind": "variable", "doc": "<p>transitivity class of the edge under symmetries of the tiling</p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "weavingspace.topology.Edge.label", "modulename": "weavingspace.topology", "qualname": "Edge.label", "kind": "variable", "doc": "<p>the (lower case letter) label of the edge under the symmetries of the\ntiling.</p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "weavingspace.topology.Edge.get_corner_IDs", "modulename": "weavingspace.topology", "qualname": "Edge.get_corner_IDs", "kind": "function", "doc": "<p>Return the IDs of edge corners.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[int]: IDs of all corners.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Edge.get_vertex_IDs", "modulename": "weavingspace.topology", "qualname": "Edge.get_vertex_IDs", "kind": "function", "doc": "<p>Return IDs of edge vertices.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[int]: list of IDs of the vertices.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Edge.insert_vertex", "modulename": "weavingspace.topology", "qualname": "Edge.insert_vertex", "kind": "function", "doc": "<p>Insert vertex after predecessor and return modified edge and new edge.</p>\n\n<p>If the initial edge was (say) (0 1 2 5) and the predecessor was set to 1\nthe returned edges would be (0 1 v) and (v 2 5).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span>,</span><span class=\"param\">\t<span class=\"n\">predecessor</span><span class=\"p\">:</span> <span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Vertex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">weavingspace</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Edge.get_geometry", "modulename": "weavingspace.topology", "qualname": "Edge.get_geometry", "kind": "function", "doc": "<p>Return geom.LineString representing geometry (including corners).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>forward (bool, optional):</strong>  if True the returned LineString starts at\ncorners[0], else at corners[-1]. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.LineString: the required LineString.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">forward</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.topology.Edge.get_topology", "modulename": "weavingspace.topology", "qualname": "Edge.get_topology", "kind": "function", "doc": "<p>Return LineString connecting vertices of this edge.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>forward (bool, optional):</strong>  if True LineString starts at vertices[0],\nelse at vertices[1]. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>geom.LineString: the required LineString.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">forward</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">shapely</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">linestring</span><span class=\"o\">.</span><span class=\"n\">LineString</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices", "modulename": "weavingspace.weave_matrices", "kind": "module", "doc": "<p>Functions to generate the matrices associated with woven patterns.</p>\n\n<p>Such patterns when repeated across a map area give the appearance of a woven\nsurface composed of criss-crossing strands.</p>\n\n<p>Implementation is based on ideas discussed in variously</p>\n\n<p>Glassner A. 2002. Digital weaving. 1. IEEE Computer Graphics and Applications\n22(6):108-118.\nGlassner A. 2003. Digital weaving. 2. IEEE Computer Graphics and Applications\n23(1):77-90.\nGlassner A. 2003. Digital weaving. 3. IEEE Computer Graphics and Applications\n23(2):80-83.</p>\n\n<p>and (unpublished)</p>\n\n<ul>\n<li>Griswold, R. 2006. Mathematical and Computational Topics in Weaving\n<a href=\"https://www2.cs.arizona.edu/patterns/weaving/webdocs/mo/Griswold-MO.pdf\">https://www2.cs.arizona.edu/patterns/weaving/webdocs/mo/Griswold-MO.pdf</a>\n(accessed 29/10/21).</li>\n</ul>\n\n<p>where weaving is shown to be a matrix multiplication of tie-up, threading and\ntreadling matrices. An accessible introduction can be found at\n<a href=\"https://www.youtube.com/watch?v=oMOSiag3dxg\">https://www.youtube.com/watch?v=oMOSiag3dxg</a></p>\n"}, {"fullname": "weavingspace.weave_matrices.reps_needed", "modulename": "weavingspace.weave_matrices", "qualname": "reps_needed", "kind": "function", "doc": "<p>Return number of sequences of length x1 and x2 are needed to match lengths.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x1 (int):</strong>  length of first sequence.</li>\n<li><strong>x2 (int):</strong>  length of second sequence.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[int]: (number of repeats of x1, number of repeats of x2).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">x2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.get_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "get_pattern", "kind": "function", "doc": "<p>Return a 0/1 encoded weave matrix.</p>\n\n<p>Given tie_up, treadling and threading matrices. The following conditions\nmust be satisfied to avoid non-conformable matrix error:</p>\n\n<p>treadling.shape[1] == tie_up.shape[0]\n  tie_up.shape[1] == threading.shape[0]</p>\n\n<p>The \"twill\", \"basket\" and \"plain\" options should guarantee this. If the\nwarp_n and weft_n values are not factors of treadling.shape[0] and\nthreading.shape[1] respectively, the output matrix will be repeated as needed\nto make this match</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tie_up (np.ndarray):</strong>  the tie up matrix.</li>\n<li><strong>treadling (np.ndarray):</strong>  the treadling matrix.</li>\n<li><strong>threading (np.ndarray):</strong>  the threading matrix.</li>\n<li><strong>warp_n (int):</strong>  the number of uniquely labelled warp threads.</li>\n<li><strong>weft_n (int):</strong>  the number of uniquely labelled weft threads.</li>\n<li><strong>rep (int, optional):</strong>  optional additional repetition of the output\napplied in both directions. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the matrix weave pattern generated by the supplied parameters.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">treadling</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">threading</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">rep</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_plain_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_plain_pattern", "kind": "function", "doc": "<p>Return plain weave (checkerboard) matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>warp_n (int, optional):</strong>  number of warp thread labels. Defaults to 1.</li>\n<li><strong>weft_n (int, optional):</strong>  number of weft thread labels. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: 0/1 matrix where 1 = warp on top.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_twill_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_twill_pattern", "kind": "function", "doc": "<p>Return twill pattern matrix extended for warp and weft patterns.</p>\n\n<p>n is the number of over-unders. With n = 1 we get a plain weave.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int|tuple[int], optional):</strong>  specifies over-under sequence in\nthe weave. Defaults to 2.</li>\n<li><strong>warp_n (int, optional):</strong>  number of warp thread labels. Defaults to 2.</li>\n<li><strong>weft_n (int, optional):</strong>  number of weft thread labels. Defaults to 2.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_over_under_row", "modulename": "weavingspace.weave_matrices", "qualname": "make_over_under_row", "kind": "function", "doc": "<p>Return a tuple of runs of 1s and 0s.</p>\n\n<p>Returns a tuple of runs of 1s and 0s per supplied n.</p>\n\n<p>If n is an integer, returned tuple will be a series of n 1s followed by\nn 0s.</p>\n\n<p>If n is a tuple of odd length it will be repeated to produce an even\nlength over-under sequence. This is required to avoid cases such as\ne.g, (1,2,3) -> 100111 which repeated is 1001111001111, i.e. a (2,4)\npattern. Repeating it yields 100111011000 which is the requested pattern.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int|tuple[int]):</strong>  requested over-under sequence. See details.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[int]: list of runs of 1s and 0s in the requested pattern.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.wrap_row", "modulename": "weavingspace.weave_matrices", "qualname": "wrap_row", "kind": "function", "doc": "<p>Wrap the list r by number of positions.</p>\n\n<p>Positive by will shift right.\nNegative shifts left.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>r (list):</strong>  list to wrap.</li>\n<li><strong>by (int, optional):</strong>  number of positions to shift by. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: wrapped list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">by</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_twill_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "make_twill_matrix", "kind": "function", "doc": "<p>Make a twill 0/1 matrix.</p>\n\n<p>Makes a matrix like</p>\n\n<p>1 1 0 0\n  0 1 1 0\n  0 0 1 1\n  1 0 0 1</p>\n\n<p>where the repeat runs in each row are lengths returned by\nmake_over_under_row(n)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>over_under (int|tuple[int]):</strong>  over-under run specification. See\nmake_over_under_row().</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: a matrix of 0s and 1s.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">over_under</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_basket_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_basket_pattern", "kind": "function", "doc": "<p>Return basket pattern matrix extended for warp and weft patterns.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int, optional):</strong>  over under count. Defaults to 2.</li>\n<li><strong>warp_n (int, optional):</strong>  number of warp thread labels. Defaults to 2.</li>\n<li><strong>weft_n (int, optional):</strong>  number of weft thread labels. Defaults to 2.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: _description</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_basket_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "make_basket_matrix", "kind": "function", "doc": "<p>Return a basket weave pattern matrix.</p>\n\n<p>Makes a matrix like</p>\n\n<p>1 1 0 0\n  1 1 0 0\n  0 0 1 1\n  0 0 1 1</p>\n\n<p>where the repeat runs in each row are length n</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int):</strong>  dimension of the 'basket' over-under pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: 0/1 matrix in basket weave pattern.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.make_this_pattern", "modulename": "weavingspace.weave_matrices", "qualname": "make_this_pattern", "kind": "function", "doc": "<p>Pass through returns weave pattern matrix from supplied input.</p>\n\n<p>This is just a pass through function which applies suitable size identity.\nCould try to enforce</p>\n\n<p>treadling.shape[1] == tie_up.shape[0] and\n  tie_up.shape[1] == threading.shape[0]</p>\n\n<p>but unsure what would be an appropriate way to do this...</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tie_up (np.ndarray):</strong>  desired weave pattern.</li>\n<li><strong>threading (np.ndarray):</strong>  desired threading pattern.</li>\n<li><strong>treadling (np.ndarray):</strong>  desired treadling pattern.</li>\n<li><strong>warp_n (int, optional):</strong>  number of warp thread labels. Defaults to 1.</li>\n<li><strong>weft_n (int, optional):</strong>  number of weft thread labels. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: resulting 0/1 weave pattern matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">threading</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">treadling</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">warp_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">weft_n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_matrices.get_weave_pattern_matrix", "modulename": "weavingspace.weave_matrices", "qualname": "get_weave_pattern_matrix", "kind": "function", "doc": "<p>Return encoded weave pattern matrix.</p>\n\n<p>See <code>_encode_biaxial_weave()</code> for the encoding.</p>\n\n<p>Allowed weave_types: \"plain\", \"twill\", \"basket\", and \"this\" (pass-thru).\nThese are explained in the respective functions to which this function\ndelegates construction of the base matrices before applying the encoding.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>weave_type (str, optional):</strong>  one of \"plain\", \"twill\", \"basket\" or\n\"this\". Defaults to \"plain\".</li>\n<li><strong>n (int|tuple[int], optional):</strong>  over under pattern. See\nmake_over_under_row() for details. Defaults to 2.</li>\n<li><strong>warp (list[str]|tuple[str], optional):</strong>  list of labels for warp\nstrands. Defaults to [\"a\", \"b\"].</li>\n<li><strong>weft (list[str]|tuple[str], optional):</strong>  list of labels for weft\nstrands. Defaults to [\"c\", \"d\"].</li>\n<li><strong>tie_up (np.ndarray, optional):</strong>  a weave pattern matrix to pass thru in\nthe \"this\" case. Defaults to make_twill_matrix((2, 2)).</li>\n<li><strong>tr (np.ndarray, optional):</strong>  treadling matrix for the \"this\" case.\nDefaults to None.</li>\n<li><strong>th (np.ndarray, optional):</strong>  threading matrix for the \"this\" case.\nDefaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: encoded weave pattern matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">weave_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;plain&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">warp</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">weft</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;c&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;d&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">tie_up</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">th</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavingspace.weave_unit", "modulename": "weavingspace.weave_unit", "kind": "module", "doc": "<p>The <code>WeaveUnit</code> subclass of <code>weavingspace.tileable.Tileable</code>.</p>\n\n<p>Implements tileable geometric patterns constructed by specifying 2- and 3-axial\nweaves.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <p>Explain usage here...</p>\n</blockquote>\n"}, {"fullname": "weavingspace.weave_unit.WeaveUnit", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit", "kind": "class", "doc": "<p>Extend Tileable to allow for tiles that appear like woven patterns.</p>\n", "bases": "weavingspace.tileable.Tileable"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.__init__", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.weave_type", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.weave_type", "kind": "variable", "doc": "<p>type of weave pattern, one of <code>plain</code>, <code>twill</code>, <code>basket</code>, <code>cube</code>, <code>hex</code> or\n<code>this</code>. Defaults to <code>plain</code>.</p>\n", "annotation": ": str", "default_value": "&#x27;plain&#x27;"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.aspect", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.aspect", "kind": "variable", "doc": "<p>width of strands relative to the <code>spacing</code>. Defaults to 1.0.</p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.n", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.n", "kind": "variable", "doc": "<p>number of over-under strands in biaxial weaves. Only one item is\nrequired in a plain weave. Twill and basket patterns expect an even number of\nentries in the tuple.</p>\n", "annotation": ": int | tuple[int]", "default_value": "(2, 2)"}, {"fullname": "weavingspace.weave_unit.WeaveUnit.strands", "modulename": "weavingspace.weave_unit", "qualname": "WeaveUnit.strands", "kind": "variable", "doc": "<p>specification of the strand labels along each axis. Defaults to <code>a|b|c</code>.</p>\n", "annotation": ": str", "default_value": "&#x27;a|b|c&#x27;"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();