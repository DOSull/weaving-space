<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.tile_map API documentation</title>
<meta name="description" content="Classes for tiling maps. `weavingspace.tile_map.Tiling` and
`weavingspace.tile_map.TiledMap` are exposed in the
public API and
respectively enable …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tile_map</code></h1>
</header>
<section id="section-intro">
<p>Classes for tiling maps. <code><a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code> and
<code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code> are exposed in the
public API and
respectively enable creation of a tiling and plotting of the tiling as a
multivariate map.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.tile_map.TiledMap"><code class="flex name class">
<span>class <span class="ident">TiledMap</span></span>
<span>(</span><span>tiling: <a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a> = None,<br>map: geopandas.geodataframe.GeoDataFrame = None,<br>variables: dict[str, str] = None,<br>colourmaps: dict[str, str | dict] = None,<br>legend: bool = True,<br>legend_zoom: float = 1.0,<br>legend_dx: float = 0.0,<br>legend_dy: float = 0.0,<br>use_ellipse: bool = False,<br>ellipse_magnification: float = 1.0,<br>radial_key: bool = False,<br>draft_mode: bool = False,<br>scheme: str = 'equalinterval',<br>k: int = 100,<br>figsize: tuple[float] = (20, 15),<br>dpi: float = 72)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TiledMap:
  &#34;&#34;&#34;Class representing a tiled map. Should not be accessed directly, but
  will be created by calling `Tiling.get_tiled_map()`. After creation the
  variables and colourmaps attributes can be set, and then
  `TiledMap.render()` called to make a map. Settable attributes are explained
  in documentation of the `TiledMap.render()` method.

  Examples:
    Recommended usage is as follows. First, make a `TiledMap` from a `Tiling` object.

      tm = tiling.get_tiled_map(...)

    Some options in the `Tiling` constructor affect the map appearance. See
    `Tiling` for details.

    Once a `TiledMap` object exists, set options on it, either when calling
    `TiledMap.render()` or explicitly, i.e.

      tm.render(opt1 = val1, opt2 = val2, ...)

    or

      tm.opt1 = val1
      tm.opt2 = val2
      tm.render()

    Option settings are persistent, i.e. unless a new `TiledMap` object is
    created the option settings have to be explicitly reset to default
    values on subsequent calls to `TiledMap.render()`.

    The most important options are the `variables` and `colourmaps`
    settings.

    `variables` is a dictionary mapping `weavingspace.tileable.Tileable`
    tile_ids (usually &#34;a&#34;, &#34;b&#34;, etc.) to variable names in the data. For
    example,

      tm.variables = dict(zip([&#34;a&#34;, &#34;b&#34;], [&#34;population&#34;, &#34;income&#34;]))

    `colourmaps` is a dictionary mapping dataset variable names to the
    matplotlib colourmap to be used for each. For example,

      tm.colourmaps = dict(zip(tm.variables.values(), [&#34;Reds&#34;, &#34;Blues&#34;]))

    See [this notebook](https://github.com/DOSull/weaving-space/blob/main/weavingspace/examples/example-tiles-cairo.ipynb)
    for simple usage.

    TODO: This more complicated example shows how categorical maps can be
    created.
  &#34;&#34;&#34;
  # these will be set at instantion by Tiling.get_tiled_map()
  tiling:Tiling = None
  &#34;&#34;&#34;the Tiling with the required tiles&#34;&#34;&#34;
  map:gpd.GeoDataFrame = None
  &#34;&#34;&#34;the GeoDataFrame on which this map is based&#34;&#34;&#34;
  variables:dict[str,str] = None 
  &#34;&#34;&#34;lookup from tile_id to variable names&#34;&#34;&#34;
  colourmaps:dict[str,Union[str,dict]] = None
  &#34;&#34;&#34;lookup from variables to matplotlib cmaps&#34;&#34;&#34;

  # the below parameters can be set either before calling self.render()
  # or passed in as parameters to self.render()
  # these are solely TiledMap.render() options
  legend:bool = True
  &#34;&#34;&#34;whether or not to show a legend&#34;&#34;&#34;
  legend_zoom:float = 1.0
  &#34;&#34;&#34;&lt;1 zooms out from legend to show more context&#34;&#34;&#34;
  legend_dx:float = 0.
  &#34;&#34;&#34;x shift of legend relative to the map&#34;&#34;&#34;
  legend_dy:float = 0.
  &#34;&#34;&#34;y shift of legend relative to the map&#34;&#34;&#34;
  use_ellipse:bool = False
  &#34;&#34;&#34;if True clips legend with an ellipse&#34;&#34;&#34;
  ellipse_magnification:float = 1.0
  &#34;&#34;&#34;magnification to apply to clip ellipse&#34;&#34;&#34;
  radial_key:bool = False
  &#34;&#34;&#34;if True use radial key even for ordinal/ratio data (normally these will be 
  shown by concentric tile geometries)&#34;&#34;&#34;
  draft_mode:bool = False
  &#34;&#34;&#34;if True plot the map coloured by tile_id&#34;&#34;&#34;

  # the parameters below are geopandas.plot options which we intercept to
  # ensure they are applied appropriately when we plot a GDF
  scheme:str = &#34;equalinterval&#34;
  &#34;&#34;&#34;geopandas scheme to apply&#34;&#34;&#34;
  k:int = 100
  &#34;&#34;&#34;geopandas number of classes to apply&#34;&#34;&#34;
  figsize:tuple[float] = (20, 15)
  &#34;&#34;&#34;maptlotlib figsize&#34;&#34;&#34;
  dpi:float = 72
  &#34;&#34;&#34;dpi for bitmap formats&#34;&#34;&#34;

  def render(self, **kwargs) -&gt; Figure:
    &#34;&#34;&#34;Renders the current state to a map.

    Note that TiledMap objects will usually be created by calling
    `Tiling.get_tiled_map()`.

    Args:
      variables (dict[str,str]): Mapping from tile_id values to
        variable names. Defaults to None.
      colourmaps (dict[str,Union[str,dict]]): Mapping from variable
        names to colour map, either a colour palette as used by
        geopandas/matplotlib, a fixed colour, or a dictionary mapping
        categorical data values to colours. Defaults to None.
      legend (bool): If True a legend will be drawn. Defaults to True.
      legend_zoom (float): Zoom factor to apply to the legend. Values &lt;1
        will show more of the tile context. Defaults to 1.0.
      legend_dx (float): x shift to apply to the legend position.
        Defaults to 0.0.
      legend_dy (float): x and y shift to apply to the legend position.
        Defaults to 0.0.
      use_ellipse (bool): If True applies an elliptical clip to the
        legend. Defaults to False.
      ellipse_magnification (float): Magnification to apply to ellipse
        clipped legend. Defaults to 1.0.
      radial_key (bool): If True legend key for TileUnit maps will be
        based on radially dissecting the tiles. Defaults to False.
      draft_mode (bool): If True a map of the tiled map coloured by
        tile_ids (and with no legend) is returned. Defaults to False.
      scheme (str): passed to geopandas.plot for numeric data. Defaults to
        &#34;equalinterval&#34;.
      k (int): passed to geopandas.plot for numeric data. Defaults to 100.
      figsize (tuple[float,floar]): plot dimensions passed to geopandas.
        plot. Defaults to (20,15).
      dpi (float): passed to pyplot.plot. Defaults to 72.
      **kwargs: other settings to pass to pyplot/geopandas.plot.

    Returns:
      matplotlib.figure.Figure: figure on which map is plotted.
    &#34;&#34;&#34;
    pyplot.rcParams[&#39;pdf.fonttype&#39;] = 42
    pyplot.rcParams[&#39;pdf.use14corefonts&#39;] = True
    matplotlib.rcParams[&#39;pdf.fonttype&#39;] = 42

    to_remove = set()  # keep track of kwargs we use to setup TiledMap
    for k, v in kwargs.items():
      if k in self.__dict__:
        self.__dict__[k] = v
        to_remove.add(k)
    # remove them so we don&#39;t pass them on to pyplot and get errors
    for k in to_remove:
      del kwargs[k]

    if self.draft_mode:
      fig = pyplot.figure(figsize = self.figsize)
      ax = fig.add_subplot(111)
      self.map.plot(ax = ax, column = &#34;tile_id&#34;, cmap = &#34;tab20&#34;,
              **kwargs)
      return fig

    if self.legend:
      # this sizing stuff is rough and ready for now, possibly forever...
      reg_w, reg_h, *_ = \
        tiling_utils.get_width_height_left_bottom(self.map.geometry)
      tile_w, tile_h, *_ = \
        tiling_utils.get_width_height_left_bottom(
          self.tiling.tile_unit._get_legend_tiles().rotate(
            self.tiling.rotation, origin = (0, 0)))
      sf_w, sf_h = reg_w / tile_w / 3, reg_h / tile_h / 3
      gskw = {&#34;height_ratios&#34;: [sf_h * tile_h, reg_h - sf_h * tile_h],
              &#34;width_ratios&#34;: [reg_w, sf_w * tile_w]}

      fig, axes = pyplot.subplot_mosaic(
        [[&#34;map&#34;, &#34;legend&#34;], [&#34;map&#34;, &#34;.&#34;]],
        gridspec_kw = gskw, figsize = self.figsize,
        layout = &#34;constrained&#34;, **kwargs)
    else:
      fig, axes = pyplot.subplots(
        1, 1, figsize = self.figsize,
        layout = &#34;constrained&#34;, **kwargs)

    if self.variables is None:
      # get any floating point columns available
      default_columns = \
        self.map.select_dtypes(
          include = (&#34;float64&#34;, &#34;int64&#34;)).columns
      self.variables = dict(zip(self.map.tile_id.unique(),
                                list(default_columns)))
      print(f&#34;&#34;&#34;No variables specified, picked the first
            {len(self.variables)} numeric ones available.&#34;&#34;&#34;)
    elif isinstance(self.variables, (list, tuple)):
      self.variables = dict(zip(
        self.tiling.tile_unit.tiles.tile_id.unique(),
        self.variables))
      print(f&#34;&#34;&#34;Only a list of variables specified, assigning to
            available tile_ids.&#34;&#34;&#34;)

    if self.colourmaps is None:
      self.colourmaps = {}
      for var in self.variables.values():
        if self.map[var].dtype == pd.CategoricalDtype:
          self.colourmaps[var] = &#34;tab20&#34;
          print(f&#34;&#34;&#34;For categorical data, you should specify colour
              mapping explicitly.&#34;&#34;&#34;)
        else:
          self.colourmaps[var] = &#34;Reds&#34;

    self._plot_map(axes, **kwargs)
    return fig


  def _plot_map(self, axes:pyplot.Axes, **kwargs) -&gt; None:
    &#34;&#34;&#34;Plots map to the supplied axes.

    Args:
      axes (pyplot.Axes): axes on which maps will be drawn.
    &#34;&#34;&#34;
    bb = self.map.geometry.total_bounds
    if self.legend:
      axes[&#34;map&#34;].set_axis_off()
      axes[&#34;map&#34;].set_xlim(bb[0], bb[2])
      axes[&#34;map&#34;].set_ylim(bb[1], bb[3])
      self._plot_subsetted_gdf(axes[&#34;map&#34;], self.map, **kwargs)
      self.plot_legend(ax = axes[&#34;legend&#34;], **kwargs)
      if (self.legend_dx != 0 or self.legend_dx != 0):
        box = axes[&#34;legend&#34;].get_position()
        box.x0 = box.x0 + self.legend_dx
        box.x1 = box.x1 + self.legend_dx
        box.y0 = box.y0 + self.legend_dy
        box.y1 = box.y1 + self.legend_dy
        axes[&#34;legend&#34;].set_position(box)
    else:
      axes.set_axis_off()
      axes.set_xlim(bb[0], bb[2])
      axes.set_ylim(bb[1], bb[3])
      self._plot_subsetted_gdf(axes, self.map, **kwargs)
    return None


  def _plot_subsetted_gdf(self, ax:pyplot.Axes,
                          gdf:gpd.GeoDataFrame, **kwargs) -&gt; None:
    &#34;&#34;&#34;Plots a gpd.GeoDataFrame multiple times based on a subsetting
    attribute (assumed to be &#34;tile_id&#34;).

    NOTE: used to plot both the main map _and_ the legend.

    Args:
      ax (pyplot.Axes): axes to plot to.
      gdf (gpd.GeoDataFrame): the GeoDataFrame to plot.

    Raises:
      Exception: if self.colourmaps cannot be parsed exception is raised.
    &#34;&#34;&#34;
    groups = gdf.groupby(&#34;tile_id&#34;)
    for id, var in self.variables.items():
      subset = groups.get_group(id)
      # Handle custom color assignments via &#39;cmaps&#39; parameter.
      # Result is setting &#39;cmap&#39; variable used in plot command afterwards.
      if (isinstance(self.colourmaps[var], dict)):
        colormap_dict = self.colourmaps[var]
        data_unique_sorted = sorted(subset[var].unique())
        cmap = matplotlib.colors.ListedColormap(
          [colormap_dict[x] for x in data_unique_sorted])
        subset.plot(ax = ax, column = var, cmap = cmap, **kwargs)
      else:
        if (isinstance(self.colourmaps,
                (str, matplotlib.colors.Colormap,
                matplotlib.colors.LinearSegmentedColormap,
                matplotlib.colors.ListedColormap))):
          cmap = self.colourmaps   # one palette for all ids
        elif (len(self.colourmaps) == 0):
          cmap = &#39;Reds&#39;  # set a default... here, to Brewer&#39;s &#39;Reds&#39;
        elif (var not in self.colourmaps):
          cmap = &#39;Reds&#39;  # no color specified in dict, use default
        elif (isinstance(self.colourmaps[var],
                (str, matplotlib.colors.Colormap,
                matplotlib.colors.LinearSegmentedColormap,
                matplotlib.colors.ListedColormap))):
          cmap = self.colourmaps[var]  # specified colors for this var
        else:
          raise Exception(f&#34;&#34;&#34;Color map for &#39;{var}&#39; is not a known
                          type, but is {str(type(self.colourmaps[var]))}&#34;&#34;&#34;)

        subset.plot(ax = ax, column = var, cmap = cmap,
              scheme = self.scheme, k = self.k, **kwargs)


  def to_file(self, fname:str = None) -&gt; None:
    &#34;&#34;&#34;Outputs the tiled map to a layered GPKG file.

    Currently delegates to `weavingspace.tiling_utils.write_map_to_layers()`.

    Args:
      fname (str, optional): Filename to write. Defaults to None.
    &#34;&#34;&#34;
    tiling_utils.write_map_to_layers(self.map, fname)
    return None


  def plot_legend(self, ax: pyplot.Axes = None, **kwargs) -&gt; None:
    &#34;&#34;&#34;Plots a legend for this tiled map.

    Args:
      ax (pyplot.Axes, optional): axes to draw legend. Defaults to None.
    &#34;&#34;&#34;
    # turn off axes (which seems also to make it impossible
    # to set a background colour)
    ax.set_axis_off()

    legend_tiles = self.tiling.tile_unit._get_legend_tiles()
    # this is a bit hacky, but we will apply the rotation to text
    # annotation so for TileUnits which don&#39;t need it, reverse that now
    if isinstance(self.tiling.tile_unit, TileUnit):
      legend_tiles.rotation = -self.tiling.rotation

    legend_key = self._get_legend_key_gdf(legend_tiles)

    legend_tiles.geometry = legend_tiles.geometry.rotate(
      self.tiling.rotation, origin = (0, 0))

    if self.use_ellipse:
      ellipse = tiling_utils.get_bounding_ellipse(
        legend_tiles.geometry, mag = self.ellipse_magnification)
      bb = ellipse.total_bounds
      c = ellipse.unary_union.centroid
    else:
      bb = legend_tiles.geometry.total_bounds
      c = legend_tiles.geometry.unary_union.centroid

    # apply legend zoom - NOTE that this must be applied even
    # if self.legend_zoom is not == 1...
    ax.set_xlim(c.x + (bb[0] - c.x) / self.legend_zoom,
          c.x + (bb[2] - c.x) / self.legend_zoom)
    ax.set_ylim(c.y + (bb[1] - c.y) / self.legend_zoom,
          c.y + (bb[3] - c.y) / self.legend_zoom)

    # plot the legend key tiles (which include the data)
    self._plot_subsetted_gdf(ax, legend_key, lw = 0, **kwargs)

    for id, tile, rotn in zip(self.variables.keys(),
                              legend_tiles.geometry,
                              legend_tiles.rotation):
      c = tile.centroid
      ax.annotate(self.variables[id], xy = (c.x, c.y),
          ha = &#34;center&#34;, va = &#34;center&#34;, rotation_mode = &#34;anchor&#34;,
          # adjust rotation to favour text reading left to right
          rotation = (rotn + self.tiling.rotation + 90) % 180 - 90,
          bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})

    # now plot background; we include the central tiles, since in
    # the weave case these may not match the legend tiles
    context_tiles = self.tiling.tile_unit.get_local_patch(r = 2,
      include_0 = True).geometry.rotate(self.tiling.rotation, origin = (0, 0))
    # for reasons escaping all reason... invalid polygons sometimes show up
    # here I think because of the rotation /shrug... in any case, this
    # sledgehammer should fix it
    # context_tiles = gpd.GeoSeries([g.simplify(1e-6)
    #                                for g in context_tiles.geometry],
    #                 crs = self.tiling.tile_unit.crs)

    if self.use_ellipse:
      context_tiles.clip(ellipse, keep_geom_type = False).plot(
        ax = ax, fc = &#34;#9F9F9F3F&#34;, lw = 0.0)
      tiling_utils.get_tiling_edges(context_tiles.geometry).clip(
        ellipse, keep_geom_type = True).plot(ax = ax, ec = &#34;#5F5F5F&#34;, lw = 1)
    else:
      context_tiles.plot(ax = ax, fc = &#34;#9F9F9F3F&#34;, ec = &#34;#5F5F5F&#34;, lw = 0.0)
      tiling_utils.get_tiling_edges(context_tiles.geometry).plot(
        ax = ax, ec = &#34;#5F5F5F&#34;, lw = 1)


  def _get_legend_key_gdf(self, tiles:gpd.GeoDataFrame) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Returns a GeoDataFrame of tiles dissected and with data assigned 
    to the slice so a map of them can stand as a legend.

    &#39;Dissection&#39; is handled differently by `WeaveUnit` and `TileUnit`
    objects and delegated to either `WeaveUnit._get_legend_key_shapes()`
    or `TileUnit._get_legend_key_shapes()`.

    Args:
      tiles (gpd.GeoDataFrame): the legend tiles.

    Returns:
      gpd.GeoDataFrame:  with tile_id, variables and rotation
        attributes, and geometries of Tileable tiles sliced into a
        colour ramp or set of nested tiles.
    &#34;&#34;&#34;
    key_tiles = []   # set of tiles to form a colour key (e.g. a ramp)
    ids = []         # tile_ids applied to the keys
    unique_ids = []  # list of each tile_id used in order
    vals = []        # the data assigned to the key tiles
    rots = []        # rotation of each key tile
    subsets = self.map.groupby(&#34;tile_id&#34;)
    for (id, var), geom, rot in zip(self.variables.items(),
                 tiles.geometry,
                 tiles.rotation):
      subset = subsets.get_group(id)
      d = subset[var]
      radial = False
      # if the data are categorical then it&#39;s complicated...
      if d.dtype == pd.CategoricalDtype:
        radial = True and self.radial_key
        # desired order of categorical variable is the
        # color maps dictionary keys
        cmap = self.colourmaps[var]
        num_cats = len(cmap)
        val_order = dict(zip(cmap.keys(), range(num_cats)))
        # compile counts of each category
        freqs = [0] * num_cats
        for v in list(d):
          freqs[val_order[v]] += 1
        # make list of the categories containing appropriate
        # counts of each in the order needed using a reverse lookup
        data_vals = list(val_order.keys())
        data_vals = [data_vals[i] for i, f in enumerate(freqs) if f &gt; 0]
      else: # any other data is easy!
        data_vals = sorted(d)
        freqs = [1] * len(data_vals)
      key = self.tiling.tile_unit._get_legend_key_shapes(
        geom, freqs, rot, radial)
      key_tiles.extend(key)
      vals.extend(data_vals)
      n = len(data_vals)
      ids.extend([id] * n)
      unique_ids.append(id)
      rots.extend([rot] * n)
    # finally make up a data table with all the data in all the
    # columns (each set of data only gets used in the subset it
    # applies to). This allows us to reuse the tiling_utils.
    # plot_subsetted_gdf() function
    key_data = {}
    for id in unique_ids:
      key_data[self.variables[id]] = vals

    key_gdf = gpd.GeoDataFrame(
      data = key_data | {&#34;tile_id&#34;: ids, &#34;rotation&#34;: rots},
      crs = self.map.crs,
      geometry = gpd.GeoSeries(key_tiles))
    key_gdf.geometry = key_gdf.rotate(self.tiling.rotation, origin = (0, 0))
    return key_gdf


  def explore(self) -&gt; None:
    &#34;&#34;&#34;TODO: add wrapper to make tiled web map via geopandas.explore.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
<div class="desc"><p>Class representing a tiled map. Should not be accessed directly, but
will be created by calling <code><a title="weavingspace.tile_map.Tiling.get_tiled_map" href="#weavingspace.tile_map.Tiling.get_tiled_map">Tiling.get_tiled_map()</a></code>. After creation the
variables and colourmaps attributes can be set, and then
<code><a title="weavingspace.tile_map.TiledMap.render" href="#weavingspace.tile_map.TiledMap.render">TiledMap.render()</a></code> called to make a map. Settable attributes are explained
in documentation of the <code><a title="weavingspace.tile_map.TiledMap.render" href="#weavingspace.tile_map.TiledMap.render">TiledMap.render()</a></code> method.</p>
<h2 id="examples">Examples</h2>
<p>Recommended usage is as follows. First, make a <code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code> from a <code><a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code> object.</p>
<p>tm = tiling.get_tiled_map(&hellip;)</p>
<p>Some options in the <code><a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code> constructor affect the map appearance. See
<code><a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code> for details.</p>
<p>Once a <code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code> object exists, set options on it, either when calling
<code><a title="weavingspace.tile_map.TiledMap.render" href="#weavingspace.tile_map.TiledMap.render">TiledMap.render()</a></code> or explicitly, i.e.</p>
<p>tm.render(opt1 = val1, opt2 = val2, &hellip;)</p>
<p>or</p>
<p>tm.opt1 = val1
tm.opt2 = val2
tm.render()</p>
<p>Option settings are persistent, i.e. unless a new <code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code> object is
created the option settings have to be explicitly reset to default
values on subsequent calls to <code><a title="weavingspace.tile_map.TiledMap.render" href="#weavingspace.tile_map.TiledMap.render">TiledMap.render()</a></code>.</p>
<p>The most important options are the <code>variables</code> and <code>colourmaps</code>
settings.</p>
<p><code>variables</code> is a dictionary mapping <code><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></code>
tile_ids (usually "a", "b", etc.) to variable names in the data. For
example,</p>
<p>tm.variables = dict(zip(["a", "b"], ["population", "income"]))</p>
<p><code>colourmaps</code> is a dictionary mapping dataset variable names to the
matplotlib colourmap to be used for each. For example,</p>
<p>tm.colourmaps = dict(zip(tm.variables.values(), ["Reds", "Blues"]))</p>
<p>See <a href="https://github.com/DOSull/weaving-space/blob/main/weavingspace/examples/example-tiles-cairo.ipynb">this notebook</a>
for simple usage.</p>
<p>TODO: This more complicated example shows how categorical maps can be
created.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tile_map.TiledMap.colourmaps"><code class="name">var <span class="ident">colourmaps</span> : dict[str, str | dict]</code></dt>
<dd>
<div class="desc"><p>lookup from variables to matplotlib cmaps</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.dpi"><code class="name">var <span class="ident">dpi</span> : float</code></dt>
<dd>
<div class="desc"><p>dpi for bitmap formats</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.draft_mode"><code class="name">var <span class="ident">draft_mode</span> : bool</code></dt>
<dd>
<div class="desc"><p>if True plot the map coloured by tile_id</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.ellipse_magnification"><code class="name">var <span class="ident">ellipse_magnification</span> : float</code></dt>
<dd>
<div class="desc"><p>magnification to apply to clip ellipse</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.figsize"><code class="name">var <span class="ident">figsize</span> : tuple[float]</code></dt>
<dd>
<div class="desc"><p>maptlotlib figsize</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.k"><code class="name">var <span class="ident">k</span> : int</code></dt>
<dd>
<div class="desc"><p>geopandas number of classes to apply</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.legend"><code class="name">var <span class="ident">legend</span> : bool</code></dt>
<dd>
<div class="desc"><p>whether or not to show a legend</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.legend_dx"><code class="name">var <span class="ident">legend_dx</span> : float</code></dt>
<dd>
<div class="desc"><p>x shift of legend relative to the map</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.legend_dy"><code class="name">var <span class="ident">legend_dy</span> : float</code></dt>
<dd>
<div class="desc"><p>y shift of legend relative to the map</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.legend_zoom"><code class="name">var <span class="ident">legend_zoom</span> : float</code></dt>
<dd>
<div class="desc"><p>&lt;1 zooms out from legend to show more context</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.map"><code class="name">var <span class="ident">map</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the GeoDataFrame on which this map is based</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.radial_key"><code class="name">var <span class="ident">radial_key</span> : bool</code></dt>
<dd>
<div class="desc"><p>if True use radial key even for ordinal/ratio data (normally these will be
shown by concentric tile geometries)</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.scheme"><code class="name">var <span class="ident">scheme</span> : str</code></dt>
<dd>
<div class="desc"><p>geopandas scheme to apply</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.tiling"><code class="name">var <span class="ident">tiling</span> : <a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code></dt>
<dd>
<div class="desc"><p>the Tiling with the required tiles</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.use_ellipse"><code class="name">var <span class="ident">use_ellipse</span> : bool</code></dt>
<dd>
<div class="desc"><p>if True clips legend with an ellipse</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.variables"><code class="name">var <span class="ident">variables</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"><p>lookup from tile_id to variable names</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.tile_map.TiledMap.explore"><code class="name flex">
<span>def <span class="ident">explore</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explore(self) -&gt; None:
  &#34;&#34;&#34;TODO: add wrapper to make tiled web map via geopandas.explore.
  &#34;&#34;&#34;
  return None</code></pre>
</details>
<div class="desc"><p>TODO: add wrapper to make tiled web map via geopandas.explore.</p></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.plot_legend"><code class="name flex">
<span>def <span class="ident">plot_legend</span></span>(<span>self, ax: matplotlib.axes._axes.Axes = None, **kwargs) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_legend(self, ax: pyplot.Axes = None, **kwargs) -&gt; None:
  &#34;&#34;&#34;Plots a legend for this tiled map.

  Args:
    ax (pyplot.Axes, optional): axes to draw legend. Defaults to None.
  &#34;&#34;&#34;
  # turn off axes (which seems also to make it impossible
  # to set a background colour)
  ax.set_axis_off()

  legend_tiles = self.tiling.tile_unit._get_legend_tiles()
  # this is a bit hacky, but we will apply the rotation to text
  # annotation so for TileUnits which don&#39;t need it, reverse that now
  if isinstance(self.tiling.tile_unit, TileUnit):
    legend_tiles.rotation = -self.tiling.rotation

  legend_key = self._get_legend_key_gdf(legend_tiles)

  legend_tiles.geometry = legend_tiles.geometry.rotate(
    self.tiling.rotation, origin = (0, 0))

  if self.use_ellipse:
    ellipse = tiling_utils.get_bounding_ellipse(
      legend_tiles.geometry, mag = self.ellipse_magnification)
    bb = ellipse.total_bounds
    c = ellipse.unary_union.centroid
  else:
    bb = legend_tiles.geometry.total_bounds
    c = legend_tiles.geometry.unary_union.centroid

  # apply legend zoom - NOTE that this must be applied even
  # if self.legend_zoom is not == 1...
  ax.set_xlim(c.x + (bb[0] - c.x) / self.legend_zoom,
        c.x + (bb[2] - c.x) / self.legend_zoom)
  ax.set_ylim(c.y + (bb[1] - c.y) / self.legend_zoom,
        c.y + (bb[3] - c.y) / self.legend_zoom)

  # plot the legend key tiles (which include the data)
  self._plot_subsetted_gdf(ax, legend_key, lw = 0, **kwargs)

  for id, tile, rotn in zip(self.variables.keys(),
                            legend_tiles.geometry,
                            legend_tiles.rotation):
    c = tile.centroid
    ax.annotate(self.variables[id], xy = (c.x, c.y),
        ha = &#34;center&#34;, va = &#34;center&#34;, rotation_mode = &#34;anchor&#34;,
        # adjust rotation to favour text reading left to right
        rotation = (rotn + self.tiling.rotation + 90) % 180 - 90,
        bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})

  # now plot background; we include the central tiles, since in
  # the weave case these may not match the legend tiles
  context_tiles = self.tiling.tile_unit.get_local_patch(r = 2,
    include_0 = True).geometry.rotate(self.tiling.rotation, origin = (0, 0))
  # for reasons escaping all reason... invalid polygons sometimes show up
  # here I think because of the rotation /shrug... in any case, this
  # sledgehammer should fix it
  # context_tiles = gpd.GeoSeries([g.simplify(1e-6)
  #                                for g in context_tiles.geometry],
  #                 crs = self.tiling.tile_unit.crs)

  if self.use_ellipse:
    context_tiles.clip(ellipse, keep_geom_type = False).plot(
      ax = ax, fc = &#34;#9F9F9F3F&#34;, lw = 0.0)
    tiling_utils.get_tiling_edges(context_tiles.geometry).clip(
      ellipse, keep_geom_type = True).plot(ax = ax, ec = &#34;#5F5F5F&#34;, lw = 1)
  else:
    context_tiles.plot(ax = ax, fc = &#34;#9F9F9F3F&#34;, ec = &#34;#5F5F5F&#34;, lw = 0.0)
    tiling_utils.get_tiling_edges(context_tiles.geometry).plot(
      ax = ax, ec = &#34;#5F5F5F&#34;, lw = 1)</code></pre>
</details>
<div class="desc"><p>Plots a legend for this tiled map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>pyplot.Axes</code>, optional</dt>
<dd>axes to draw legend. Defaults to None.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, **kwargs) ‑> matplotlib.figure.Figure</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, **kwargs) -&gt; Figure:
  &#34;&#34;&#34;Renders the current state to a map.

  Note that TiledMap objects will usually be created by calling
  `Tiling.get_tiled_map()`.

  Args:
    variables (dict[str,str]): Mapping from tile_id values to
      variable names. Defaults to None.
    colourmaps (dict[str,Union[str,dict]]): Mapping from variable
      names to colour map, either a colour palette as used by
      geopandas/matplotlib, a fixed colour, or a dictionary mapping
      categorical data values to colours. Defaults to None.
    legend (bool): If True a legend will be drawn. Defaults to True.
    legend_zoom (float): Zoom factor to apply to the legend. Values &lt;1
      will show more of the tile context. Defaults to 1.0.
    legend_dx (float): x shift to apply to the legend position.
      Defaults to 0.0.
    legend_dy (float): x and y shift to apply to the legend position.
      Defaults to 0.0.
    use_ellipse (bool): If True applies an elliptical clip to the
      legend. Defaults to False.
    ellipse_magnification (float): Magnification to apply to ellipse
      clipped legend. Defaults to 1.0.
    radial_key (bool): If True legend key for TileUnit maps will be
      based on radially dissecting the tiles. Defaults to False.
    draft_mode (bool): If True a map of the tiled map coloured by
      tile_ids (and with no legend) is returned. Defaults to False.
    scheme (str): passed to geopandas.plot for numeric data. Defaults to
      &#34;equalinterval&#34;.
    k (int): passed to geopandas.plot for numeric data. Defaults to 100.
    figsize (tuple[float,floar]): plot dimensions passed to geopandas.
      plot. Defaults to (20,15).
    dpi (float): passed to pyplot.plot. Defaults to 72.
    **kwargs: other settings to pass to pyplot/geopandas.plot.

  Returns:
    matplotlib.figure.Figure: figure on which map is plotted.
  &#34;&#34;&#34;
  pyplot.rcParams[&#39;pdf.fonttype&#39;] = 42
  pyplot.rcParams[&#39;pdf.use14corefonts&#39;] = True
  matplotlib.rcParams[&#39;pdf.fonttype&#39;] = 42

  to_remove = set()  # keep track of kwargs we use to setup TiledMap
  for k, v in kwargs.items():
    if k in self.__dict__:
      self.__dict__[k] = v
      to_remove.add(k)
  # remove them so we don&#39;t pass them on to pyplot and get errors
  for k in to_remove:
    del kwargs[k]

  if self.draft_mode:
    fig = pyplot.figure(figsize = self.figsize)
    ax = fig.add_subplot(111)
    self.map.plot(ax = ax, column = &#34;tile_id&#34;, cmap = &#34;tab20&#34;,
            **kwargs)
    return fig

  if self.legend:
    # this sizing stuff is rough and ready for now, possibly forever...
    reg_w, reg_h, *_ = \
      tiling_utils.get_width_height_left_bottom(self.map.geometry)
    tile_w, tile_h, *_ = \
      tiling_utils.get_width_height_left_bottom(
        self.tiling.tile_unit._get_legend_tiles().rotate(
          self.tiling.rotation, origin = (0, 0)))
    sf_w, sf_h = reg_w / tile_w / 3, reg_h / tile_h / 3
    gskw = {&#34;height_ratios&#34;: [sf_h * tile_h, reg_h - sf_h * tile_h],
            &#34;width_ratios&#34;: [reg_w, sf_w * tile_w]}

    fig, axes = pyplot.subplot_mosaic(
      [[&#34;map&#34;, &#34;legend&#34;], [&#34;map&#34;, &#34;.&#34;]],
      gridspec_kw = gskw, figsize = self.figsize,
      layout = &#34;constrained&#34;, **kwargs)
  else:
    fig, axes = pyplot.subplots(
      1, 1, figsize = self.figsize,
      layout = &#34;constrained&#34;, **kwargs)

  if self.variables is None:
    # get any floating point columns available
    default_columns = \
      self.map.select_dtypes(
        include = (&#34;float64&#34;, &#34;int64&#34;)).columns
    self.variables = dict(zip(self.map.tile_id.unique(),
                              list(default_columns)))
    print(f&#34;&#34;&#34;No variables specified, picked the first
          {len(self.variables)} numeric ones available.&#34;&#34;&#34;)
  elif isinstance(self.variables, (list, tuple)):
    self.variables = dict(zip(
      self.tiling.tile_unit.tiles.tile_id.unique(),
      self.variables))
    print(f&#34;&#34;&#34;Only a list of variables specified, assigning to
          available tile_ids.&#34;&#34;&#34;)

  if self.colourmaps is None:
    self.colourmaps = {}
    for var in self.variables.values():
      if self.map[var].dtype == pd.CategoricalDtype:
        self.colourmaps[var] = &#34;tab20&#34;
        print(f&#34;&#34;&#34;For categorical data, you should specify colour
            mapping explicitly.&#34;&#34;&#34;)
      else:
        self.colourmaps[var] = &#34;Reds&#34;

  self._plot_map(axes, **kwargs)
  return fig</code></pre>
</details>
<div class="desc"><p>Renders the current state to a map.</p>
<p>Note that TiledMap objects will usually be created by calling
<code><a title="weavingspace.tile_map.Tiling.get_tiled_map" href="#weavingspace.tile_map.Tiling.get_tiled_map">Tiling.get_tiled_map()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong> :&ensp;<code>dict[str,str]</code></dt>
<dd>Mapping from tile_id values to
variable names. Defaults to None.</dd>
<dt><strong><code>colourmaps</code></strong> :&ensp;<code>dict[str,Union[str,dict]]</code></dt>
<dd>Mapping from variable
names to colour map, either a colour palette as used by
geopandas/matplotlib, a fixed colour, or a dictionary mapping
categorical data values to colours. Defaults to None.</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True a legend will be drawn. Defaults to True.</dd>
<dt><strong><code>legend_zoom</code></strong> :&ensp;<code>float</code></dt>
<dd>Zoom factor to apply to the legend. Values &lt;1
will show more of the tile context. Defaults to 1.0.</dd>
<dt><strong><code>legend_dx</code></strong> :&ensp;<code>float</code></dt>
<dd>x shift to apply to the legend position.
Defaults to 0.0.</dd>
<dt><strong><code>legend_dy</code></strong> :&ensp;<code>float</code></dt>
<dd>x and y shift to apply to the legend position.
Defaults to 0.0.</dd>
<dt><strong><code>use_ellipse</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True applies an elliptical clip to the
legend. Defaults to False.</dd>
<dt><strong><code>ellipse_magnification</code></strong> :&ensp;<code>float</code></dt>
<dd>Magnification to apply to ellipse
clipped legend. Defaults to 1.0.</dd>
<dt><strong><code>radial_key</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True legend key for TileUnit maps will be
based on radially dissecting the tiles. Defaults to False.</dd>
<dt><strong><code>draft_mode</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True a map of the tiled map coloured by
tile_ids (and with no legend) is returned. Defaults to False.</dd>
<dt><strong><code>scheme</code></strong> :&ensp;<code>str</code></dt>
<dd>passed to geopandas.plot for numeric data. Defaults to
"equalinterval".</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>passed to geopandas.plot for numeric data. Defaults to 100.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple[float,floar]</code></dt>
<dd>plot dimensions passed to geopandas.
plot. Defaults to (20,15).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>float</code></dt>
<dd>passed to pyplot.plot. Defaults to 72.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>other settings to pass to pyplot/geopandas.plot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.figure.Figure</code></dt>
<dd>figure on which map is plotted.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tile_map.TiledMap.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, fname: str = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, fname:str = None) -&gt; None:
  &#34;&#34;&#34;Outputs the tiled map to a layered GPKG file.

  Currently delegates to `weavingspace.tiling_utils.write_map_to_layers()`.

  Args:
    fname (str, optional): Filename to write. Defaults to None.
  &#34;&#34;&#34;
  tiling_utils.write_map_to_layers(self.map, fname)
  return None</code></pre>
</details>
<div class="desc"><p>Outputs the tiled map to a layered GPKG file.</p>
<p>Currently delegates to <code><a title="weavingspace.tiling_utils.write_map_to_layers" href="tiling_utils.html#weavingspace.tiling_utils.write_map_to_layers">write_map_to_layers()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filename to write. Defaults to None.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.tile_map.Tiling"><code class="flex name class">
<span>class <span class="ident">Tiling</span></span>
<span>(</span><span>unit: <a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a>,<br>region: geopandas.geodataframe.GeoDataFrame,<br>id_var=None,<br>prototile_margin: float = 0,<br>tiles_sf: float = 1,<br>tiles_margin: float = 0,<br>as_icons: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Tiling:
  &#34;&#34;&#34;Class that applies a `Tileable` object to a region to be mapped.

  The result of the tiling procedure is stored in the `tiles` variable and
  covers a region sufficient that the tiling can be rotated to any desired
  angle.
  &#34;&#34;&#34;
  tile_unit:Tileable = None
  &#34;&#34;&#34;tileable on which the tiling is based.&#34;&#34;&#34;
  tile_shape:TileShape = None
  &#34;&#34;&#34;base shape of the tileable.&#34;&#34;&#34;
  region:gpd.GeoDataFrame = None
  &#34;&#34;&#34;the region to be tiled.&#34;&#34;&#34;
  region_union: geom.Polygon = None
  grid:_TileGrid = None
  &#34;&#34;&#34;the grid which will be used to apply the tiling.&#34;&#34;&#34;
  tiles:gpd.GeoDataFrame = None
  &#34;&#34;&#34;the tiles after tiling has been carried out.&#34;&#34;&#34;
  prototiles:gpd.GeoDataFrame = None
  &#34;&#34;&#34;the prototiles after tiling has been carried out.&#34;&#34;&#34;
  rotation:float = 0.0
  &#34;&#34;&#34;the cumulative rotation already applied to the tiling.&#34;&#34;&#34;

  def __init__(self, unit:Tileable, region:gpd.GeoDataFrame, id_var = None,
         prototile_margin:float = 0, tiles_sf:float = 1,
         tiles_margin:float = 0, as_icons:bool = False) -&gt; None:
    &#34;&#34;&#34;Class to persist a tiling by filling an area relative to
    a region sufficient to apply the tiling at any rotation.

    The Tiling constructor allows a number of adjustments to the supplied
    `weavingspace.tileable.Tileable` object:

    + `prototile_margin` values greater than 0 will introduce spacing of
    the specified distance between tiles on the boundary of each tile
    by applying the `TileUnit.inset_prototile()` method. Note that this
    operation does not make sense for `WeaveUnit` objects,
    and may not preserve the equality of tile areas.
    + `tiles_sf` values less than one scale down tiles by applying the 
    `TileUnit.scale_tiles()` method. Does not make sense for `WeaveUnit` 
    objects.
    + `tiles_margin` values greater than one apply a negative buffer of
    the specified distance to every tile in the tiling by applying the
    `Tileable.inset_tiles()` method. This option is applicable to both
    `WeaveUnit` and `TileUnit` objects.

    Args:
      unit (Tileable): the tile_unit to use.
      region (gpd.GeoDataFrame): the region to be tiled.
      prototile_margin (float, optional): values greater than 0 apply an
        inset margin to the tile unit. Defaults to 0.
      tiles_sf (float, optional): scales the tiles. Defaults to 1.
      tiles_margin (float, optional): applies a negative buffer to
        the tiles. Defaults to 0.
      as_icons (bool, optional): if True prototiles will only be placed at
        the region&#39;s zone centroids, one per zone. Defaults to
        False.
    &#34;&#34;&#34;
    self.tile_unit = unit
    self.rotation = self.tile_unit.rotation
    if tiles_margin &gt; 0:
      self.tile_unit = self.tile_unit.inset_tiles(tiles_margin)
    if tiles_sf != 1:
      if isinstance(self.tile_unit, TileUnit):
        self.tile_unit = self.tile_unit.scale_tiles(tiles_sf)
      else:
        print(f&#34;&#34;&#34;Applying scaling to tiles of a WeaveUnit does not make sense. 
              Ignoring tiles_sf setting of {tiles_sf}.&#34;&#34;&#34;)
    if prototile_margin &gt; 0:
      if isinstance(self.tile_unit, TileUnit):
        self.tile_unit = self.tile_unit.inset_prototile(prototile_margin)
      else:
        print(f&#34;&#34;&#34;Applying a prototile margin to a WeaveUnit does 
              not make sense. Ignoring prototile_margin setting of
              {prototile_margin}.&#34;&#34;&#34;)
    self.region = region
    self.region.sindex
    self.region_union = self.region.geometry.unary_union
    if id_var != None:
      print(&#34;&#34;&#34;id_var is no longer required and will be deprecated soon.
            A temporary unique index attribute is added and removed when 
            generating the tiled map.&#34;&#34;&#34;)
    if as_icons:
      self.grid = _TileGrid(self.tile_unit, self.region.geometry, True)
    else:
      self.grid = _TileGrid(self.tile_unit, self.region.geometry)
    self.tiles, self.prototiles = self.make_tiling()
    self.tiles.sindex


  def get_tiled_map(self, rotation:float = 0.,
                    join_on_prototiles:bool = True,
                    prioritise_tiles:bool = True,
                    ragged_edges:bool = True,
                    use_centroid_lookup_approximation = False,
                    debug = False) -&gt; &#34;TiledMap&#34;:
    &#34;&#34;&#34;Returns a `TiledMap` filling a region at the requested rotation.

    HERE BE DRAGONS! This function took a lot of trial and error to get
    right, so modify with CAUTION!

    The `proritise_tiles = True` option means that the tiling will not
    break up the tiles in `TileUnit`s at the boundaries between areas
    in the mapped region, but will instead ensure that tiles remain
    complete, picking up their data from the region zone which they overlap
    the most.
    
    The exact order in which operations are performed affects performance.
    For example, the final clipping to self.region when ragged_edges =
    False is _much_ slower if it is carried out before the dissolving of
    tiles into the region zones. So... again... modify CAREFULLY!

    Args:
      rotation (float, optional): An optional rotation to apply. Defaults
        to 0.
      join_on_prototiles (bool, optional): if True data from the region
        dataset are joined to tiles based on the prototile to which they
        belong. If False the join is based on the tiles in relation to the
        region areas. For weave-based tilings False is probably to be
        preferred. Defaults to True.
      prioritise_tiles (bool, optional): if True tiles will not be
        broken at boundaries in the region dataset. Defaults to True.
      ragged_edges (bool, optional): if True tiles at the edge of the
        region will not be cut by the region extent - ignored if
        prioritise_tiles is False when edges will always be clipped to
        the region extent. Defaults to True.
      use_centroid_lookup_approximation (bool, optional): if True use
        tile centroids for lookup of region data - ignored if
        prioritise_tiles is False when it is irrelevant. Defaults to
        False.
      debug (bool, optional): if True prints timing messages. Defaults
        to False.

    Returns:
      TiledMap: a TiledMap of the source region.
    &#34;&#34;&#34;
    if debug:
      t1 = perf_counter()

    id_var = self._setup_region_DZID()
    if join_on_prototiles:
      tiled_map, join_layer = self.rotated(rotation)
      tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;prototile_id&#34;]
    else:
      tiled_map = self.rotated(rotation)[0]
      tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;tile_id&#34;]
      join_layer = tiled_map
    join_layer[&#34;joinUID&#34;] = list(range(join_layer.shape[0]))

    # compile a list of the variable names we are NOT going to change
    # i.e. everything except the geometry and the id_var
    region_vars = list(self.region.columns)
    region_vars.remove(&#34;geometry&#34;)
    region_vars.remove(id_var)

    if debug:
      t2 = perf_counter()
      print(f&#34;STEP 1: prep data (rotation if requested): {t2 - t1:.3f}&#34;)

    if prioritise_tiles:  # maintain tile continuity across zone boundaries
      # select only tiles inside a spacing buffer of the region
      # make column with unique ID for every tile in the tiling
      # the join ID is unique per tile
      # if join_on_prototiles:
      #   tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;prototile_id&#34;]
      # else:
      #   tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;tile_id&#34;]
 
      if use_centroid_lookup_approximation:
        t5 = perf_counter()
        tile_pts = copy.deepcopy(join_layer)
        tile_pts.geometry = tile_pts.centroid
        lookup = tile_pts.sjoin(
          self.region, how = &#34;inner&#34;)[[&#34;joinUID&#34;, id_var]]
      else:
        # determine areas of overlapping tiles and drop the data we join the 
        # data back later, so dropping makes that easier overlaying in region.
        # overlay(tiles) seems to be faster??
        # TODO: also... this part is performance-critical, think about fixes -- 
        # possibly including the above centroid-based approx
        overlaps = self.region.overlay(join_layer, make_valid = False)
        # overlaps = self.region.overlay(tiled_map, make_valid = False)
        if debug:
          t3 = perf_counter()
          print(f&#34;STEP A2: overlay zones with tiling: {t3 - t2:.3f}&#34;)
        overlaps[&#34;area&#34;] = overlaps.geometry.area
        if debug:
          t4 = perf_counter()
          print(f&#34;STEP A3: calculate areas: {t4 - t3:.3f}&#34;)
        overlaps.drop(columns = region_vars, inplace = True)
        if debug:
          t5 = perf_counter()
          print(f&#34;STEP A4: drop columns prior to join: {t5 - t4:.3f}&#34;)
        # make a lookup by largest area tile to region id
        lookup = overlaps \
          .iloc[overlaps.groupby(&#34;joinUID&#34;)[&#34;area&#34;] \
          .agg(pd.Series.idxmax)][[&#34;joinUID&#34;, id_var]]
      # now join the lookup and from there the region data
      if debug:
        t6 = perf_counter()
        print(f&#34;STEP A5: build lookup for join: {t6 - t5:.3f}&#34;)
      tiled_map = tiled_map \
        .merge(lookup, on = &#34;joinUID&#34;) \
        .merge(self.region.drop(columns = [&#34;geometry&#34;]), on = id_var)
      if debug:
        t7 = perf_counter()
        print(f&#34;STEP A6: perform lookup join: {t7 - t6:.3f}&#34;)
      tiled_map.drop(columns = [&#34;joinUID&#34;], inplace = True)

    else:  # here we overlay
      tiled_map = self.region.overlay(tiled_map)
      t7 = perf_counter()
      if debug:
        print(f&#34;STEP B2: overlay tiling with zones: {t7 - t2:.3f}&#34;)

    if join_on_prototiles:
      tiled_map = tiled_map.loc[
        shapely.intersects(self.region_union, np.array(tiled_map.geometry)), :]

    tiled_map.drop(columns = [id_var], inplace = True)
    self.region.drop(columns = [id_var], inplace = True)

    # if we&#39;ve retained tiles and want &#39;clean&#39; edges, then clip
    # note that this step is slow: geopandas unary_unions the clip layer
    if prioritise_tiles and not ragged_edges:
      tiled_map.sindex
      tiled_map = tiled_map.clip(self.region)
      if debug:
        print(f&#34;&#34;&#34;STEP A7/B3: clip map to region: {perf_counter() - t7:.3f}&#34;&#34;&#34;)

    tm = TiledMap()
    tm.tiling = self
    tm.map = tiled_map
    return tm


  def _setup_region_DZID(self) -&gt; str:
    &#34;&#34;&#34;Creates a new guaranteed-unique attribute in the self.region
    dataframe, and returns its name.

    Avoids a name clash with any existing attribute in the dataframe.

    Returns:
      str: name of the added attribute.
    &#34;&#34;&#34;
    dzid = &#34;DZID&#34;
    i = 0
    while dzid in self.region.columns:
      dzid = &#34;DZID&#34; + str(i)
      i = i + 1
    self.region[dzid] = list(range(self.region.shape[0]))
    return dzid


  def _rotate_gdf_to_geoseries(
      self, gdf:gpd.GeoDataFrame,
      angle:float, centre:tuple = (0, 0)
    ) -&gt; tuple[gpd.GeoSeries, tuple[float]]:
    &#34;&#34;&#34;Rotates the geometries in a GeoDataFrame as a single collection.

    Rotation is about the supplied centre or about the centroid of the
    GeoDataFrame (if not). This allows for reversal of  a rotation. [Note
    that this might not be a required precaution!]

    Args:
      gdf (geopandas.GeoDataFrame): GeoDataFrame to rotate
      angle (float): angle of rotation (degrees).
      centre (tuple, optional): desired centre of rotation. Defaults
        to (0, 0).

    Returns:
      tuple: a geopandas.GeoSeries and a tuple (point) of the centre of
        the rotation.
    &#34;&#34;&#34;
    centre = (
      gdf.geometry.unary_union.centroid.coords[0]
      if centre is None
      else centre)
    return gdf.geometry.rotate(angle, origin = centre), centre


  def make_tiling(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Tiles the region with a tile unit, returning a GeoDataFrame

    Returns:
      geopandas.GeoDataFrame: a GeoDataFrame of the region tiled with the
        tile unit.
    &#34;&#34;&#34;
    # we assume the geometry column is called geometry so make it so...
    if self.region.geometry.name != &#34;geometry&#34;:
      self.region.rename_geometry(&#34;geometry&#34;, inplace = True)

    # chain list of lists of GeoSeries geometries to list of geometries
    tiles = itertools.chain(*[
      self.tile_unit.tiles.geometry.translate(p.x, p.y)
      for p in self.grid.points])
    prototiles = itertools.chain(*[
      self.tile_unit.prototile.geometry.translate(p.x, p.y)
      for p in self.grid.points])
    # replicate the tile ids
    prototile_ids = list(range(len(self.grid.points)))
    tile_ids = list(self.tile_unit.tiles.tile_id) * len(self.grid.points)
    tile_prototile_ids = sorted(prototile_ids * self.tile_unit.tiles.shape[0])
    tiles_gs = gpd.GeoSeries(tiles)
    prototiles_gs = gpd.GeoSeries(prototiles)
    # assemble and return as GeoDataFrames
    tiles_gdf = gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: tile_ids, &#34;prototile_id&#34;: tile_prototile_ids},
      geometry = tiles_gs, crs = self.tile_unit.crs)
    prototiles_gdf = gpd.GeoDataFrame(
      data = {&#34;prototile_id&#34;: prototile_ids},
      geometry = prototiles_gs, crs = self.tile_unit.crs)
    # unclear if we need the gridify or not...
    return (tiling_utils.gridify(tiles_gdf),
            tiling_utils.gridify(prototiles_gdf))


  def rotated(self, rotation:float = None) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Returns the stored tiling rotated.

    Args:
      rotation (float, optional): Rotation angle in degrees.
        Defaults to None.

    Returns:
      gpd.GeoDataFrame: Rotated tiling.
    &#34;&#34;&#34;
    if self.tiles is None:
      self.tiles = self.make_tiling()
    self.rotation = rotation
    if self.rotation == 0:
      return self.tiles, self.prototiles
    tiles = gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: self.tiles.tile_id,
              &#34;prototile_id&#34;: self.tiles.tile_id},
      crs = self.tiles.crs,
      geometry = tiling_utils.gridify(
        self.tiles.geometry.rotate(rotation, origin = self.grid.centre)))
    prototiles = gpd.GeoDataFrame(
      data = {&#34;prototile_id&#34;: self.prototiles.prototile_id},
      crs = self.prototiles.crs,
      geometry = tiling_utils.gridify(
        self.prototiles.geometry.rotate(rotation, origin = self.grid.centre)))
    return tiles, prototiles</code></pre>
</details>
<div class="desc"><p>Class that applies a <code>Tileable</code> object to a region to be mapped.</p>
<p>The result of the tiling procedure is stored in the <code>tiles</code> variable and
covers a region sufficient that the tiling can be rotated to any desired
angle.</p>
<p>Class to persist a tiling by filling an area relative to
a region sufficient to apply the tiling at any rotation.</p>
<p>The Tiling constructor allows a number of adjustments to the supplied
<code><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></code> object:</p>
<ul>
<li><code>prototile_margin</code> values greater than 0 will introduce spacing of
the specified distance between tiles on the boundary of each tile
by applying the <code>TileUnit.inset_prototile()</code> method. Note that this
operation does not make sense for <code>WeaveUnit</code> objects,
and may not preserve the equality of tile areas.</li>
<li><code>tiles_sf</code> values less than one scale down tiles by applying the
<code>TileUnit.scale_tiles()</code> method. Does not make sense for <code>WeaveUnit</code>
objects.</li>
<li><code>tiles_margin</code> values greater than one apply a negative buffer of
the specified distance to every tile in the tiling by applying the
<code>Tileable.inset_tiles()</code> method. This option is applicable to both
<code>WeaveUnit</code> and <code>TileUnit</code> objects.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>Tileable</code></dt>
<dd>the tile_unit to use.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the region to be tiled.</dd>
<dt><strong><code>prototile_margin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>values greater than 0 apply an
inset margin to the tile unit. Defaults to 0.</dd>
<dt><strong><code>tiles_sf</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>scales the tiles. Defaults to 1.</dd>
<dt><strong><code>tiles_margin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>applies a negative buffer to
the tiles. Defaults to 0.</dd>
<dt><strong><code>as_icons</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True prototiles will only be placed at
the region's zone centroids, one per zone. Defaults to
False.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tile_map.Tiling.grid"><code class="name">var <span class="ident">grid</span> : weavingspace.tile_map._TileGrid</code></dt>
<dd>
<div class="desc"><p>the grid which will be used to apply the tiling.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.prototiles"><code class="name">var <span class="ident">prototiles</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the prototiles after tiling has been carried out.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.region"><code class="name">var <span class="ident">region</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the region to be tiled.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.region_union"><code class="name">var <span class="ident">region_union</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.rotation"><code class="name">var <span class="ident">rotation</span> : float</code></dt>
<dd>
<div class="desc"><p>the cumulative rotation already applied to the tiling.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.tile_shape"><code class="name">var <span class="ident">tile_shape</span> : <a title="weavingspace.tileable.TileShape" href="tileable.html#weavingspace.tileable.TileShape">TileShape</a></code></dt>
<dd>
<div class="desc"><p>base shape of the tileable.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.tile_unit"><code class="name">var <span class="ident">tile_unit</span> : <a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></code></dt>
<dd>
<div class="desc"><p>tileable on which the tiling is based.</p></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.tiles"><code class="name">var <span class="ident">tiles</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the tiles after tiling has been carried out.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.tile_map.Tiling.get_tiled_map"><code class="name flex">
<span>def <span class="ident">get_tiled_map</span></span>(<span>self,<br>rotation: float = 0.0,<br>join_on_prototiles: bool = True,<br>prioritise_tiles: bool = True,<br>ragged_edges: bool = True,<br>use_centroid_lookup_approximation=False,<br>debug=False) ‑> <a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiled_map(self, rotation:float = 0.,
                  join_on_prototiles:bool = True,
                  prioritise_tiles:bool = True,
                  ragged_edges:bool = True,
                  use_centroid_lookup_approximation = False,
                  debug = False) -&gt; &#34;TiledMap&#34;:
  &#34;&#34;&#34;Returns a `TiledMap` filling a region at the requested rotation.

  HERE BE DRAGONS! This function took a lot of trial and error to get
  right, so modify with CAUTION!

  The `proritise_tiles = True` option means that the tiling will not
  break up the tiles in `TileUnit`s at the boundaries between areas
  in the mapped region, but will instead ensure that tiles remain
  complete, picking up their data from the region zone which they overlap
  the most.
  
  The exact order in which operations are performed affects performance.
  For example, the final clipping to self.region when ragged_edges =
  False is _much_ slower if it is carried out before the dissolving of
  tiles into the region zones. So... again... modify CAREFULLY!

  Args:
    rotation (float, optional): An optional rotation to apply. Defaults
      to 0.
    join_on_prototiles (bool, optional): if True data from the region
      dataset are joined to tiles based on the prototile to which they
      belong. If False the join is based on the tiles in relation to the
      region areas. For weave-based tilings False is probably to be
      preferred. Defaults to True.
    prioritise_tiles (bool, optional): if True tiles will not be
      broken at boundaries in the region dataset. Defaults to True.
    ragged_edges (bool, optional): if True tiles at the edge of the
      region will not be cut by the region extent - ignored if
      prioritise_tiles is False when edges will always be clipped to
      the region extent. Defaults to True.
    use_centroid_lookup_approximation (bool, optional): if True use
      tile centroids for lookup of region data - ignored if
      prioritise_tiles is False when it is irrelevant. Defaults to
      False.
    debug (bool, optional): if True prints timing messages. Defaults
      to False.

  Returns:
    TiledMap: a TiledMap of the source region.
  &#34;&#34;&#34;
  if debug:
    t1 = perf_counter()

  id_var = self._setup_region_DZID()
  if join_on_prototiles:
    tiled_map, join_layer = self.rotated(rotation)
    tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;prototile_id&#34;]
  else:
    tiled_map = self.rotated(rotation)[0]
    tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;tile_id&#34;]
    join_layer = tiled_map
  join_layer[&#34;joinUID&#34;] = list(range(join_layer.shape[0]))

  # compile a list of the variable names we are NOT going to change
  # i.e. everything except the geometry and the id_var
  region_vars = list(self.region.columns)
  region_vars.remove(&#34;geometry&#34;)
  region_vars.remove(id_var)

  if debug:
    t2 = perf_counter()
    print(f&#34;STEP 1: prep data (rotation if requested): {t2 - t1:.3f}&#34;)

  if prioritise_tiles:  # maintain tile continuity across zone boundaries
    # select only tiles inside a spacing buffer of the region
    # make column with unique ID for every tile in the tiling
    # the join ID is unique per tile
    # if join_on_prototiles:
    #   tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;prototile_id&#34;]
    # else:
    #   tiled_map[&#34;joinUID&#34;] = self.tiles[&#34;tile_id&#34;]

    if use_centroid_lookup_approximation:
      t5 = perf_counter()
      tile_pts = copy.deepcopy(join_layer)
      tile_pts.geometry = tile_pts.centroid
      lookup = tile_pts.sjoin(
        self.region, how = &#34;inner&#34;)[[&#34;joinUID&#34;, id_var]]
    else:
      # determine areas of overlapping tiles and drop the data we join the 
      # data back later, so dropping makes that easier overlaying in region.
      # overlay(tiles) seems to be faster??
      # TODO: also... this part is performance-critical, think about fixes -- 
      # possibly including the above centroid-based approx
      overlaps = self.region.overlay(join_layer, make_valid = False)
      # overlaps = self.region.overlay(tiled_map, make_valid = False)
      if debug:
        t3 = perf_counter()
        print(f&#34;STEP A2: overlay zones with tiling: {t3 - t2:.3f}&#34;)
      overlaps[&#34;area&#34;] = overlaps.geometry.area
      if debug:
        t4 = perf_counter()
        print(f&#34;STEP A3: calculate areas: {t4 - t3:.3f}&#34;)
      overlaps.drop(columns = region_vars, inplace = True)
      if debug:
        t5 = perf_counter()
        print(f&#34;STEP A4: drop columns prior to join: {t5 - t4:.3f}&#34;)
      # make a lookup by largest area tile to region id
      lookup = overlaps \
        .iloc[overlaps.groupby(&#34;joinUID&#34;)[&#34;area&#34;] \
        .agg(pd.Series.idxmax)][[&#34;joinUID&#34;, id_var]]
    # now join the lookup and from there the region data
    if debug:
      t6 = perf_counter()
      print(f&#34;STEP A5: build lookup for join: {t6 - t5:.3f}&#34;)
    tiled_map = tiled_map \
      .merge(lookup, on = &#34;joinUID&#34;) \
      .merge(self.region.drop(columns = [&#34;geometry&#34;]), on = id_var)
    if debug:
      t7 = perf_counter()
      print(f&#34;STEP A6: perform lookup join: {t7 - t6:.3f}&#34;)
    tiled_map.drop(columns = [&#34;joinUID&#34;], inplace = True)

  else:  # here we overlay
    tiled_map = self.region.overlay(tiled_map)
    t7 = perf_counter()
    if debug:
      print(f&#34;STEP B2: overlay tiling with zones: {t7 - t2:.3f}&#34;)

  if join_on_prototiles:
    tiled_map = tiled_map.loc[
      shapely.intersects(self.region_union, np.array(tiled_map.geometry)), :]

  tiled_map.drop(columns = [id_var], inplace = True)
  self.region.drop(columns = [id_var], inplace = True)

  # if we&#39;ve retained tiles and want &#39;clean&#39; edges, then clip
  # note that this step is slow: geopandas unary_unions the clip layer
  if prioritise_tiles and not ragged_edges:
    tiled_map.sindex
    tiled_map = tiled_map.clip(self.region)
    if debug:
      print(f&#34;&#34;&#34;STEP A7/B3: clip map to region: {perf_counter() - t7:.3f}&#34;&#34;&#34;)

  tm = TiledMap()
  tm.tiling = self
  tm.map = tiled_map
  return tm</code></pre>
</details>
<div class="desc"><p>Returns a <code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code> filling a region at the requested rotation.</p>
<p>HERE BE DRAGONS! This function took a lot of trial and error to get
right, so modify with CAUTION!</p>
<p>The <code>proritise_tiles = True</code> option means that the tiling will not
break up the tiles in <code>TileUnit</code>s at the boundaries between areas
in the mapped region, but will instead ensure that tiles remain
complete, picking up their data from the region zone which they overlap
the most.</p>
<p>The exact order in which operations are performed affects performance.
For example, the final clipping to self.region when ragged_edges =
False is <em>much</em> slower if it is carried out before the dissolving of
tiles into the region zones. So&hellip; again&hellip; modify CAREFULLY!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rotation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>An optional rotation to apply. Defaults
to 0.</dd>
<dt><strong><code>join_on_prototiles</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True data from the region
dataset are joined to tiles based on the prototile to which they
belong. If False the join is based on the tiles in relation to the
region areas. For weave-based tilings False is probably to be
preferred. Defaults to True.</dd>
<dt><strong><code>prioritise_tiles</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True tiles will not be
broken at boundaries in the region dataset. Defaults to True.</dd>
<dt><strong><code>ragged_edges</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True tiles at the edge of the
region will not be cut by the region extent - ignored if
prioritise_tiles is False when edges will always be clipped to
the region extent. Defaults to True.</dd>
<dt><strong><code>use_centroid_lookup_approximation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True use
tile centroids for lookup of region data - ignored if
prioritise_tiles is False when it is irrelevant. Defaults to
False.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True prints timing messages. Defaults
to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code></dt>
<dd>a TiledMap of the source region.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.make_tiling"><code class="name flex">
<span>def <span class="ident">make_tiling</span></span>(<span>self) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_tiling(self) -&gt; gpd.GeoDataFrame:
  &#34;&#34;&#34;Tiles the region with a tile unit, returning a GeoDataFrame

  Returns:
    geopandas.GeoDataFrame: a GeoDataFrame of the region tiled with the
      tile unit.
  &#34;&#34;&#34;
  # we assume the geometry column is called geometry so make it so...
  if self.region.geometry.name != &#34;geometry&#34;:
    self.region.rename_geometry(&#34;geometry&#34;, inplace = True)

  # chain list of lists of GeoSeries geometries to list of geometries
  tiles = itertools.chain(*[
    self.tile_unit.tiles.geometry.translate(p.x, p.y)
    for p in self.grid.points])
  prototiles = itertools.chain(*[
    self.tile_unit.prototile.geometry.translate(p.x, p.y)
    for p in self.grid.points])
  # replicate the tile ids
  prototile_ids = list(range(len(self.grid.points)))
  tile_ids = list(self.tile_unit.tiles.tile_id) * len(self.grid.points)
  tile_prototile_ids = sorted(prototile_ids * self.tile_unit.tiles.shape[0])
  tiles_gs = gpd.GeoSeries(tiles)
  prototiles_gs = gpd.GeoSeries(prototiles)
  # assemble and return as GeoDataFrames
  tiles_gdf = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: tile_ids, &#34;prototile_id&#34;: tile_prototile_ids},
    geometry = tiles_gs, crs = self.tile_unit.crs)
  prototiles_gdf = gpd.GeoDataFrame(
    data = {&#34;prototile_id&#34;: prototile_ids},
    geometry = prototiles_gs, crs = self.tile_unit.crs)
  # unclear if we need the gridify or not...
  return (tiling_utils.gridify(tiles_gdf),
          tiling_utils.gridify(prototiles_gdf))</code></pre>
</details>
<div class="desc"><p>Tiles the region with a tile unit, returning a GeoDataFrame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>a GeoDataFrame of the region tiled with the
tile unit.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tile_map.Tiling.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, rotation: float = None) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, rotation:float = None) -&gt; gpd.GeoDataFrame:
  &#34;&#34;&#34;Returns the stored tiling rotated.

  Args:
    rotation (float, optional): Rotation angle in degrees.
      Defaults to None.

  Returns:
    gpd.GeoDataFrame: Rotated tiling.
  &#34;&#34;&#34;
  if self.tiles is None:
    self.tiles = self.make_tiling()
  self.rotation = rotation
  if self.rotation == 0:
    return self.tiles, self.prototiles
  tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: self.tiles.tile_id,
            &#34;prototile_id&#34;: self.tiles.tile_id},
    crs = self.tiles.crs,
    geometry = tiling_utils.gridify(
      self.tiles.geometry.rotate(rotation, origin = self.grid.centre)))
  prototiles = gpd.GeoDataFrame(
    data = {&#34;prototile_id&#34;: self.prototiles.prototile_id},
    crs = self.prototiles.crs,
    geometry = tiling_utils.gridify(
      self.prototiles.geometry.rotate(rotation, origin = self.grid.centre)))
  return tiles, prototiles</code></pre>
</details>
<div class="desc"><p>Returns the stored tiling rotated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rotation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Rotation angle in degrees.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Rotated tiling.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.tile_map.TiledMap" href="#weavingspace.tile_map.TiledMap">TiledMap</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tile_map.TiledMap.colourmaps" href="#weavingspace.tile_map.TiledMap.colourmaps">colourmaps</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.dpi" href="#weavingspace.tile_map.TiledMap.dpi">dpi</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.draft_mode" href="#weavingspace.tile_map.TiledMap.draft_mode">draft_mode</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.ellipse_magnification" href="#weavingspace.tile_map.TiledMap.ellipse_magnification">ellipse_magnification</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.explore" href="#weavingspace.tile_map.TiledMap.explore">explore</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.figsize" href="#weavingspace.tile_map.TiledMap.figsize">figsize</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.k" href="#weavingspace.tile_map.TiledMap.k">k</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.legend" href="#weavingspace.tile_map.TiledMap.legend">legend</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.legend_dx" href="#weavingspace.tile_map.TiledMap.legend_dx">legend_dx</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.legend_dy" href="#weavingspace.tile_map.TiledMap.legend_dy">legend_dy</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.legend_zoom" href="#weavingspace.tile_map.TiledMap.legend_zoom">legend_zoom</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.map" href="#weavingspace.tile_map.TiledMap.map">map</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.plot_legend" href="#weavingspace.tile_map.TiledMap.plot_legend">plot_legend</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.radial_key" href="#weavingspace.tile_map.TiledMap.radial_key">radial_key</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.render" href="#weavingspace.tile_map.TiledMap.render">render</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.scheme" href="#weavingspace.tile_map.TiledMap.scheme">scheme</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.tiling" href="#weavingspace.tile_map.TiledMap.tiling">tiling</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.to_file" href="#weavingspace.tile_map.TiledMap.to_file">to_file</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.use_ellipse" href="#weavingspace.tile_map.TiledMap.use_ellipse">use_ellipse</a></code></li>
<li><code><a title="weavingspace.tile_map.TiledMap.variables" href="#weavingspace.tile_map.TiledMap.variables">variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.tile_map.Tiling" href="#weavingspace.tile_map.Tiling">Tiling</a></code></h4>
<ul class="two-column">
<li><code><a title="weavingspace.tile_map.Tiling.get_tiled_map" href="#weavingspace.tile_map.Tiling.get_tiled_map">get_tiled_map</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.grid" href="#weavingspace.tile_map.Tiling.grid">grid</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.make_tiling" href="#weavingspace.tile_map.Tiling.make_tiling">make_tiling</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.prototiles" href="#weavingspace.tile_map.Tiling.prototiles">prototiles</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.region" href="#weavingspace.tile_map.Tiling.region">region</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.region_union" href="#weavingspace.tile_map.Tiling.region_union">region_union</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.rotated" href="#weavingspace.tile_map.Tiling.rotated">rotated</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.rotation" href="#weavingspace.tile_map.Tiling.rotation">rotation</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.tile_shape" href="#weavingspace.tile_map.Tiling.tile_shape">tile_shape</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.tile_unit" href="#weavingspace.tile_map.Tiling.tile_unit">tile_unit</a></code></li>
<li><code><a title="weavingspace.tile_map.Tiling.tiles" href="#weavingspace.tile_map.Tiling.tiles">tiles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
