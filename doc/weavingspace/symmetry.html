<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.symmetry API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.symmetry</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.symmetry.KMP_Matcher"><code class="flex name class">
<span>class <span class="ident">KMP_Matcher</span></span>
<span>(</span><span>sequence: Iterable)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KMP_Matcher:
  &#34;&#34;&#34;Class to find matching subsequences in a sequence.&#34;&#34;&#34;

  sequence: Iterable
  &#34;&#34;&#34;Iterable in which subsequences are to be found.&#34;&#34;&#34;

  def __init__(self, sequence:Iterable):
    self.sequence = sequence

  def find_matches(self, pat:Iterable[tuple[float]]) -&gt; list[int]:
    &#34;&#34;&#34; Implements Knuth-Morris-Pratt string pattern matching algorithm. See:
    https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm which provides
    detailed pseudo-code on which this code is directly based. See also:
    
    Knuth DE, JH Morris Jr, and VR Pratt. 1977. Fast pattern  matching in 
    strings. SIAM Journal on Computing 6(2): 323–350. doi: 10.1137/0206024.

    This implementation expects sequences of tuples of floats, although in 
    principle any objects could be contained in the Iterables.

    Args:
      pat (Iterable[tuple[float]]): The sequence to match.

    Returns:
      Iterable[int]: _description_
    &#34;&#34;&#34;
    j, k, = 0, 0
    finds = []
    table = self._get_table(pat)
    while j &lt; len(self.sequence):
      if self._equal_tuples(pat[k], self.sequence[j]):
        j = j + 1
        k = k + 1
        if k == len(pat):
          finds.append(j - k)
          k = table[k]
      else:
        k = table[k]
        if k &lt; 0:
          j = j + 1
          k = k + 1
    return finds

  def _get_table(self, pattern:Iterable) -&gt; Iterable[int]:
    &#34;&#34;&#34;Returns the &#39;offsets&#39; table used by KMP pattern matching algorithm as
    required by self.find_matches, based on the supplied pattern.

    Args:
      pattern (Iterable): The pattern to set up the table for.
      equals (function, optional): A function to use to test for equality of
        elements in patterns. Defaults to _equal_tuples().

    Returns:
        Iterable[int]: _description_
    &#34;&#34;&#34;
    pos = 1
    cnd = 0
    T = {0: -1}
    while pos &lt; len(pattern):
      if np.allclose(pattern[pos], pattern[cnd]):
        T[pos] = T[cnd]
      else:
        T[pos] = cnd
        while cnd &gt;= 0 and not self._equal_tuples(pattern[pos], pattern[cnd]):
          cnd = T[cnd]
      pos = pos + 1
      cnd = cnd + 1
    T[pos] = cnd
    return tuple(T.values())

  def _equal_tuples(self, t1:Iterable[float], t2:Iterable[float]) -&gt; bool:
    &#34;&#34;&#34;Tests for near equality of two iterables of floats using numpy
    allclose. Wrapped so as to allow find_matches function to take 
    alternative equality tests as input.
    &#34;&#34;&#34;
    return np.allclose(t1, t2, atol = tiling_utils.RESOLUTION * 10)

  def _round_tuple(self, t:Iterable[float], digits:int = 3) -&gt; Iterable[float]:
    &#34;&#34;&#34;Convenience function to round all members of an interable. Used for 
    display purposes.&#34;&#34;&#34;
    return tuple([np.round(x, digits) for x in t])</code></pre>
</details>
<div class="desc"><p>Class to find matching subsequences in a sequence.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.symmetry.KMP_Matcher.sequence"><code class="name">var <span class="ident">sequence</span> : Iterable</code></dt>
<dd>
<div class="desc"><p>Iterable in which subsequences are to be found.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.symmetry.KMP_Matcher.find_matches"><code class="name flex">
<span>def <span class="ident">find_matches</span></span>(<span>self, pat: Iterable[tuple[float]]) ‑> list[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_matches(self, pat:Iterable[tuple[float]]) -&gt; list[int]:
  &#34;&#34;&#34; Implements Knuth-Morris-Pratt string pattern matching algorithm. See:
  https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm which provides
  detailed pseudo-code on which this code is directly based. See also:
  
  Knuth DE, JH Morris Jr, and VR Pratt. 1977. Fast pattern  matching in 
  strings. SIAM Journal on Computing 6(2): 323–350. doi: 10.1137/0206024.

  This implementation expects sequences of tuples of floats, although in 
  principle any objects could be contained in the Iterables.

  Args:
    pat (Iterable[tuple[float]]): The sequence to match.

  Returns:
    Iterable[int]: _description_
  &#34;&#34;&#34;
  j, k, = 0, 0
  finds = []
  table = self._get_table(pat)
  while j &lt; len(self.sequence):
    if self._equal_tuples(pat[k], self.sequence[j]):
      j = j + 1
      k = k + 1
      if k == len(pat):
        finds.append(j - k)
        k = table[k]
    else:
      k = table[k]
      if k &lt; 0:
        j = j + 1
        k = k + 1
  return finds</code></pre>
</details>
<div class="desc"><p>Implements Knuth-Morris-Pratt string pattern matching algorithm. See:
<a href="https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm">https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm</a> which provides
detailed pseudo-code on which this code is directly based. See also:</p>
<p>Knuth DE, JH Morris Jr, and VR Pratt. 1977. Fast pattern
matching in
strings. SIAM Journal on Computing 6(2): 323–350. doi: 10.1137/0206024.</p>
<p>This implementation expects sequences of tuples of floats, although in
principle any objects could be contained in the Iterables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pat</code></strong> :&ensp;<code>Iterable[tuple[float]]</code></dt>
<dd>The sequence to match.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[int]</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher"><code class="flex name class">
<span>class <span class="ident">Shape_Matcher</span></span>
<span>(</span><span>shape: shapely.geometry.polygon.Polygon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shape_Matcher:
  shape: geom.Polygon
  s1: Symmetries
  other: geom.Polygon
  centre: geom.Point
  translation: tuple[float]
  matches: list[Transform]
  identity_transform: tuple[float] = (1, 0, 0, 1, 0, 0)
  
  def __init__(self, shape: geom.Polygon):
    self.shape = shape
    self.s1 = Symmetries(shape)

  def get_polygon_matches(self, shape2: geom.Polygon):
    s2 = Symmetries(shape2)
    if self.s1.symmetry_group != s2.symmetry_group:
      # print(&#34;No matches&#34;)
      return None
    else:
      match_rot, rots = self._get_rotation_matches(s2)
      match_ref, refs = self._get_reflection_matches(s2)
      if match_rot and match_ref:
        # print(f&#34;Rotation and reflection matches found&#34;)
        return rots + refs
      elif match_rot:
        # print(f&#34;Only rotation matches found&#34;)
        return rots
      elif match_ref:
        # print(f&#34;Only reflection matches found&#34;)
        return refs
      else:
        # print (f&#34;No matches found&#34;)
        return None

  def _get_rotation_matches(self, s2:Symmetries):
    matches = self.s1.matcher.find_matches(s2.p_code)
    if len(matches) == 0:
      return False, None
    else:
      transforms = []
      # get lists of polygon corners aligned correctly to measure the angle
      p1_corners = tiling_utils.get_corners(self.shape, repeat_first = False)
      p2_corners = tiling_utils.get_corners(s2.polygon, repeat_first = False)
      for m in matches:
        a, c = self.get_angle_between_polygons(p1_corners, p2_corners, m)
        if a == &#34;translation&#34;:
          # print(&#34;One of the rotation matches is a translation.&#34;)
          transforms.append(
            Transform(&#34;translation&#34;, None, None, c, (1, 0, 0, 1, c[0], c[1])))
        elif a == &#34;identity&#34;:
          transforms.append(
            Transform(&#34;identity&#34;, None, None, c, (1, 0, 0, 1, 0, 0)))
        elif a is None:
          continue
        else:
          transforms.append(Transform(&#34;rotation&#34;, a, c, (0, 0),
            tiling_utils.get_rotation_transform(a, (c.x, c.y))))
      return True, transforms

  def get_angle_between_polygons(self, corners1:list[geom.Point], 
      corners2:list[geom.Point], offset:int) -&gt; tuple[Union[float,geom.Point]]:
    corners2 = corners2[offset:] + corners2[:offset]
    dists = [p1.distance(p2) for p1, p2 in zip(corners1, corners2)]
    if all([np.isclose(dists[0], d, atol = 1e-3, rtol = 1e-3) for d in dists]):
      if np.isclose(dists[0], 0, atol = 1e-3, rtol  = 1e-3):
        return &#34;identity&#34;, (0, 0)
      else:
        return &#34;translation&#34;, (corners1[0].x - corners2[0].x,
                               corners1[0].y - corners2[0].y)
    ordered_dists = sorted([(i, d) for i, d in enumerate(dists)], 
                           key = lambda x: x[1])
    AB = ordered_dists[-2:]
    p1A, p1B = corners1[AB[0][0]], corners1[AB[1][0]]
    p2A, p2B = corners2[AB[0][0]], corners2[AB[1][0]]
    perpAA = self.get_straight_line(p1A, p2A, True)
    perpBB = self.get_straight_line(p1B, p2B, True)
    centre = self.get_intersection(perpAA, perpBB)
    if centre is None:
      angle = None
    else:
      angle = -tiling_utils.get_inner_angle(p1A, centre, p2A)
      if angle &lt; -179:
        angle = angle + 360
      elif angle &gt; 180:
        angle = angle - 360
    return angle, centre

  def get_straight_line(self, p1:geom.Point, p2:geom.Point, 
                        perpendicular:bool = False) -&gt; StraightLine:
    if perpendicular:
      ls = affine.rotate(geom.LineString([p1, p2]), 90)
      pts = [p for p in ls.coords]
      x1, y1 = pts[0]
      x2, y2 = pts[1]
    else:
      x1, y1 = p1.x, p1.y
      x2, y2 = p2.x, p2.y
    return StraightLine(y1 - y2, x2 - x1, x1 * y2 - x2 * y1)

  def get_intersection(self, line1:StraightLine, 
                       line2:StraightLine) -&gt; geom.Point:
    x_set, y_set = False, False
    denominator = line1.A * line2.B - line2.A * line1.B
    if np.isclose(line1.A, 0, atol = 1e-4, rtol = 1e-4):
      y = -line1.C / line1.B
      y_set = True
    elif np.isclose(line2.A, 0, atol = 1e-4, rtol = 1e-4):
      y = -line2.C / line2.B
      y_set = True
    if np.isclose(line1.B, 0, atol = 1e-4, rtol = 1e-4):
      x = -line1.C / line1.A
      x_set = True
    elif np.isclose(line2.B, 0, atol = 1e-4, rtol = 1e-4):
      x = -line2.C / line2.A
      x_set = True
    if np.isclose(denominator, 0, atol = 1e-4, rtol = 1e-4):
      return None
    x = x if x_set else (line1.B * line2.C - line2.B * line1.C) / denominator
    y = y if y_set else (line1.C * line2.A - line2.C * line1.A) / denominator
    return geom.Point(x, y)

  def _get_reflection_matches(self, s2:Symmetries):
    ctr1 = self.s1.polygon.centroid
    ctr2 = s2.polygon.centroid
    c = ((ctr1.x + ctr2.x) / 2, (ctr1.y + ctr2.y) / 2)
    matches = self.s1.matcher.find_matches(s2.p_code_r)
    if len(matches) == 0:
      return False, None
    reflections1 = self.s1.get_reflections(matches)
    reflections2 = s2.get_reflections(matches)
    angles = [(ref1.angle + ref2.angle) / 2
              for ref1, ref2 in zip(reflections1, reflections2)]
    trs = [tiling_utils.get_reflection_transform(angle, c)
           for angle in angles]
    ctrs2r = [affine.affine_transform(ctr2, tr) for tr in trs]
    dxdys = [(ctr1.x - ctr2r.x, ctr1.y - ctr2r.y) for ctr2r in ctrs2r]
    return True, [Transform(
      &#34;reflection&#34;, angle, geom.Point(c), dxdy,
      tiling_utils.combine_transforms(
        [tiling_utils.get_reflection_transform(angle, c), 
         (1, 0, 0, 1, dxdy[0], dxdy[1])])) 
      for angle, dxdy in zip(angles, dxdys)]</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.symmetry.Shape_Matcher.centre"><code class="name">var <span class="ident">centre</span> : shapely.geometry.point.Point</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.identity_transform"><code class="name">var <span class="ident">identity_transform</span> : tuple[float]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.matches"><code class="name">var <span class="ident">matches</span> : list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.other"><code class="name">var <span class="ident">other</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.s1"><code class="name">var <span class="ident">s1</span> : <a title="weavingspace.symmetry.Symmetries" href="#weavingspace.symmetry.Symmetries">Symmetries</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.shape"><code class="name">var <span class="ident">shape</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.translation"><code class="name">var <span class="ident">translation</span> : tuple[float]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.symmetry.Shape_Matcher.get_angle_between_polygons"><code class="name flex">
<span>def <span class="ident">get_angle_between_polygons</span></span>(<span>self,<br>corners1: list[shapely.geometry.point.Point],<br>corners2: list[shapely.geometry.point.Point],<br>offset: int) ‑> tuple[float | shapely.geometry.point.Point]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_angle_between_polygons(self, corners1:list[geom.Point], 
    corners2:list[geom.Point], offset:int) -&gt; tuple[Union[float,geom.Point]]:
  corners2 = corners2[offset:] + corners2[:offset]
  dists = [p1.distance(p2) for p1, p2 in zip(corners1, corners2)]
  if all([np.isclose(dists[0], d, atol = 1e-3, rtol = 1e-3) for d in dists]):
    if np.isclose(dists[0], 0, atol = 1e-3, rtol  = 1e-3):
      return &#34;identity&#34;, (0, 0)
    else:
      return &#34;translation&#34;, (corners1[0].x - corners2[0].x,
                             corners1[0].y - corners2[0].y)
  ordered_dists = sorted([(i, d) for i, d in enumerate(dists)], 
                         key = lambda x: x[1])
  AB = ordered_dists[-2:]
  p1A, p1B = corners1[AB[0][0]], corners1[AB[1][0]]
  p2A, p2B = corners2[AB[0][0]], corners2[AB[1][0]]
  perpAA = self.get_straight_line(p1A, p2A, True)
  perpBB = self.get_straight_line(p1B, p2B, True)
  centre = self.get_intersection(perpAA, perpBB)
  if centre is None:
    angle = None
  else:
    angle = -tiling_utils.get_inner_angle(p1A, centre, p2A)
    if angle &lt; -179:
      angle = angle + 360
    elif angle &gt; 180:
      angle = angle - 360
  return angle, centre</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.get_intersection"><code class="name flex">
<span>def <span class="ident">get_intersection</span></span>(<span>self,<br>line1: <a title="weavingspace.symmetry.StraightLine" href="#weavingspace.symmetry.StraightLine">StraightLine</a>,<br>line2: <a title="weavingspace.symmetry.StraightLine" href="#weavingspace.symmetry.StraightLine">StraightLine</a>) ‑> shapely.geometry.point.Point</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intersection(self, line1:StraightLine, 
                     line2:StraightLine) -&gt; geom.Point:
  x_set, y_set = False, False
  denominator = line1.A * line2.B - line2.A * line1.B
  if np.isclose(line1.A, 0, atol = 1e-4, rtol = 1e-4):
    y = -line1.C / line1.B
    y_set = True
  elif np.isclose(line2.A, 0, atol = 1e-4, rtol = 1e-4):
    y = -line2.C / line2.B
    y_set = True
  if np.isclose(line1.B, 0, atol = 1e-4, rtol = 1e-4):
    x = -line1.C / line1.A
    x_set = True
  elif np.isclose(line2.B, 0, atol = 1e-4, rtol = 1e-4):
    x = -line2.C / line2.A
    x_set = True
  if np.isclose(denominator, 0, atol = 1e-4, rtol = 1e-4):
    return None
  x = x if x_set else (line1.B * line2.C - line2.B * line1.C) / denominator
  y = y if y_set else (line1.C * line2.A - line2.C * line1.A) / denominator
  return geom.Point(x, y)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.get_polygon_matches"><code class="name flex">
<span>def <span class="ident">get_polygon_matches</span></span>(<span>self, shape2: shapely.geometry.polygon.Polygon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polygon_matches(self, shape2: geom.Polygon):
  s2 = Symmetries(shape2)
  if self.s1.symmetry_group != s2.symmetry_group:
    # print(&#34;No matches&#34;)
    return None
  else:
    match_rot, rots = self._get_rotation_matches(s2)
    match_ref, refs = self._get_reflection_matches(s2)
    if match_rot and match_ref:
      # print(f&#34;Rotation and reflection matches found&#34;)
      return rots + refs
    elif match_rot:
      # print(f&#34;Only rotation matches found&#34;)
      return rots
    elif match_ref:
      # print(f&#34;Only reflection matches found&#34;)
      return refs
    else:
      # print (f&#34;No matches found&#34;)
      return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Shape_Matcher.get_straight_line"><code class="name flex">
<span>def <span class="ident">get_straight_line</span></span>(<span>self,<br>p1: shapely.geometry.point.Point,<br>p2: shapely.geometry.point.Point,<br>perpendicular: bool = False) ‑> <a title="weavingspace.symmetry.StraightLine" href="#weavingspace.symmetry.StraightLine">StraightLine</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_straight_line(self, p1:geom.Point, p2:geom.Point, 
                      perpendicular:bool = False) -&gt; StraightLine:
  if perpendicular:
    ls = affine.rotate(geom.LineString([p1, p2]), 90)
    pts = [p for p in ls.coords]
    x1, y1 = pts[0]
    x2, y2 = pts[1]
  else:
    x1, y1 = p1.x, p1.y
    x2, y2 = p2.x, p2.y
  return StraightLine(y1 - y2, x2 - x1, x1 * y2 - x2 * y1)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.symmetry.StraightLine"><code class="flex name class">
<span>class <span class="ident">StraightLine</span></span>
<span>(</span><span>A, B, C)</span>
</code></dt>
<dd>
<div class="desc"><p>StraightLine(A, B, C)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="weavingspace.symmetry.StraightLine.A"><code class="name">var <span class="ident">A</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="weavingspace.symmetry.StraightLine.B"><code class="name">var <span class="ident">B</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="weavingspace.symmetry.StraightLine.C"><code class="name">var <span class="ident">C</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.symmetry.Symmetries"><code class="flex name class">
<span>class <span class="ident">Symmetries</span></span>
<span>(</span><span>polygon: shapely.geometry.polygon.Polygon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Symmetries():
  &#34;&#34;&#34;Class to identify and store the symmetries of a supplied shapely.Polygon
  as a list of `Transform` objects.
  &#34;&#34;&#34;
  polygon:geom.Polygon = None
  &#34;&#34;&#34;Polygon from which these symmetries are derived.&#34;&#34;&#34;
  matcher:KMP_Matcher = None
  &#34;&#34;&#34;the subsequence matcher used in symmetry detection.&#34;&#34;&#34;
  n:int = None
  &#34;&#34;&#34;number of vertices of the polygon.&#34;&#34;&#34;
  p_code:list[tuple[float]] = None
  &#34;&#34;&#34;the encoding of the polygon as sequence of length, angle pairs.&#34;&#34;&#34;
  p_code_r:list[tuple[float]] = None
  &#34;&#34;&#34;the reversed encoding used to detect reflection symmetries.&#34;&#34;&#34;
  rotation_shifts:list[int] = None
  &#34;&#34;&#34;list of number of 2pi/n rotation symmetries.&#34;&#34;&#34;
  reflection_shifts:list[int] = None
  &#34;&#34;&#34;list of pi/n relection angle symmetries.&#34;&#34;&#34;
  symmetries:list[Transform] = None
  &#34;&#34;&#34;list of Transform objects with more complete information.&#34;&#34;&#34;
  symmetry_group:str = None
  &#34;&#34;&#34;the code denoting the symmetry group&#34;&#34;&#34;

  def __init__(self, polygon:geom.Polygon):
    self.polygon = polygon
    self.n = shapely.count_coordinates(self.polygon) - 1
    self.p_code = self._get_polygon_code(self.polygon)
    self.p_code_r = self._get_polygon_code(self.polygon, mirrored = True)
    self.matcher = KMP_Matcher(self.p_code + self.p_code[:-1])
    self.symmetries = self.get_symmetries()
    self.symmetry_group = self.get_symmetry_group_code()

  def _get_polygon_code(self, p:geom.Polygon, 
                        mirrored = False) -&gt; list[tuple[float]]:
    r&#34;&#34;&#34;Returns a list of length-angle pairs to uniquely encode a polygon
    shape (up to scale). The alignment of lengths and angles is important
    and symmetry detection is sensitively dependent on it...

    The forward (i.e. unmirrored) polygon pairs are of edge lengths and the 
    angle between each edge and its successor going CW around the polygon. 
    
           A[i] ----L[i]---- A (i+1)
          /                   \
         /                     \
                             
    i.e. edge i is between angles i and i + 1, and angle i is between edge
    i-1 and i. The unmirrored encoding pairs length[i] with angle[i+1].
    
    The mirrored encoding pairs matched indexes of lengths and angles in the
    original polygon. This means the angle is still the one between and edge 
    and its successor but proceeding CCW around the polygon.
    
    See in particular for clarification.
    
    Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and 
    Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology. 
    North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.
    
    Args:
      p (geom.Polygon): the polygon to encode
      mirrored (bool, optional): if true encoding will be in CCC order. 
        Defaults to False.

    Returns:
      list[tuple[float]]: _description_
    &#34;&#34;&#34;
    # get edge lengths and angles
    lengths = tiling_utils.get_side_lengths(p)
    raw_angles = tiling_utils.get_interior_angles(p)
    if mirrored:
      lengths_r = list(reversed(lengths))
      angles_r = list(reversed(raw_angles))
      return list(zip(lengths_r, angles_r))
    else:
      angles = raw_angles[1:] + raw_angles[:1]
      return list(zip(lengths, angles))

  def get_symmetries(self) -&gt; list[Transform]:
    &#34;&#34;&#34;Finds rotation and reflection symmetries of the supplied polygon.
    Based on
    
      Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and 
      Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology. 
      North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.
    
    and also
    
      Wolter JD, TC Woo, and RA Volz. 1985. Optimal algorithms for symmetry 
      detection in two and three dimensions. The Visual Computer 1(1): 37-48. 
      doi: 10.1007/BF01901268.
    
    Details in these papers are not unambiguous. This implementation was
    developed based on them, but with a lot of trial and error to get the index
    offsets and (especially) retrieval of the reflection axes angles to work.

    Returns:
      list[Transform]: a list of Transform objects representing the polygon
        symmetries.
    &#34;&#34;&#34;
    # ==== Rotations ====
    self.rotation_shifts = self.matcher.find_matches(self.p_code)
    # ==== Reflections ====
    self.reflection_shifts = self.matcher.find_matches(self.p_code_r)
    return self.get_rotations(self.rotation_shifts) + \
           self.get_reflections(self.reflection_shifts)

  def get_rotations(self, offsets:list[int]) -&gt; list[Transform]:
    &#34;&#34;&#34;Gets the rotations associated with this collection of symmetries.

    Returns:
      list[Transform]: A list of the rotation symmetries associated with this
        polygon.
    &#34;&#34;&#34;
    c = self.polygon.centroid
    rot_angles = [np.round(i * 360 / self.n, 6) for i in offsets] 
    rotation_transforms = [
      np.round(tiling_utils.get_rotation_transform(a, (c.x, c.y)), 6) 
      for a in rot_angles]
    return [Transform(&#34;rotation&#34;, angle, c, (0, 0), transform)
            for transform, angle in zip(rotation_transforms, rot_angles)]

  def get_reflections(self, offsets:list[int]) -&gt; list[Transform]:
    &#34;&#34;&#34;Gets the reflections associated with this collection of symmetries.

    Returns:
      list[Transform]: A list of the reflection symmetries associated with this
        polygon.
    &#34;&#34;&#34;
    # calculate all possible reflection axes - ordering of these is important
    # for correct picking - don&#39;t mess with this code!
    c = self.polygon.centroid
    bearings = tiling_utils.get_side_bearings(self.polygon)
    reflection_axes = []
    interior_angles = tiling_utils.get_interior_angles(self.polygon)
    for i in range(self.n):
      # angle bisectors
      reflection_axes.append(bearings[i] - interior_angles[i] / 2)
      # edge_perpendicular bisectors
      reflection_axes.append(bearings[i] - 90)  # normal to the edge
    # pick out those where matches occurred
    ref_angles = [np.round(reflection_axes[i], 6) for i in offsets]
    reflection_transforms = [
      np.round(tiling_utils.get_reflection_transform(a, (c.x, c.y)), 6)
      for a in ref_angles]
    return [Transform(&#34;reflection&#34;, angle, c, (0, 0), transform)
            for transform, angle in zip(reflection_transforms, ref_angles)]

  def get_symmetry_group_code(self):
    if len(self.reflection_shifts) == 0:
      return f&#34;C{len(self.rotation_shifts)}&#34;
    else:
      return f&#34;D{len(self.rotation_shifts)}&#34;

  def get_corner_offset(self, poly2:geom.Polygon):
    s2 = Symmetries(poly2)
    matches = self.matcher.find_matches(s2.p_code)
    if len(matches) &gt; 0:
      return matches[0]
    matches = self.matcher.find_matches(s2.p_code_r)
    if len(matches) &gt; 0:
      return -matches[0]
    return None

  def get_corner_labels(self) -&gt; dict[str, list[str]]:
    &#34;&#34;&#34;Returns all the reorderings of vertex labels corresponding to each
    symmetry.

    Returns:
      dict[str, list[str]]: A dictionary with two entries. &#34;rotations&#34; is
        a list of labels under the rotation symmetries, &#34;reflections&#34; those
        under the reflection symmetries.
    &#34;&#34;&#34;
    labels = list(string.ascii_letters.upper())[:self.n]
    return self._get_labels_under_symmetries(labels)

  def get_unique_labels(self, offset:int = 0) -&gt; list[str]:
    labellings = self.get_corner_labels()
    labellings = labellings[&#34;rotations&#34;] + labellings[&#34;reflections&#34;]
    labellings = [&#34;&#34;.join(sorted(x)) for x in zip(*labellings)]
    n_new_labels = len(set(labellings))
    letters = list(string.ascii_letters.upper())[offset:offset + n_new_labels]
    mapping = dict()
    i = 0
    for label in labellings:
      if not label in mapping:
        mapping[label] = letters[i]
        i = i + 1
    return self._get_labels_under_symmetries([mapping[x] for x in labellings])
  
  def _get_labels_under_symmetries(
      self, labels:list[str]) -&gt; dict[str, list[str]]:
    cycle = labels * 2
    under_rotation = [&#34;&#34;.join(cycle[i:self.n + i]) 
                      for i in self.rotation_shifts]
    under_reflection = [&#34;&#34;.join(cycle[self.n + i:i:-1]) 
                        for i in self.reflection_shifts]
    return {&#34;rotations&#34;: under_rotation,
            &#34;reflections&#34;: under_reflection}

  def plot(self, as_image:bool = False, title:str = &#34;&#34;):
    fig = pyplot.figure()
    fig.suptitle(title)

    n_subplots = len(self.symmetries)
    nr = int(np.ceil(np.sqrt(n_subplots)))
    nc = int(np.ceil(n_subplots / nr))
    n_plots = 0

    for s in self.symmetries:
      n_plots = n_plots + 1
      ax = fig.add_subplot(nr, nc, n_plots)
      s.plot(ax, self.polygon)
    
    if as_image:
      buf = io.BytesIO()
      fig.savefig(buf)
      buf.seek(0)
      return PIL.Image.open(buf)
    return ax</code></pre>
</details>
<div class="desc"><p>Class to identify and store the symmetries of a supplied shapely.Polygon
as a list of <code><a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a></code> objects.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.symmetry.Symmetries.matcher"><code class="name">var <span class="ident">matcher</span> : <a title="weavingspace.symmetry.KMP_Matcher" href="#weavingspace.symmetry.KMP_Matcher">KMP_Matcher</a></code></dt>
<dd>
<div class="desc"><p>the subsequence matcher used in symmetry detection.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.n"><code class="name">var <span class="ident">n</span> : int</code></dt>
<dd>
<div class="desc"><p>number of vertices of the polygon.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.p_code"><code class="name">var <span class="ident">p_code</span> : list[tuple[float]]</code></dt>
<dd>
<div class="desc"><p>the encoding of the polygon as sequence of length, angle pairs.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.p_code_r"><code class="name">var <span class="ident">p_code_r</span> : list[tuple[float]]</code></dt>
<dd>
<div class="desc"><p>the reversed encoding used to detect reflection symmetries.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.polygon"><code class="name">var <span class="ident">polygon</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"><p>Polygon from which these symmetries are derived.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.reflection_shifts"><code class="name">var <span class="ident">reflection_shifts</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>list of pi/n relection angle symmetries.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.rotation_shifts"><code class="name">var <span class="ident">rotation_shifts</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>list of number of 2pi/n rotation symmetries.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.symmetries"><code class="name">var <span class="ident">symmetries</span> : list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</code></dt>
<dd>
<div class="desc"><p>list of Transform objects with more complete information.</p></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.symmetry_group"><code class="name">var <span class="ident">symmetry_group</span> : str</code></dt>
<dd>
<div class="desc"><p>the code denoting the symmetry group</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.symmetry.Symmetries.get_corner_labels"><code class="name flex">
<span>def <span class="ident">get_corner_labels</span></span>(<span>self) ‑> dict[str, list[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner_labels(self) -&gt; dict[str, list[str]]:
  &#34;&#34;&#34;Returns all the reorderings of vertex labels corresponding to each
  symmetry.

  Returns:
    dict[str, list[str]]: A dictionary with two entries. &#34;rotations&#34; is
      a list of labels under the rotation symmetries, &#34;reflections&#34; those
      under the reflection symmetries.
  &#34;&#34;&#34;
  labels = list(string.ascii_letters.upper())[:self.n]
  return self._get_labels_under_symmetries(labels)</code></pre>
</details>
<div class="desc"><p>Returns all the reorderings of vertex labels corresponding to each
symmetry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, list[str]]</code></dt>
<dd>A dictionary with two entries. "rotations" is
a list of labels under the rotation symmetries, "reflections" those
under the reflection symmetries.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_corner_offset"><code class="name flex">
<span>def <span class="ident">get_corner_offset</span></span>(<span>self, poly2: shapely.geometry.polygon.Polygon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner_offset(self, poly2:geom.Polygon):
  s2 = Symmetries(poly2)
  matches = self.matcher.find_matches(s2.p_code)
  if len(matches) &gt; 0:
    return matches[0]
  matches = self.matcher.find_matches(s2.p_code_r)
  if len(matches) &gt; 0:
    return -matches[0]
  return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_reflections"><code class="name flex">
<span>def <span class="ident">get_reflections</span></span>(<span>self, offsets: list[int]) ‑> list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reflections(self, offsets:list[int]) -&gt; list[Transform]:
  &#34;&#34;&#34;Gets the reflections associated with this collection of symmetries.

  Returns:
    list[Transform]: A list of the reflection symmetries associated with this
      polygon.
  &#34;&#34;&#34;
  # calculate all possible reflection axes - ordering of these is important
  # for correct picking - don&#39;t mess with this code!
  c = self.polygon.centroid
  bearings = tiling_utils.get_side_bearings(self.polygon)
  reflection_axes = []
  interior_angles = tiling_utils.get_interior_angles(self.polygon)
  for i in range(self.n):
    # angle bisectors
    reflection_axes.append(bearings[i] - interior_angles[i] / 2)
    # edge_perpendicular bisectors
    reflection_axes.append(bearings[i] - 90)  # normal to the edge
  # pick out those where matches occurred
  ref_angles = [np.round(reflection_axes[i], 6) for i in offsets]
  reflection_transforms = [
    np.round(tiling_utils.get_reflection_transform(a, (c.x, c.y)), 6)
    for a in ref_angles]
  return [Transform(&#34;reflection&#34;, angle, c, (0, 0), transform)
          for transform, angle in zip(reflection_transforms, ref_angles)]</code></pre>
</details>
<div class="desc"><p>Gets the reflections associated with this collection of symmetries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</code></dt>
<dd>A list of the reflection symmetries associated with this
polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_rotations"><code class="name flex">
<span>def <span class="ident">get_rotations</span></span>(<span>self, offsets: list[int]) ‑> list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rotations(self, offsets:list[int]) -&gt; list[Transform]:
  &#34;&#34;&#34;Gets the rotations associated with this collection of symmetries.

  Returns:
    list[Transform]: A list of the rotation symmetries associated with this
      polygon.
  &#34;&#34;&#34;
  c = self.polygon.centroid
  rot_angles = [np.round(i * 360 / self.n, 6) for i in offsets] 
  rotation_transforms = [
    np.round(tiling_utils.get_rotation_transform(a, (c.x, c.y)), 6) 
    for a in rot_angles]
  return [Transform(&#34;rotation&#34;, angle, c, (0, 0), transform)
          for transform, angle in zip(rotation_transforms, rot_angles)]</code></pre>
</details>
<div class="desc"><p>Gets the rotations associated with this collection of symmetries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</code></dt>
<dd>A list of the rotation symmetries associated with this
polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_symmetries"><code class="name flex">
<span>def <span class="ident">get_symmetries</span></span>(<span>self) ‑> list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_symmetries(self) -&gt; list[Transform]:
  &#34;&#34;&#34;Finds rotation and reflection symmetries of the supplied polygon.
  Based on
  
    Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and 
    Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology. 
    North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.
  
  and also
  
    Wolter JD, TC Woo, and RA Volz. 1985. Optimal algorithms for symmetry 
    detection in two and three dimensions. The Visual Computer 1(1): 37-48. 
    doi: 10.1007/BF01901268.
  
  Details in these papers are not unambiguous. This implementation was
  developed based on them, but with a lot of trial and error to get the index
  offsets and (especially) retrieval of the reflection axes angles to work.

  Returns:
    list[Transform]: a list of Transform objects representing the polygon
      symmetries.
  &#34;&#34;&#34;
  # ==== Rotations ====
  self.rotation_shifts = self.matcher.find_matches(self.p_code)
  # ==== Reflections ====
  self.reflection_shifts = self.matcher.find_matches(self.p_code_r)
  return self.get_rotations(self.rotation_shifts) + \
         self.get_reflections(self.reflection_shifts)</code></pre>
</details>
<div class="desc"><p>Finds rotation and reflection symmetries of the supplied polygon.
Based on</p>
<p>Eades P. 1988. Symmetry Finding Algorithms. In Machine Intelligence and
Pattern Recognition, ed. GT Toussaint, 6:41-51. Computational Morphology.
North-Holland. doi: 10.1016/B978-0-444-70467-2.50009-6.</p>
<p>and also</p>
<p>Wolter JD, TC Woo, and RA Volz. 1985. Optimal algorithms for symmetry
detection in two and three dimensions. The Visual Computer 1(1): 37-48.
doi: 10.1007/BF01901268.</p>
<p>Details in these papers are not unambiguous. This implementation was
developed based on them, but with a lot of trial and error to get the index
offsets and (especially) retrieval of the reflection axes angles to work.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a>]</code></dt>
<dd>a list of Transform objects representing the polygon
symmetries.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_symmetry_group_code"><code class="name flex">
<span>def <span class="ident">get_symmetry_group_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_symmetry_group_code(self):
  if len(self.reflection_shifts) == 0:
    return f&#34;C{len(self.rotation_shifts)}&#34;
  else:
    return f&#34;D{len(self.rotation_shifts)}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.get_unique_labels"><code class="name flex">
<span>def <span class="ident">get_unique_labels</span></span>(<span>self, offset: int = 0) ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unique_labels(self, offset:int = 0) -&gt; list[str]:
  labellings = self.get_corner_labels()
  labellings = labellings[&#34;rotations&#34;] + labellings[&#34;reflections&#34;]
  labellings = [&#34;&#34;.join(sorted(x)) for x in zip(*labellings)]
  n_new_labels = len(set(labellings))
  letters = list(string.ascii_letters.upper())[offset:offset + n_new_labels]
  mapping = dict()
  i = 0
  for label in labellings:
    if not label in mapping:
      mapping[label] = letters[i]
      i = i + 1
  return self._get_labels_under_symmetries([mapping[x] for x in labellings])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Symmetries.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, as_image: bool = False, title: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, as_image:bool = False, title:str = &#34;&#34;):
  fig = pyplot.figure()
  fig.suptitle(title)

  n_subplots = len(self.symmetries)
  nr = int(np.ceil(np.sqrt(n_subplots)))
  nc = int(np.ceil(n_subplots / nr))
  n_plots = 0

  for s in self.symmetries:
    n_plots = n_plots + 1
    ax = fig.add_subplot(nr, nc, n_plots)
    s.plot(ax, self.polygon)
  
  if as_image:
    buf = io.BytesIO()
    fig.savefig(buf)
    buf.seek(0)
    return PIL.Image.open(buf)
  return ax</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.symmetry.Transform"><code class="flex name class">
<span>class <span class="ident">Transform</span></span>
<span>(</span><span>transform_type: str,<br>angle: float,<br>centre: shapely.geometry.point.Point,<br>translation: tuple[float],<br>transform: tuple[float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transform:
  &#34;&#34;&#34;Class to store details of a transform and draw it.&#34;&#34;&#34;
  transform_type: str
  &#34;&#34;&#34;Type of transform, &#39;rotation&#39;, &#39;reflection&#39;, &#39;translation&#39; or &#39;identity&#39;.&#34;&#34;&#34;
  angle: float
  &#34;&#34;&#34;Angle of rotation (degrees).&#34;&#34;&#34;
  centre: geom.Point
  &#34;&#34;&#34;Centre of the transformation.&#34;&#34;&#34;
  translation: tuple[float] 
  &#34;&#34;&#34;X and Y coordinates shifts of a translation transform. A glide reflection
  may also include this.&#34;&#34;&#34;
  transform: tuple[float]
  &#34;&#34;&#34;Six element tuple for the transform in shapely.transform format. See
  https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations and
  methods in `weavingspace.tiling_utils`.&#34;&#34;&#34;
  offset: int

  def __init__(self, transform_type:str, angle:float, centre:geom.Point, 
               translation: tuple[float], transform:tuple[float]):
    self.transform_type = transform_type
    self.angle = angle
    self.centre = centre
    self.translation = translation
    self.transform = transform

  def __str__(self) -&gt; str:
    if self.transform_type == &#34;rotation&#34;:
      return f&#34;{self.transform_type} {self.angle:.1f}° POINT ({self.centre.x:.1f} {self.centre.y:.1f}) {tuple([np.round(x, 3) for x in self.transform])}&#34;
    elif self.transform_type == &#34;reflection&#34;:
      return f&#34;{self.transform_type} {self.angle:.1f}° {tuple([np.round(x, 3) for x in self.transform])}&#34;
    else:
      return f&#34;{self.transform_type} {tuple([np.round(x, 3) for x in self.transform])}&#34;

  def __repr__(self) -&gt; str:
    return str(self)

  def apply(self, geometry:Any) -&gt; Any:
    &#34;&#34;&#34;Applies this transform to supplied shapely geometry and returns result.

    Args:
      geometry (Any): a shapely geometry to transform.
    
    Returns:
      Any: the resulting transformed shapely geometry.
    &#34;&#34;&#34;
    return affine.affine_transform(geometry, self.transform)

  def draw(self, ax:pyplot.axes, **kwargs) -&gt; pyplot.Axes:
    &#34;&#34;&#34;Draws this transform on the supplied axes. Arguments specific to each
    transform type are supplied as **kwargs and are documented in 
    `draw_rotation`, `draw_reflection`, and `draw_translation`.

    Args:
        ax (pyplot.axes): the axes on which to draw the transform.

    Returns:
        pyplot.Axes: the axes with the rendering of this transform added.
    &#34;&#34;&#34;
    if self.transform_type == &#34;rotation&#34;:
      rotn_args = list(inspect.signature(self.draw_rotation).parameters)
      rotn_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in rotn_args}
      return self.draw_rotation(ax = ax, **rotn_dict)
    elif self.transform_type == &#34;reflection&#34;:
      refn_args = list(inspect.signature(self.draw_reflection).parameters)
      refn_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in refn_args}
      return self.draw_reflection(ax = ax, **refn_dict)
    if self.transform_type == &#34;translation&#34;:
      trans_args = list(inspect.signature(self.draw_translation).parameters)
      trans_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in trans_args}
      return self.draw_translation(ax = ax, **trans_dict)
    elif self.transform_type == &#34;identity&#34;:
      w = ax.get_window_extent().width
      return ax.set_title(f&#34;{self.transform_type}&#34;, fontsize = w / 20)

  def draw_rotation(self, ax:pyplot.Axes, 
                    radius = 200, add_title = True) -&gt; pyplot.Axes:
    x, y = self.centre.x, self.centre.y
    axis = geom.LineString([(x, y), (x + radius * 1.25, y)])
    arc = geom.LineString([
      geom.Point(x + radius * np.cos(np.radians(a)),
                  y + radius * np.sin(np.radians(a)))
      for a in np.linspace(0, self.angle, 50)])
    gpd.GeoSeries([self.centre]).plot(
      ax = ax, color = &#34;r&#34;, markersize = 4, zorder = 5)
    gpd.GeoSeries([axis, arc]).plot(ax = ax, color = &#34;r&#34;, lw = .5)
    if add_title:
      w = ax.get_window_extent().width
      ax.set_title(f&#34;{self.transform_type} {np.round(self.angle, 2)}&#34;,
                   fontsize = w / 20)
    return ax

  def draw_reflection(self, ax:pyplot.Axes, w = 5, 
                      mirror_length = 100, add_title = True) -&gt; pyplot.Axes:
    x, y = self.centre.x, self.centre.y
    dx, dy = self.translation
    r = np.sqrt(self.translation[0] ** 2 + self.translation[1] ** 2) 
    mirror = geom.LineString([
      (x - mirror_length / 2 * np.cos(np.radians(self.angle)), 
        y - mirror_length / 2 * np.sin(np.radians(self.angle))),
      (x + mirror_length / 2 * np.cos(np.radians(self.angle)), 
        y + mirror_length / 2 * np.sin(np.radians(self.angle)))])
    gpd.GeoSeries([mirror]).plot(
      ax = ax, color = &#34;r&#34;, lw = 1, ls = &#34;dashdot&#34;, zorder = 5)
    no_slide = np.isclose(r, 0, rtol = 1e-6, atol = 1e-6)
    if not no_slide:
      pyplot.arrow(
        x - dx / 2, y - dy / 2, dx, dy, length_includes_head = True,
        width = w, fc = &#34;k&#34;, ec = None, head_width = w * 6, zorder = 5)
    if add_title:
      w = ax.get_window_extent().width
      ax.set_title(f&#34;{self.transform_type} {np.round(self.angle, 2)}&#34;,
                   fontsize = w / 20)
    return ax

  def draw_translation(self, ax:pyplot.Axes, c:geom.Point, 
                       w:float = 5, add_title = True) -&gt; pyplot.Axes:
    gpd.GeoSeries([c]).plot(ax = ax, color = &#34;b&#34;)
    pyplot.arrow(c.x, c.y, self.translation[0], self.translation[1], lw = 0.5,
                width = w, fc = &#34;b&#34;, ec = None, head_width = w * 6, zorder = 5)
    if add_title:
      w = ax.get_window_extent().width
      rounded_tr = tuple([np.round(x, 1) for x in self.translation])
      ax.set_title(f&#34;{self.transform_type} {rounded_tr}&#34;,
                   fontsize = w / 20)
    return ax</code></pre>
</details>
<div class="desc"><p>Class to store details of a transform and draw it.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.symmetry.Transform.angle"><code class="name">var <span class="ident">angle</span> : float</code></dt>
<dd>
<div class="desc"><p>Angle of rotation (degrees).</p></div>
</dd>
<dt id="weavingspace.symmetry.Transform.centre"><code class="name">var <span class="ident">centre</span> : shapely.geometry.point.Point</code></dt>
<dd>
<div class="desc"><p>Centre of the transformation.</p></div>
</dd>
<dt id="weavingspace.symmetry.Transform.offset"><code class="name">var <span class="ident">offset</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.symmetry.Transform.transform"><code class="name">var <span class="ident">transform</span> : tuple[float]</code></dt>
<dd>
<div class="desc"><p>Six element tuple for the transform in shapely.transform format. See
<a href="https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a> and
methods in <code><a title="weavingspace.tiling_utils" href="tiling_utils.html">weavingspace.tiling_utils</a></code>.</p></div>
</dd>
<dt id="weavingspace.symmetry.Transform.transform_type"><code class="name">var <span class="ident">transform_type</span> : str</code></dt>
<dd>
<div class="desc"><p>Type of transform, 'rotation', 'reflection', 'translation' or 'identity'.</p></div>
</dd>
<dt id="weavingspace.symmetry.Transform.translation"><code class="name">var <span class="ident">translation</span> : tuple[float]</code></dt>
<dd>
<div class="desc"><p>X and Y coordinates shifts of a translation transform. A glide reflection
may also include this.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.symmetry.Transform.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, geometry: Any) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, geometry:Any) -&gt; Any:
  &#34;&#34;&#34;Applies this transform to supplied shapely geometry and returns result.

  Args:
    geometry (Any): a shapely geometry to transform.
  
  Returns:
    Any: the resulting transformed shapely geometry.
  &#34;&#34;&#34;
  return affine.affine_transform(geometry, self.transform)</code></pre>
</details>
<div class="desc"><p>Applies this transform to supplied shapely geometry and returns result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>Any</code></dt>
<dd>a shapely geometry to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>the resulting transformed shapely geometry.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Transform.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, ax: <function axes at 0x117ecaca0>, **kwargs) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, ax:pyplot.axes, **kwargs) -&gt; pyplot.Axes:
  &#34;&#34;&#34;Draws this transform on the supplied axes. Arguments specific to each
  transform type are supplied as **kwargs and are documented in 
  `draw_rotation`, `draw_reflection`, and `draw_translation`.

  Args:
      ax (pyplot.axes): the axes on which to draw the transform.

  Returns:
      pyplot.Axes: the axes with the rendering of this transform added.
  &#34;&#34;&#34;
  if self.transform_type == &#34;rotation&#34;:
    rotn_args = list(inspect.signature(self.draw_rotation).parameters)
    rotn_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in rotn_args}
    return self.draw_rotation(ax = ax, **rotn_dict)
  elif self.transform_type == &#34;reflection&#34;:
    refn_args = list(inspect.signature(self.draw_reflection).parameters)
    refn_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in refn_args}
    return self.draw_reflection(ax = ax, **refn_dict)
  if self.transform_type == &#34;translation&#34;:
    trans_args = list(inspect.signature(self.draw_translation).parameters)
    trans_dict = {k: kwargs.pop(k) for k in dict(kwargs) if k in trans_args}
    return self.draw_translation(ax = ax, **trans_dict)
  elif self.transform_type == &#34;identity&#34;:
    w = ax.get_window_extent().width
    return ax.set_title(f&#34;{self.transform_type}&#34;, fontsize = w / 20)</code></pre>
</details>
<div class="desc"><p>Draws this transform on the supplied axes. Arguments specific to each
transform type are supplied as **kwargs and are documented in
<code>draw_rotation</code>, <code>draw_reflection</code>, and <code>draw_translation</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>pyplot.axes</code></dt>
<dd>the axes on which to draw the transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pyplot.Axes</code></dt>
<dd>the axes with the rendering of this transform added.</dd>
</dl></div>
</dd>
<dt id="weavingspace.symmetry.Transform.draw_reflection"><code class="name flex">
<span>def <span class="ident">draw_reflection</span></span>(<span>self, ax: matplotlib.axes._axes.Axes, w=5, mirror_length=100, add_title=True) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_reflection(self, ax:pyplot.Axes, w = 5, 
                    mirror_length = 100, add_title = True) -&gt; pyplot.Axes:
  x, y = self.centre.x, self.centre.y
  dx, dy = self.translation
  r = np.sqrt(self.translation[0] ** 2 + self.translation[1] ** 2) 
  mirror = geom.LineString([
    (x - mirror_length / 2 * np.cos(np.radians(self.angle)), 
      y - mirror_length / 2 * np.sin(np.radians(self.angle))),
    (x + mirror_length / 2 * np.cos(np.radians(self.angle)), 
      y + mirror_length / 2 * np.sin(np.radians(self.angle)))])
  gpd.GeoSeries([mirror]).plot(
    ax = ax, color = &#34;r&#34;, lw = 1, ls = &#34;dashdot&#34;, zorder = 5)
  no_slide = np.isclose(r, 0, rtol = 1e-6, atol = 1e-6)
  if not no_slide:
    pyplot.arrow(
      x - dx / 2, y - dy / 2, dx, dy, length_includes_head = True,
      width = w, fc = &#34;k&#34;, ec = None, head_width = w * 6, zorder = 5)
  if add_title:
    w = ax.get_window_extent().width
    ax.set_title(f&#34;{self.transform_type} {np.round(self.angle, 2)}&#34;,
                 fontsize = w / 20)
  return ax</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Transform.draw_rotation"><code class="name flex">
<span>def <span class="ident">draw_rotation</span></span>(<span>self, ax: matplotlib.axes._axes.Axes, radius=200, add_title=True) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_rotation(self, ax:pyplot.Axes, 
                  radius = 200, add_title = True) -&gt; pyplot.Axes:
  x, y = self.centre.x, self.centre.y
  axis = geom.LineString([(x, y), (x + radius * 1.25, y)])
  arc = geom.LineString([
    geom.Point(x + radius * np.cos(np.radians(a)),
                y + radius * np.sin(np.radians(a)))
    for a in np.linspace(0, self.angle, 50)])
  gpd.GeoSeries([self.centre]).plot(
    ax = ax, color = &#34;r&#34;, markersize = 4, zorder = 5)
  gpd.GeoSeries([axis, arc]).plot(ax = ax, color = &#34;r&#34;, lw = .5)
  if add_title:
    w = ax.get_window_extent().width
    ax.set_title(f&#34;{self.transform_type} {np.round(self.angle, 2)}&#34;,
                 fontsize = w / 20)
  return ax</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.symmetry.Transform.draw_translation"><code class="name flex">
<span>def <span class="ident">draw_translation</span></span>(<span>self,<br>ax: matplotlib.axes._axes.Axes,<br>c: shapely.geometry.point.Point,<br>w: float = 5,<br>add_title=True) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_translation(self, ax:pyplot.Axes, c:geom.Point, 
                     w:float = 5, add_title = True) -&gt; pyplot.Axes:
  gpd.GeoSeries([c]).plot(ax = ax, color = &#34;b&#34;)
  pyplot.arrow(c.x, c.y, self.translation[0], self.translation[1], lw = 0.5,
              width = w, fc = &#34;b&#34;, ec = None, head_width = w * 6, zorder = 5)
  if add_title:
    w = ax.get_window_extent().width
    rounded_tr = tuple([np.round(x, 1) for x in self.translation])
    ax.set_title(f&#34;{self.transform_type} {rounded_tr}&#34;,
                 fontsize = w / 20)
  return ax</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.symmetry.KMP_Matcher" href="#weavingspace.symmetry.KMP_Matcher">KMP_Matcher</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.symmetry.KMP_Matcher.find_matches" href="#weavingspace.symmetry.KMP_Matcher.find_matches">find_matches</a></code></li>
<li><code><a title="weavingspace.symmetry.KMP_Matcher.sequence" href="#weavingspace.symmetry.KMP_Matcher.sequence">sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.symmetry.Shape_Matcher" href="#weavingspace.symmetry.Shape_Matcher">Shape_Matcher</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.symmetry.Shape_Matcher.centre" href="#weavingspace.symmetry.Shape_Matcher.centre">centre</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.get_angle_between_polygons" href="#weavingspace.symmetry.Shape_Matcher.get_angle_between_polygons">get_angle_between_polygons</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.get_intersection" href="#weavingspace.symmetry.Shape_Matcher.get_intersection">get_intersection</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.get_polygon_matches" href="#weavingspace.symmetry.Shape_Matcher.get_polygon_matches">get_polygon_matches</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.get_straight_line" href="#weavingspace.symmetry.Shape_Matcher.get_straight_line">get_straight_line</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.identity_transform" href="#weavingspace.symmetry.Shape_Matcher.identity_transform">identity_transform</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.matches" href="#weavingspace.symmetry.Shape_Matcher.matches">matches</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.other" href="#weavingspace.symmetry.Shape_Matcher.other">other</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.s1" href="#weavingspace.symmetry.Shape_Matcher.s1">s1</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.shape" href="#weavingspace.symmetry.Shape_Matcher.shape">shape</a></code></li>
<li><code><a title="weavingspace.symmetry.Shape_Matcher.translation" href="#weavingspace.symmetry.Shape_Matcher.translation">translation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.symmetry.StraightLine" href="#weavingspace.symmetry.StraightLine">StraightLine</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.symmetry.StraightLine.A" href="#weavingspace.symmetry.StraightLine.A">A</a></code></li>
<li><code><a title="weavingspace.symmetry.StraightLine.B" href="#weavingspace.symmetry.StraightLine.B">B</a></code></li>
<li><code><a title="weavingspace.symmetry.StraightLine.C" href="#weavingspace.symmetry.StraightLine.C">C</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.symmetry.Symmetries" href="#weavingspace.symmetry.Symmetries">Symmetries</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.symmetry.Symmetries.get_corner_labels" href="#weavingspace.symmetry.Symmetries.get_corner_labels">get_corner_labels</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_corner_offset" href="#weavingspace.symmetry.Symmetries.get_corner_offset">get_corner_offset</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_reflections" href="#weavingspace.symmetry.Symmetries.get_reflections">get_reflections</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_rotations" href="#weavingspace.symmetry.Symmetries.get_rotations">get_rotations</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_symmetries" href="#weavingspace.symmetry.Symmetries.get_symmetries">get_symmetries</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_symmetry_group_code" href="#weavingspace.symmetry.Symmetries.get_symmetry_group_code">get_symmetry_group_code</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.get_unique_labels" href="#weavingspace.symmetry.Symmetries.get_unique_labels">get_unique_labels</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.matcher" href="#weavingspace.symmetry.Symmetries.matcher">matcher</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.n" href="#weavingspace.symmetry.Symmetries.n">n</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.p_code" href="#weavingspace.symmetry.Symmetries.p_code">p_code</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.p_code_r" href="#weavingspace.symmetry.Symmetries.p_code_r">p_code_r</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.plot" href="#weavingspace.symmetry.Symmetries.plot">plot</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.polygon" href="#weavingspace.symmetry.Symmetries.polygon">polygon</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.reflection_shifts" href="#weavingspace.symmetry.Symmetries.reflection_shifts">reflection_shifts</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.rotation_shifts" href="#weavingspace.symmetry.Symmetries.rotation_shifts">rotation_shifts</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.symmetries" href="#weavingspace.symmetry.Symmetries.symmetries">symmetries</a></code></li>
<li><code><a title="weavingspace.symmetry.Symmetries.symmetry_group" href="#weavingspace.symmetry.Symmetries.symmetry_group">symmetry_group</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.symmetry.Transform" href="#weavingspace.symmetry.Transform">Transform</a></code></h4>
<ul class="two-column">
<li><code><a title="weavingspace.symmetry.Transform.angle" href="#weavingspace.symmetry.Transform.angle">angle</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.apply" href="#weavingspace.symmetry.Transform.apply">apply</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.centre" href="#weavingspace.symmetry.Transform.centre">centre</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.draw" href="#weavingspace.symmetry.Transform.draw">draw</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.draw_reflection" href="#weavingspace.symmetry.Transform.draw_reflection">draw_reflection</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.draw_rotation" href="#weavingspace.symmetry.Transform.draw_rotation">draw_rotation</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.draw_translation" href="#weavingspace.symmetry.Transform.draw_translation">draw_translation</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.offset" href="#weavingspace.symmetry.Transform.offset">offset</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.transform" href="#weavingspace.symmetry.Transform.transform">transform</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.transform_type" href="#weavingspace.symmetry.Transform.transform_type">transform_type</a></code></li>
<li><code><a title="weavingspace.symmetry.Transform.translation" href="#weavingspace.symmetry.Transform.translation">translation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
