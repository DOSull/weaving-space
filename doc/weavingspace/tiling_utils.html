<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.tiling_utils API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tiling_utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="weavingspace.tiling_utils.as_numpy_matrix"><code class="name flex">
<span>def <span class="ident">as_numpy_matrix</span></span>(<span>transform: list[float]) ‑> <built-in function array></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_numpy_matrix(transform:list[float]) -&gt; np.array:
  &#34;&#34;&#34;Converts the supplied shapely affine transform list to an augmented
  affine transform matrix in numpy array form. This makes combining transforms
  much easier.

  Args:
    transform (list[float]): the transform in shapely format.

  Returns:
    np.array: the transform in numpy matrix format.
  &#34;&#34;&#34;
  return np.array([[transform[0], transform[1], transform[4]],
                   [transform[2], transform[3], transform[5]],
                   [           0,            0,            1]])</code></pre>
</details>
<div class="desc"><p>Converts the supplied shapely affine transform list to an augmented
affine transform matrix in numpy array form. This makes combining transforms
much easier.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>the transform in shapely format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>the transform in numpy matrix format.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.as_shapely_transform"><code class="name flex">
<span>def <span class="ident">as_shapely_transform</span></span>(<span>arr: np.array) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_shapely_transform(arr:np.array) -&gt; list[float]:
  &#34;&#34;&#34;Returns the shapely affine transform list equivalent to the supplied
  numpy matrix of a conventional augmented affine transform matrix.

  Args:
    arr (np.array): augmented affine transform matrix of the desired 
      transform.

  Returns:
    list[float]: desired shapely affine transform list of floats.
  &#34;&#34;&#34;
  return [arr[0][0], arr[0][1], arr[1][0], arr[1][1], arr[0][2], arr[1][2]]</code></pre>
</details>
<div class="desc"><p>Returns the shapely affine transform list equivalent to the supplied
numpy matrix of a conventional augmented affine transform matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.array</code></dt>
<dd>augmented affine transform matrix of the desired
transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>desired shapely affine transform list of floats.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.centre_offset"><code class="name flex">
<span>def <span class="ident">centre_offset</span></span>(<span>shape: geom.Polygon, target: tuple[float] = (0, 0)) ‑> tuple[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centre_offset(shape: geom.Polygon,
                  target:tuple[float] = (0, 0)) -&gt; tuple[float]:
  &#34;&#34;&#34;Returns vector required to move centroid of polygon to target.

  Args:
    shape (Polygon): polygon to move.
    target (tuple[float], optional): target to move to.
      Defaults to (0, 0).

  Returns:
    tuple[float]: tuple of x, y movement required.
  &#34;&#34;&#34;
  shape_c = shape.centroid
  return (target[0] - shape_c.x, target[1] - shape_c.y)</code></pre>
</details>
<div class="desc"><p>Returns vector required to move centroid of polygon to target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>polygon to move.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>target to move to.
Defaults to (0, 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[float]</code></dt>
<dd>tuple of x, y movement required.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.combine_transforms"><code class="name flex">
<span>def <span class="ident">combine_transforms</span></span>(<span>transforms: list[list[float]]) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_transforms(transforms:list[list[float]]) -&gt; list[float]:
  &#34;&#34;&#34;Returns a shapely affine transform list that combines the listed
  sequence of transforms applied in order.

  Args:
    transforms (list[list[float]]): sequence of transforms to combine.

  Returns:
    list[float]: a transform tuple combining the supplied transforms applied
      in order, see 
        https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations
  &#34;&#34;&#34;
  result = np.identity(3)
  for t in transforms:
    result = as_numpy_matrix(t) @ result
  return as_shapely_transform(result)</code></pre>
</details>
<div class="desc"><p>Returns a shapely affine transform list that combines the listed
sequence of transforms applied in order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transforms</code></strong> :&ensp;<code>list[list[float]]</code></dt>
<dd>sequence of transforms to combine.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>a transform tuple combining the supplied transforms applied
in order, see
<a href="https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.ensure_cw"><code class="name flex">
<span>def <span class="ident">ensure_cw</span></span>(<span>shape: geom.Polygon) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_cw(shape:geom.Polygon) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns the polygon with its outer boundary vertices in clockwise order.

  It is important to note that shapely.set_precision() imposes clockwise order
  on polygons, and since it is used widely throughout theses modules, it makes
  sense to impose this order.

    Args:
    shape (geom.Polygon): the polygon.

  Returns:
    geom.Polygon: the polygon in clockwise order.
  &#34;&#34;&#34;
  if geom.LinearRing(shape.exterior.coords).is_ccw:
    return shape.reverse()
  else:
    return shape</code></pre>
</details>
<div class="desc"><p>Returns the polygon with its outer boundary vertices in clockwise order.</p>
<p>It is important to note that shapely.set_precision() imposes clockwise order
on polygons, and since it is used widely throughout theses modules, it makes
sense to impose this order.</p>
<p>Args:
shape (geom.Polygon): the polygon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>the polygon in clockwise order.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.geometry_matches"><code class="name flex">
<span>def <span class="ident">geometry_matches</span></span>(<span>geom1: geom.Polygon, geom2: geom.Polygon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geometry_matches(geom1:geom.Polygon, geom2:geom.Polygon):
  a = geom1.area
  return np.isclose(a, geom1.intersection(geom2).area,
                    rtol = RESOLUTION * 100, atol=RESOLUTION * 100)
  return shapely.equals_exact(
    geom1.normalize(), geom2.normalize(), RESOLUTION * 10)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_utils.get_angle_bisector"><code class="name flex">
<span>def <span class="ident">get_angle_bisector</span></span>(<span>shape: geom.Polygon, v=0) ‑> shapely.geometry.linestring.LineString</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_angle_bisector(shape:geom.Polygon, v = 0) -&gt; geom.LineString:
  &#34;&#34;&#34;Returns a line which is the angle bisector of the specified corner of the
  supplied polygon.

  Args:
      shape (geom.Polygon): the polygon
      v (int, optional): index of the corner whose bisector is required. 
      Defaults to 0.

  Returns:
      geom.LineString: line which bisects the specified corner.
  &#34;&#34;&#34;
  pts = get_corners(shape, repeat_first = False)
  n = len(pts)
  p0 = pts[v % n]
  p1 = pts[(v + 1) % n]
  p2 = pts[(v - 1) % n]
  d01 = p0.distance(p1)
  d02 = p0.distance(p2)
  if d01 &lt; d02:
    p2 = geom.LineString([p0, p2]).interpolate(d01)
  else:
    p1 = geom.LineString([p0, p1]).interpolate(d02)
  m = geom.Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)
  # we have to scale this to much larger in case of an angle near 180
  return affine.scale(geom.LineString([p0, m]), 10, 10, origin = p0)</code></pre>
</details>
<div class="desc"><p>Returns a line which is the angle bisector of the specified corner of the
supplied polygon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>the polygon</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>index of the corner whose bisector is required. </dd>
</dl>
<p>Defaults to 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.LineString</code></dt>
<dd>line which bisects the specified corner.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_apothem_length"><code class="name flex">
<span>def <span class="ident">get_apothem_length</span></span>(<span>shape: geom.Polygon) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_apothem_length(shape:geom.Polygon) -&gt; float:
  return 2 * shape.area / geom.LineString(shape.exterior.coords).length</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_utils.get_bounding_ellipse"><code class="name flex">
<span>def <span class="ident">get_bounding_ellipse</span></span>(<span>shapes: gpd.GeoSeries, mag: float = 1.0) ‑> geopandas.geoseries.GeoSeries</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_ellipse(shapes:gpd.GeoSeries, 
                         mag:float = 1.0) -&gt; gpd.GeoSeries:
  &#34;&#34;&#34;Returns an ellipse containing the supplied shapes.

  The method used is to calculate the size of square that would contain
  the shapes, if they had an aspect ratio 1, then stretch the circle in
  the x, y directions according to the actual aspect ratio of the shapes.

  Args:
    shapes (gpd.GeoSeries): the shapes to be contained.
    mag (float, optional): optionally increase the size of the returned
      ellipse by this scale factor. Defaults to 1.0.

  Returns:
    gpd.GeoSeries: the set of shapes.
  &#34;&#34;&#34;

  w, h, l, b = get_width_height_left_bottom(shapes)

  c = geom.Point(l + w / 2, b + h / 2)
  r = min(w, h) * np.sqrt(2)
  circle = [c.buffer(r)]
  return gridify(gpd.GeoSeries(circle, crs = shapes.crs).scale(
    w / r * mag / np.sqrt(2), h / r * mag / np.sqrt(2), origin = c))</code></pre>
</details>
<div class="desc"><p>Returns an ellipse containing the supplied shapes.</p>
<p>The method used is to calculate the size of square that would contain
the shapes, if they had an aspect ratio 1, then stretch the circle in
the x, y directions according to the actual aspect ratio of the shapes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shapes</code></strong> :&ensp;<code>gpd.GeoSeries</code></dt>
<dd>the shapes to be contained.</dd>
<dt><strong><code>mag</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>optionally increase the size of the returned
ellipse by this scale factor. Defaults to 1.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoSeries</code></dt>
<dd>the set of shapes.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_clean_polygon"><code class="name flex">
<span>def <span class="ident">get_clean_polygon</span></span>(<span>shape: Union[geom.MultiPolygon, geom.Polygon]) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clean_polygon(
    shape:Union[geom.MultiPolygon,geom.Polygon]) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns polygon with any successive corners that are co-linear along a 
  side or very close to one another removed. 
  
  Particularly useful for tidying polygons weave tilings that have been 
  assembled from multiple &#39;cells&#39; in the weave grid.

  Args:
    shape (Union[geom.MultiPolygon,geom.Polygon]): polygon to clean.

  Returns:
    geom.Polygon: cleaned polygon.
  &#34;&#34;&#34;
  if isinstance(shape, geom.MultiPolygon):
    return geom.MultiPolygon([get_clean_polygon(p) for p in shape.geoms])
  else:
    corners = get_corners(shape, repeat_first = False)
    # first remove any &#39;near neighbour&#39; corners
    distances = get_side_lengths(shape)
    to_remove = [np.isclose(d, 0, rtol = RESOLUTION, atol = 10 * RESOLUTION) 
                 for d in distances]
    corners = [c for c, r in zip(corners, to_remove) if not r]
    # next remove any that are colinear
    p = geom.Polygon(corners)
    corners = get_corners(p, repeat_first = False)
    angles = get_interior_angles(p)
    to_remove = [np.isclose(a, 0, rtol = RESOLUTION, atol = RESOLUTION) or
                 np.isclose(a, 180, rtol = RESOLUTION, atol = RESOLUTION)
                 for a in angles]
    corners = [c for c, r in zip(corners, to_remove) if not r]
    return gridify(geom.Polygon(corners))</code></pre>
</details>
<div class="desc"><p>Returns polygon with any successive corners that are co-linear along a
side or very close to one another removed. </p>
<p>Particularly useful for tidying polygons weave tilings that have been
assembled from multiple 'cells' in the weave grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>Union[geom.MultiPolygon,geom.Polygon]</code></dt>
<dd>polygon to clean.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>cleaned polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_collapse_distance"><code class="name flex">
<span>def <span class="ident">get_collapse_distance</span></span>(<span>geometry: geom.Polygon) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collapse_distance(geometry:geom.Polygon) -&gt; float:
  &#34;&#34;&#34;Returns the distance under which the supplied polygon will shrink
  to nothing if negatively buffered by that distance.

  Performs a binary search between an upper bound based on the radius of
  the circle of equal area to the polygon, and 0.

  Args:
    geometry (geom.Polygon): the polygon.

  Returns:
    float: its collapse distance.
  &#34;&#34;&#34;
  if is_convex(geometry):
    return get_apothem_length(geometry)
  radius = np.sqrt(geometry.area / np.pi)
  lower = 0
  upper = radius
  delta = 1e12
  stop_delta = radius / 1000
  while delta &gt; stop_delta:
    new_r = (lower + upper) / 2
    if geometry.buffer(-new_r).area &gt; 0:
      lower = new_r
      delta = upper - new_r
    else:
      upper = new_r
      delta = new_r - lower
  return new_r</code></pre>
</details>
<div class="desc"><p>Returns the distance under which the supplied polygon will shrink
to nothing if negatively buffered by that distance.</p>
<p>Performs a binary search between an upper bound based on the radius of
the circle of equal area to the polygon, and 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>the polygon.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>its collapse distance.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_corners"><code class="name flex">
<span>def <span class="ident">get_corners</span></span>(<span>shape: geom.Polygon, repeat_first: bool = True) ‑> list[shapely.geometry.point.Point]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corners(shape:geom.Polygon,
                repeat_first:bool = True) -&gt; list[geom.Point]:
  &#34;&#34;&#34;Returns a list of geom.Points around the boundary of a polygon, optionally
  repeating the first. Does no simplification (e.g. if a line segment has a 
  &#39;corner&#39; along its length, it is NOT removed; see get_clean_polygon for 
  that). Points have precision set to the package default tiling_utils.
  RESOLUTION.

  Args:
    shape (geom.Polygon): polygon whose corners are required.
    repeat_first (bool, optional): if True the first corner is repeated in the 
      returned list, if False it is omitted. Defaults to True.

  Returns:
    list[geom.Point]: list of geom.Point vertices of the polygon.
  &#34;&#34;&#34;
  corners = [gridify(geom.Point(pt)) for pt in shape.exterior.coords]
  if repeat_first:
    return corners
  else:
    return corners[:-1]</code></pre>
</details>
<div class="desc"><p>Returns a list of geom.Points around the boundary of a polygon, optionally
repeating the first. Does no simplification (e.g. if a line segment has a
'corner' along its length, it is NOT removed; see get_clean_polygon for
that). Points have precision set to the package default tiling_utils.
RESOLUTION.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon whose corners are required.</dd>
<dt><strong><code>repeat_first</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True the first corner is repeated in the
returned list, if False it is omitted. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.Point]</code></dt>
<dd>list of geom.Point vertices of the polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_dual_tile_unit"><code class="name flex">
<span>def <span class="ident">get_dual_tile_unit</span></span>(<span>unit: TileUnit) ‑> gpd.GeoDataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dual_tile_unit(unit: TileUnit) -&gt; gpd.GeoDataFrame:
  &#34;&#34;&#34;Converts supplied TileUnit to a candidate GeoDataFrame of its dual
  TileUnit.

  NOTE: this is complicated and not remotely guaranteed to work!
  a particular issue is that where to place the vertices of the faces
  of the dual with respect to the tiles in the original is ill-defined.
  This is because the dual process is topologically not metrically defined,
  so that exact vertex locations are ambiguous. Tiling duality is defined in
  Section 4.2 of Grunbaum B, Shephard G C, 1987 _Tilings and Patterns_ (W. H.
  Freeman and Company, New York)

  NOTE: In general, this method will work only if all supplied tiles are
  regular polygons. A known exception is if the only non-regular polygons are
  triangles.

  NOTE: &#39;clean&#39; polygons are required. If supplied polygons have messy
  vertices with multiple points where there is only one proper point, bad
  things are likely to happen! Consider using `clean_polygon()` on the
  tile geometries.

  Because of the above limitations, we only return a GeoDataFrame
  for inspection. However some `weavingspace.tile_unit.TileUnit` setup
  methods in `weavingspace.tiling_geometries` use this method, where we are
  confident the returned dual is valid.

  Args:
    unit (TileUnit): the tiling for which the dual is required.

  Returns:
    gpd.GeoDataFrame: GeoDataFrame that could be the tiles attribute for
      a TileUnit of the dual tiling.
  &#34;&#34;&#34;
  # get a local patch of this Tiling
  local_patch = unit.get_local_patch(r = 1, include_0 = True)
  # Find the interior points of these tiles - these will be guaranteed
  # to have a sequence of surrounding tiles incident on them
  interior_pts = _get_interior_vertices(local_patch)
  # Compile a list of the polygons incident on the interior points
  cycles = []
  for pt in interior_pts:
    cycles.append(
      set([poly_id for poly_id, p in enumerate(local_patch.geometry)
           if pt.distance(p) &lt; RESOLUTION * 2]))
  # convert the polygon ID sequences to (centroid.x, centroid.y, ID) tuples
  dual_faces = []
  for cycle in cycles:
    ids, pts = [], []
    for poly_id in cycle:
      ids.append(local_patch.tile_id[poly_id])
      poly = local_patch.geometry[poly_id]
      pts.append(get_incentre(poly))
    # sort them into CW order so they are well formed
    sorted_coords = sort_cw([(pt.x, pt.y, id)
                              for pt, id in zip(pts, ids)])
    dual_faces.append(
      (geom.Polygon([(pt_id[0], pt_id[1]) for pt_id in sorted_coords]),
       &#34;&#34;.join([pt_id[2] for pt_id in sorted_coords])))
  # ensure the resulting face centroids are inside the original tile
  # displaced a little to avoid uncertainties at corners/edges
  # TODO: Check  the logic of this - it seems like dumb luck that it works...
  dual_faces = [(f, id) for f, id in dual_faces
                if affine.translate(
                  unit.prototile.geometry[0], RESOLUTION * 10, 
                  RESOLUTION * 10).contains(f.centroid)]
  gdf = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: [f[1] for f in dual_faces]}, crs = unit.crs,
    geometry = gridify(gpd.GeoSeries([f[0] for f in dual_faces])))
  # ensure no duplicates
  gdf = gdf.dissolve(by = &#34;tile_id&#34;, as_index = False).explode(
    index_parts = False, ignore_index = True)

  gdf.tile_id = relabel(gdf.tile_id)
  return gdf</code></pre>
</details>
<div class="desc"><p>Converts supplied TileUnit to a candidate GeoDataFrame of its dual
TileUnit.</p>
<p>NOTE: this is complicated and not remotely guaranteed to work!
a particular issue is that where to place the vertices of the faces
of the dual with respect to the tiles in the original is ill-defined.
This is because the dual process is topologically not metrically defined,
so that exact vertex locations are ambiguous. Tiling duality is defined in
Section 4.2 of Grunbaum B, Shephard G C, 1987 <em>Tilings and Patterns</em> (W. H.
Freeman and Company, New York)</p>
<p>NOTE: In general, this method will work only if all supplied tiles are
regular polygons. A known exception is if the only non-regular polygons are
triangles.</p>
<p>NOTE: 'clean' polygons are required. If supplied polygons have messy
vertices with multiple points where there is only one proper point, bad
things are likely to happen! Consider using <code>clean_polygon()</code> on the
tile geometries.</p>
<p>Because of the above limitations, we only return a GeoDataFrame
for inspection. However some <code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> setup
methods in <code><a title="weavingspace.tiling_geometries" href="tiling_geometries.html">weavingspace.tiling_geometries</a></code> use this method, where we are
confident the returned dual is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the tiling for which the dual is required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>GeoDataFrame that could be the tiles attribute for
a TileUnit of the dual tiling.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_inner_angle"><code class="name flex">
<span>def <span class="ident">get_inner_angle</span></span>(<span>p1: geom.Point, p2: geom.Point, p3: geom.Point) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_inner_angle(p1:geom.Point, p2:geom.Point, p3:geom.Point) -&gt; float:
  r&#34;&#34;&#34;Returns the angle (in degrees) between line p1-p2 and p2-p3, i.e., the 
  angle A below
  
            p2
           / \ 
          / A \ 
        p1     p3
  
  Args:
    p1 (geom.Point): first point.
    p2 (geom.Point): second &#39;corner&#39; point.
    p3 (geom.Point): third point.

  Returns:
      float: angle in degrees.
  &#34;&#34;&#34;
  return np.degrees(np.arctan2(p3.y - p2.y, p3.x - p2.x) -
                    np.arctan2(p1.y - p2.y, p1.x - p2.x)) % 360</code></pre>
</details>
<div class="desc"><p>Returns the angle (in degrees) between line p1-p2 and p2-p3, i.e., the
angle A below</p>
<pre><code>      p2
     / \ 
    / A \ 
  p1     p3
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p1</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>first point.</dd>
<dt><strong><code>p2</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>second 'corner' point.</dd>
<dt><strong><code>p3</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>third point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>angle in degrees.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_interior_angles"><code class="name flex">
<span>def <span class="ident">get_interior_angles</span></span>(<span>shape: geom.Polygon) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_interior_angles(shape:geom.Polygon) -&gt; list[float]:
  &#34;&#34;&#34;Returns angles (in degrees) between successive edges of a polygon. No 
  polygon simplification is carried out so some angles may be 180 (i.e. a 
  &#39;corner&#39; along a side, such that successive sides are colinear). 

  Args:
    shape (geom.Polygon): polygon whose angles are required.

  Returns:
    list[float]: list of angles.
  &#34;&#34;&#34;
  corners = get_corners(shape, repeat_first = False)
  wrap_corners = corners[-1:] + corners + corners[:1]
  triples = zip(wrap_corners[:-2], wrap_corners[1:-1], wrap_corners[2:])
  return [get_inner_angle(p1, p2, p3) for p1, p2, p3 in triples]</code></pre>
</details>
<div class="desc"><p>Returns angles (in degrees) between successive edges of a polygon. No
polygon simplification is carried out so some angles may be 180 (i.e. a
'corner' along a side, such that successive sides are colinear). </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon whose angles are required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>list of angles.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_largest_polygon"><code class="name flex">
<span>def <span class="ident">get_largest_polygon</span></span>(<span>polygons: gpd.GeoSeries) ‑> geopandas.geoseries.GeoSeries</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_largest_polygon(polygons:gpd.GeoSeries) -&gt; gpd.GeoSeries:
  &#34;&#34;&#34;Returns the largest polygon in a GeoSeries as a GeoSeries of one polygon.

  Args:
    polygons (gpd.GeoSeries): the set of polygons to pick from.

  Returns:
    gpd.GeoSeries: the largest polygon.
  &#34;&#34;&#34;
  actual_polygons = [p for p in polygons.geometry
                     if isinstance(p, (geom.Polygon, geom.MultiPolygon))]
  areas = [p.area for p in actual_polygons]
  max_area = max(areas)
  return gpd.GeoSeries([actual_polygons[areas.index(max_area)]])</code></pre>
</details>
<div class="desc"><p>Returns the largest polygon in a GeoSeries as a GeoSeries of one polygon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygons</code></strong> :&ensp;<code>gpd.GeoSeries</code></dt>
<dd>the set of polygons to pick from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoSeries</code></dt>
<dd>the largest polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_outer_angle"><code class="name flex">
<span>def <span class="ident">get_outer_angle</span></span>(<span>p1: geom.Point, p2: geom.Point, p3: geom.Point) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_outer_angle(p1:geom.Point, p2:geom.Point, p3:geom.Point) -&gt; float:
  r&#34;&#34;&#34;Returns outer angle (in degrees) between lines p1-p2 and p2-p3, i.e., the 
  angle A below
                
              /
             /
            p2 A
           / \ 
          /   \ 
        p1     p3
  
  Args:
    p1 (geom.Point): first point.
    p2 (geom.Point): second &#39;corner&#39; point.
    p3 (geom.Point): third point.

  Returns:
    float: angle in degrees.
  &#34;&#34;&#34;
  return 180 - get_inner_angle(p1, p2, p3)</code></pre>
</details>
<div class="desc"><p>Returns outer angle (in degrees) between lines p1-p2 and p2-p3, i.e., the
angle A below</p>
<pre><code>        /
       /
      p2 A
     / \ 
    /   \ 
  p1     p3
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p1</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>first point.</dd>
<dt><strong><code>p2</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>second 'corner' point.</dd>
<dt><strong><code>p3</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>third point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>angle in degrees.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_polygon_sector"><code class="name flex">
<span>def <span class="ident">get_polygon_sector</span></span>(<span>polygon: geom.Polygon, start: float = 0.0, end: float = 1.0) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polygon_sector(polygon:geom.Polygon, start:float = 0.0,
                       end:float = 1.0) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns a sector of the provided Polygon.

  The returned sector is a section of the polygon boundary between the
  normalized start and end positions, and including the polygon centroid.
  Should (probably) only be applied to convex polygons.

  Args:
    shape (geom.Polygon): the Polygon.
    start (float): normalized start position along the boundary. Defaults to
      0.
    end (float): normalized start position along the boundary. Defaults to
      1.

  Returns:
    geom.Polygon: the requested polygon sector.
  &#34;&#34;&#34;
  if start == end:
    # must return a null polygon since the calling context
    # expects to get something back... which most likely
    # is needed to align with other data
    return geom.Polygon()
  if start * end &lt; 0:
    # either side of 0/1 so assume required sector includes 0
    e1, e2 = min(start, end), max(start, end)
    arc1 = shapely.ops.substring(geom.LineString(polygon.exterior.coords),
                                 np.mod(e1, 1), 1, normalized = True)
    arc2 = shapely.ops.substring(geom.LineString(polygon.exterior.coords),
                                 0, e2, normalized = True)
    sector = geom.Polygon([polygon.centroid] +
               list(arc1.coords) +
               list(arc2.coords)[1:])
  else:
    arc = shapely.ops.substring(geom.LineString(polygon.exterior.coords),
                                start, end, normalized = True)
    sector = geom.Polygon([polygon.centroid] + list(arc.coords))
  return gridify(sector)</code></pre>
</details>
<div class="desc"><p>Returns a sector of the provided Polygon.</p>
<p>The returned sector is a section of the polygon boundary between the
normalized start and end positions, and including the polygon centroid.
Should (probably) only be applied to convex polygons.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>the Polygon.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code></dt>
<dd>normalized start position along the boundary. Defaults to
0.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code></dt>
<dd>normalized start position along the boundary. Defaults to
1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>the requested polygon sector.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_reflection_transform"><code class="name flex">
<span>def <span class="ident">get_reflection_transform</span></span>(<span>angle: float, centre: tuple[float] = None) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reflection_transform(
    angle:float, centre:tuple[float] = None) -&gt; list[float]:
  &#34;&#34;&#34;Returns a shapely affine transform tuple that will reflect a shape
  in a line at the specified angle, optionally through a specified centre
  point.

  Args:
    angle (float): angle to the x-axis of the line of reflection.
    centre (tuple[float], optional): point through which the line of 
      reflection passes. Defaults to None, which
      will in turn be converted to (0, 0).

  Returns:
    list[float]: a six item list of floats, per the shapely.affinity.
      affine_transform method, see 
        https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations
  &#34;&#34;&#34;
  if centre is None or np.allclose((0, 0), centre, atol = RESOLUTION):
    A = 2 * np.radians(angle)
    return (np.cos(A), np.sin(A), np.sin(A), -np.cos(A), 0, 0)
  dx, dy = centre
  t1 = get_translation_transform(-dx, -dy)
  r = get_reflection_transform(angle)
  t2 = get_translation_transform(dx, dy)
  return combine_transforms([t1, r, t2])</code></pre>
</details>
<div class="desc"><p>Returns a shapely affine transform tuple that will reflect a shape
in a line at the specified angle, optionally through a specified centre
point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>angle to the x-axis of the line of reflection.</dd>
<dt><strong><code>centre</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>point through which the line of
reflection passes. Defaults to None, which
will in turn be converted to (0, 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>a six item list of floats, per the shapely.affinity.
affine_transform method, see
<a href="https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_regular_polygon"><code class="name flex">
<span>def <span class="ident">get_regular_polygon</span></span>(<span>spacing, n: int) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_regular_polygon(spacing, n:int) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns regular polygon with n sides centered on (0, 0) with a horizontal base, and height given by spacing.

  Args:
    spacing (_type_): required height.
    n (int): number of sides.

  Returns:
    geom.Polygon: required geom.Polygon.
  &#34;&#34;&#34;
  R = spacing / np.cos(np.radians(180 / n)) / 2
  a0 = -90 + 180 / n
  a_diff = 360 / n
  angles = [a0 + a * a_diff for a in range(n)]
  corners = [(R * np.cos(np.radians(a)),
              R * np.sin(np.radians(a))) for a in angles]
  return gridify(geom.Polygon(corners))</code></pre>
</details>
<div class="desc"><p>Returns regular polygon with n sides centered on (0, 0) with a horizontal base, and height given by spacing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spacing</code></strong> :&ensp;<code>_type_</code></dt>
<dd>required height.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of sides.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>required geom.Polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_rotation_transform"><code class="name flex">
<span>def <span class="ident">get_rotation_transform</span></span>(<span>angle: float, centre: tuple[float] = None) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rotation_transform(
    angle:float, centre:tuple[float] = None) -&gt; list[float]:
  &#34;&#34;&#34;Returns the shapely affine transform tuple for a rotation, optionally
  about a supplied centre point.

  Args:
      angle (float): the angle of rotation (in degrees).
      centre (tuple[float], optional): An option centre location. Defaults to 
      None, which will in turn be converted to (0, 0).

  Returns:
    list[float]: a six item list of floats, per the shapely.affinity.
      affine_transform method, see 
        https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations
  &#34;&#34;&#34;
  if centre is None or np.allclose((0, 0), centre, atol = RESOLUTION):
    a = np.radians(angle)
    return [np.cos(a), -np.sin(a), np.sin(a), np.cos(a), 0, 0]
  
  dx, dy = centre
  t1 = get_translation_transform(-dx, -dy)
  r = get_rotation_transform(angle)
  t2 = get_translation_transform(dx, dy)
  return combine_transforms([t1, r, t2])</code></pre>
</details>
<div class="desc"><p>Returns the shapely affine transform tuple for a rotation, optionally
about a supplied centre point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>the angle of rotation (in degrees).</dd>
<dt><strong><code>centre</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>An option centre location. Defaults to </dd>
</dl>
<p>None, which will in turn be converted to (0, 0).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>a six item list of floats, per the shapely.affinity.
affine_transform method, see
<a href="https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_side_bearings"><code class="name flex">
<span>def <span class="ident">get_side_bearings</span></span>(<span>shape: geom.Polygon) ‑> tuple[tuple[float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_bearings(shape:geom.Polygon) -&gt; tuple[tuple[float]]:
  &#34;&#34;&#34;Returns a list of angles (in degrees) between the sides of a polygon and
  the positive x-axis, when proceeding from the first point in each side to its
  end point. This should usually be CW around the polygon.

  Args:
    shape (geom.Polygon): polygon whose side bearings are required.

  Returns:
    tuple[tuple[float]]: tuple of bearings of each edge.
  &#34;&#34;&#34;
  return tuple([np.degrees(np.arctan2(
    e.coords[1][1] - e.coords[0][1], e.coords[1][0] - e.coords[0][0])) 
    for e in get_sides(shape)])</code></pre>
</details>
<div class="desc"><p>Returns a list of angles (in degrees) between the sides of a polygon and
the positive x-axis, when proceeding from the first point in each side to its
end point. This should usually be CW around the polygon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon whose side bearings are required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[tuple[float]]</code></dt>
<dd>tuple of bearings of each edge.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_side_bisector"><code class="name flex">
<span>def <span class="ident">get_side_bisector</span></span>(<span>shape: geom.Polygon, i: int = 0) ‑> shapely.geometry.linestring.LineString</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_bisector(shape:geom.Polygon, i:int = 0) -&gt; geom.LineString:
  return affine.scale(affine.rotate(get_sides(shape)[i], 90), 100, 100)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_utils.get_side_lengths"><code class="name flex">
<span>def <span class="ident">get_side_lengths</span></span>(<span>shape: geom.Polygon) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_lengths(shape:geom.Polygon) -&gt; list[float]:
  &#34;&#34;&#34;Returns list of lengths of polygon sides. No simplification for corners
  along sides is carried out.

  Args:
    shape (geom.Polygon): polygon whose edge lengths are required.

  Returns:
    list[float]: list of side lengths.
  &#34;&#34;&#34;
  corners = get_corners(shape)
  return [p1.distance(p2) for p1, p2 in zip(corners[:-1], corners[1:])]</code></pre>
</details>
<div class="desc"><p>Returns list of lengths of polygon sides. No simplification for corners
along sides is carried out.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon whose edge lengths are required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>list of side lengths.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_sides"><code class="name flex">
<span>def <span class="ident">get_sides</span></span>(<span>shape: geom.Polygon) ‑> list[shapely.geometry.linestring.LineString]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sides(shape:geom.Polygon) -&gt; list[geom.LineString]:
  &#34;&#34;&#34;Returns polygon sides as a list of geom.LineStrings, with resolution set
  to the package default tiling_utils.RESOLUTION. No simplification for 
  successive colinear sides is carried out.

  Args:
    shape (geom.Polygon): polygon whose edges are required.

  Returns:
    list[geom.LineString]: list of geom.LineString sides of the polygon.
  &#34;&#34;&#34;
  corners = get_corners(shape)
  return [gridify(geom.LineString([p1, p2]))
          for p1, p2 in zip(corners[:-1], corners[1:])]</code></pre>
</details>
<div class="desc"><p>Returns polygon sides as a list of geom.LineStrings, with resolution set
to the package default tiling_utils.RESOLUTION. No simplification for
successive colinear sides is carried out.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon whose edges are required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.LineString]</code></dt>
<dd>list of geom.LineString sides of the polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_strand_ids"><code class="name flex">
<span>def <span class="ident">get_strand_ids</span></span>(<span>strands_spec: str) ‑> tuple[list[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strand_ids(strands_spec: str) -&gt; tuple[list[str]]:
  &#34;&#34;&#34;Conversts a strands specification string to a list of lists of strand
  labels.

  Args:
    strands_spec (str): string format &#34;a|bc|(de)f&#34; | separates strands in
      each direction and () designates combining labels into a single
      strand that will be sliced lengthwise. Example output:

        &#34;a|bc|(de)f&#34; -&gt; ([&#34;a&#34;], [&#34;b&#34;, &#34;c&#34;], [&#34;de&#34;, &#34;f&#34;])

    Superflous parentheses are removed, but no other error-checks are
      applied.

  Returns:
    tuple[str]: tuple of lists of labels for each set of strands.
  &#34;&#34;&#34;
  strand_ids = [_parse_strand_label(s) for s in strands_spec.split(&#34;|&#34;)]
  strand_ids = strand_ids if len(strand_ids) == 3 else strand_ids + [[&#34;&#34;]]
  return tuple(strand_ids)</code></pre>
</details>
<div class="desc"><p>Conversts a strands specification string to a list of lists of strand
labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>strands_spec</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>string format "a|bc|(de)f" | separates strands in
each direction and () designates combining labels into a single
strand that will be sliced lengthwise. Example output:</p>
<p>"a|bc|(de)f" -&gt; (["a"], ["b", "c"], ["de", "f"])</p>
</dd>
</dl>
<p>Superflous parentheses are removed, but no other error-checks are
applied.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[str]</code></dt>
<dd>tuple of lists of labels for each set of strands.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_tiling_edges"><code class="name flex">
<span>def <span class="ident">get_tiling_edges</span></span>(<span>tiles: gpd.GeoSeries) ‑> geopandas.geoseries.GeoSeries</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiling_edges(tiles:gpd.GeoSeries) -&gt; gpd.GeoSeries:
  &#34;&#34;&#34;Returns linestring GeoSeries from supplied polygon GeoSeries.

  This is used to allow display of edges of tiles in legend when they are
  masked by an ellipse (if we instead clip polygons then the ellipse edge
  will also show in the result.)

  Args:
    shapes (gpd.GeoSeries): Polygons to convert.

  Returns:
    gpd.GeoSeries: LineStrings from the supplied Polygons.
  &#34;&#34;&#34;
  tiles = tiles.explode(ignore_index = True)
  edges = [geom.LineString(p.exterior.coords) for p in tiles]
  return gpd.GeoSeries(edges, crs = tiles.crs)</code></pre>
</details>
<div class="desc"><p>Returns linestring GeoSeries from supplied polygon GeoSeries.</p>
<p>This is used to allow display of edges of tiles in legend when they are
masked by an ellipse (if we instead clip polygons then the ellipse edge
will also show in the result.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shapes</code></strong> :&ensp;<code>gpd.GeoSeries</code></dt>
<dd>Polygons to convert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoSeries</code></dt>
<dd>LineStrings from the supplied Polygons.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.get_translation_transform"><code class="name flex">
<span>def <span class="ident">get_translation_transform</span></span>(<span>dx: float, dy: float) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_translation_transform(dx:float, dy:float) -&gt; list[float]:
  &#34;&#34;&#34;Returns the shapely affine transform tuple for a translation.

  Args:
      dx (float): translation distance in x direction.
      dy (float): translation distance in y direction.

  Returns:
    list[float]: a six item list of floats, per the shapely.affinity.
    affine_transform method, see 
      https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations
  &#34;&#34;&#34;
  return [1, 0, 0, 1, dx, dy]</code></pre>
</details>
<div class="desc"><p>Returns the shapely affine transform tuple for a translation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>translation distance in x direction.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>translation distance in y direction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>a six item list of floats, per the shapely.affinity.</dd>
</dl>
<p>affine_transform method, see
<a href="https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations">https://shapely.readthedocs.io/en/stable/manual.html#affine-transformations</a></p></div>
</dd>
<dt id="weavingspace.tiling_utils.get_width_height_left_bottom"><code class="name flex">
<span>def <span class="ident">get_width_height_left_bottom</span></span>(<span>gs: gpd.GeoSeries) ‑> tuple[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_height_left_bottom(gs:gpd.GeoSeries) -&gt; tuple[float]:
  &#34;&#34;&#34;Returns width, height, left and bottom limits of a GeoSeries

  Args:
    gs (geopandas.GeoSeries): GeoSeries for which limits are required.

  Returns:
    tuple: four float values of width, height, left and bottom of gs.
  &#34;&#34;&#34;
  extent = gs.total_bounds
  return (extent[2] - extent[0], extent[3] - extent[1],
      extent[0], extent[1])</code></pre>
</details>
<div class="desc"><p>Returns width, height, left and bottom limits of a GeoSeries</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gs</code></strong> :&ensp;<code>geopandas.GeoSeries</code></dt>
<dd>GeoSeries for which limits are required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>four float values of width, height, left and bottom of gs.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.gridify"><code class="name flex">
<span>def <span class="ident">gridify</span></span>(<span>gs: Union[gpd.GeoSeries, gpd.GeoDataFrame, geom.Polygon]) ‑> geopandas.geoseries.GeoSeries | geopandas.geodataframe.GeoDataFrame | shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gridify(
      gs:Union[gpd.GeoSeries, gpd.GeoDataFrame, geom.Polygon]
    ) -&gt; Union[gpd.GeoSeries, gpd.GeoDataFrame, geom.Polygon]:
  &#34;&#34;&#34;Returns the supplied GeoSeries rounded to the specified precision.

  Args:
    gs (gpd.GeoSeries): geometries to gridify.
    precision (int, optional): digits of precision. Defaults to 6.

  Returns:
    gpd.GeoSeries: the rounded geometries.
  &#34;&#34;&#34;
  # return gpd.GeoSeries(
  #   list(gs.apply(
  #     wkt.dumps, rounding_precision = precision).apply(wkt.loads)))
  if isinstance(gs, (geom.Polygon, geom.Point, geom.MultiPoint,
                     geom.MultiPolygon, geom.LineString)) :
    return shapely.set_precision(gs, grid_size = RESOLUTION)
  if isinstance(gs, gpd.GeoSeries):
    return gpd.GeoSeries(
      [shapely.set_precision(g, grid_size = RESOLUTION) for g in list(gs)],
      crs = gs.crs)
  if isinstance(gs, gpd.GeoDataFrame):
    gs.geometry = gridify(gs.geometry)
    return gs</code></pre>
</details>
<div class="desc"><p>Returns the supplied GeoSeries rounded to the specified precision.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gs</code></strong> :&ensp;<code>gpd.GeoSeries</code></dt>
<dd>geometries to gridify.</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>digits of precision. Defaults to 6.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoSeries</code></dt>
<dd>the rounded geometries.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.incentre"><code class="name flex">
<span>def <span class="ident">incentre</span></span>(<span>shape: geom.Polygon) ‑> shapely.geometry.point.Point</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_incentre(shape:geom.Polygon) -&gt; geom.Point:
  &#34;&#34;&#34;A different polygon centre, which produces better results for some
  dual tilings where tiles are not regular polygons... see
  https://en.wikipedia.org/wiki/Incenter

  This method relies on the polygon being tangential, i.e. there is an
  inscribed circle to which all sides of the polygon are tangent. It will
  work on all the polygons encountered in the Laves tilings, but is not
  guaranteed to work on all polygons.

  Given that the polygon is tangential, the radius of the inscribed circle is
  the [apothem of the polygon](https://en.wikipedia.org/wiki/Apothem) given
  by 2 x Area / Perimeter. We apply a parallel offset of this size to two
  sides of the polygon and find their intersection to determine the centre of
  the circle, givng the incentre of the polygon.

    Args:
    shape (geom.Polygon): the polygon.

  Returns:
    geom.Point: the incentre of the polygon.
  &#34;&#34;&#34;
  if is_regular_polygon(shape):
    return shape.centroid
  shape = ensure_cw(shape)
  if is_convex(shape):
    if is_tangential(shape):  # find the incentre
      corners = get_corners(shape, repeat_first = False)
      r = get_apothem_length(shape)
      e1 = geom.LineString(corners[:2]).parallel_offset(r, side = &#34;right&#34;)
      e2 = geom.LineString(corners[1:3]).parallel_offset(r, side = &#34;right&#34;)
      c = e1.intersection(e2)
      # is_tangential is unreliable, and sometimes we get to here and do not
      # get a Point, but a LineString, or even no intersection, so...
      return c if isinstance(c, geom.Point) else shape.centroid
  return shape.centroid</code></pre>
</details>
<div class="desc"><p>A different polygon centre, which produces better results for some
dual tilings where tiles are not regular polygons&hellip; see
<a href="https://en.wikipedia.org/wiki/Incenter">https://en.wikipedia.org/wiki/Incenter</a></p>
<p>This method relies on the polygon being tangential, i.e. there is an
inscribed circle to which all sides of the polygon are tangent. It will
work on all the polygons encountered in the Laves tilings, but is not
guaranteed to work on all polygons.</p>
<p>Given that the polygon is tangential, the radius of the inscribed circle is
the <a href="https://en.wikipedia.org/wiki/Apothem">apothem of the polygon</a> given
by 2 x Area / Perimeter. We apply a parallel offset of this size to two
sides of the polygon and find their intersection to determine the centre of
the circle, givng the incentre of the polygon.</p>
<p>Args:
shape (geom.Polygon): the polygon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Point</code></dt>
<dd>the incentre of the polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.is_convex"><code class="name flex">
<span>def <span class="ident">is_convex</span></span>(<span>shape: geom.Polygon) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_convex(shape:geom.Polygon) -&gt; bool:
  &#34;&#34;&#34;Tests for shape convexity. There are better ways to do this, like
  e.g. using something like the get_interior_angles() function, but simply
  checking if the area is close to that of its convex hull works too!

  Args:
    shape (geom.Polygon): polygon to check

  Returns:
    bool: True if the polygon is convex, False otherwise.
  &#34;&#34;&#34;
  return np.isclose(shape.area, shape.convex_hull.area, rtol = RESOLUTION)</code></pre>
</details>
<div class="desc"><p>Tests for shape convexity. There are better ways to do this, like
e.g. using something like the get_interior_angles() function, but simply
checking if the area is close to that of its convex hull works too!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the polygon is convex, False otherwise.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.is_regular_polygon"><code class="name flex">
<span>def <span class="ident">is_regular_polygon</span></span>(<span>shape: geom.Polygon) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_regular_polygon(shape:geom.Polygon) -&gt; bool:
  &#34;&#34;&#34;Tests if supplied polygon is regular (i.e. equal sides and angles).

  Args:
      shape (geom.Polygon): polygon to test.

  Returns:
      bool: True if polygon is regular, False if not.
  &#34;&#34;&#34;
  side_lengths = get_side_lengths(shape)
  angles = get_interior_angles(shape)
  return all(np.isclose(side_lengths, side_lengths[0])) \
     and all(np.isclose(angles, angles[0]))</code></pre>
</details>
<div class="desc"><p>Tests if supplied polygon is regular (i.e. equal sides and angles).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon to test.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if polygon is regular, False if not.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.is_tangential"><code class="name flex">
<span>def <span class="ident">is_tangential</span></span>(<span>shape: geom.Polygon) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tangential(shape:geom.Polygon) -&gt; bool:
  &#34;&#34;&#34;Determines if the supplied polygon is tangential i.e., it can have
  circle inscribed tangential to all its sides. 
  
  Note that this will fail for polygons with successive colinear sides,
  meaning that polygons should be fully simplified...
  &#34;&#34;&#34;
  if is_regular_polygon(shape):
    return True
  side_lengths = get_side_lengths(shape)
  n = len(side_lengths)
  if n % 2 == 1:
    if n == 3: #triangles are easy!
      return True
    # odd number of sides there is a nice solvable system  of equations
    # see https://math.stackexchange.com/questions/4065370/tangential-polygons-conditions-on-edge-lengths
    #
    # TODO: this is not reliable for reasons I don&#39;t fully understand
    # there is a corresponding crude catch exception in incentre... but
    # this needs a more complete investigation
    mat = np.identity(n) + np.roll(np.identity(n), 1, axis = 1)
    fractions = np.linalg.inv(mat) @ side_lengths / side_lengths
    if not(np.isclose(np.mean(fractions), 
                      0.5, rtol= RESOLUTION, atol = RESOLUTION)):
      return False
    ones = [np.isclose(f, 1, rtol = RESOLUTION, atol = RESOLUTION) 
            for f in fractions]
    zeros = [np.isclose(f, 0, rtol = RESOLUTION, atol = RESOLUTION) 
             for f in fractions]
    negatives = [f &lt; 0 for f in fractions]
    return not (any(ones) or any(zeros) or any(negatives))
  elif n == 4:
    # for quadrilaterals odd and even side lengths are equal
    return np.isclose(sum(side_lengths[0::2]), 
                      sum(side_lengths[1::2]), rtol = RESOLUTION)
  else:
    # other even numbers of sides... hard to avoid brute force
    bisectors = [get_angle_bisector(shape, i) for i in range(n)]
    intersects = [b1.intersection(b2) for b1, b2 in
                  zip(bisectors, bisectors[1:] + bisectors[:1])
                  if b1.intersects(b2)]
    distances = [i1.distance(i2) for i1, i2 in
                 zip(intersects, intersects[1:] + intersects[:1])]
    return all([d &lt;= 2 * RESOLUTION for d in distances])</code></pre>
</details>
<div class="desc"><p>Determines if the supplied polygon is tangential i.e., it can have
circle inscribed tangential to all its sides. </p>
<p>Note that this will fail for polygons with successive colinear sides,
meaning that polygons should be fully simplified&hellip;</p></div>
</dd>
<dt id="weavingspace.tiling_utils.offset_polygon_corners"><code class="name flex">
<span>def <span class="ident">offset_polygon_corners</span></span>(<span>polygon: geom.Polygon, offset: int) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset_polygon_corners(polygon:geom.Polygon, 
                          offset:int) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns this polygon but with its first corner offset from its
  original position in the coordinate sequence. The returned polygon will
  be identical but stored differently internally.

  Args:
    polygon (geom.Polygon): the polygon to reorder.
    offset (int): the number of corner positions by which to shift the
      sequence.

  Returns:
      geom.Polygon: the reordered polygon.
  &#34;&#34;&#34;
  corners = get_corners(polygon, repeat_first = False)
  return geom.Polygon([c for c in corners[offset:] + corners[:offset]]) </code></pre>
</details>
<div class="desc"><p>Returns this polygon but with its first corner offset from its
original position in the coordinate sequence. The returned polygon will
be identical but stored differently internally.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>the polygon to reorder.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of corner positions by which to shift the
sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>the reordered polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.order_of_pts_cw_around_centre"><code class="name flex">
<span>def <span class="ident">order_of_pts_cw_around_centre</span></span>(<span>pts: list[geom.Point], centre: geom.Point)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_of_pts_cw_around_centre(pts:list[geom.Point], centre:geom.Point):
  &#34;&#34;&#34;Returns the order of the supplied points clockwise relative to supplied 
  centre point, i.e. a list of the indices in clockwise order.

  Args:
      pts (list[geom.Point]): list of points to order.
      centre (geom.Point): centre relative to which CW order is determined.

  Returns:
      _type_: list of reordered points.
  &#34;&#34;&#34;
  dx = [p.x - centre.x for p in pts]
  dy = [p.y - centre.y for p in pts]
  angles = [np.arctan2(dy, dx) for dx, dy in zip(dx, dy)]
  d = dict(zip(angles, range(len(pts))))
  return [i for angle, i in reversed(sorted(d.items()))]</code></pre>
</details>
<div class="desc"><p>Returns the order of the supplied points clockwise relative to supplied
centre point, i.e. a list of the indices in clockwise order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pts</code></strong> :&ensp;<code>list[geom.Point]</code></dt>
<dd>list of points to order.</dd>
<dt><strong><code>centre</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>centre relative to which CW order is determined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd>list of reordered points.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.relabel"><code class="name flex">
<span>def <span class="ident">relabel</span></span>(<span>data: Iterable) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relabel(data:Iterable) -&gt; list:
  &#34;&#34;&#34;Returns supplied data reassigned with unique values from
  string.ascii_letters.

  Args:
    data (Iterable): the data to relabel

  Returns:
    list: the reassigned data
  &#34;&#34;&#34;
  new_data = {}
  d_count = 0
  for d in data:
    if not d in new_data:
      new_data[d] = string.ascii_letters[d_count]
      d_count = d_count + 1
  return [new_data[d] for d in data]</code></pre>
</details>
<div class="desc"><p>Returns supplied data reassigned with unique values from
string.ascii_letters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Iterable</code></dt>
<dd>the data to relabel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>the reassigned data</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.repair_polygon"><code class="name flex">
<span>def <span class="ident">repair_polygon</span></span>(<span>polygon: Union[geom.Polygon, geom.MultiPolygon, gpd.GeoSeries],<br>shrink_then_grow: bool = True) ‑> shapely.geometry.polygon.Polygon | geopandas.geoseries.GeoSeries</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repair_polygon(
    polygon:Union[geom.Polygon, geom.MultiPolygon, gpd.GeoSeries],
    shrink_then_grow:bool = True) -&gt; Union[geom.Polygon, gpd.GeoSeries]:
  &#34;&#34;&#34;Convenience function to &#39;repair&#39; a shapely polyon or GeoSeries by applying
  a negative buffer then the same positive buffer.

  Optionally the buffer may be applied in the opposite order (i.e. grow then
  shrink). This operation may also convert a MultiPolygon that has some &#39;stray&#39;
  parts to a Polygon.

  This is method is often unofficially recommended (on stackexchange etc.)
  even in the shapely docs, to resolve topology issues and extraneous
  additional vertices appearing when spatial operations are repeatedly
  applied.

  Args:
    p (Union[geom.Polygon, gpd.GeoSeries]): Polygon or GeoSeries to clean.
    res (float, optional): buffer size to use. Defaults to 1e-3.
    shrink_then_grow (bool, optional): if True the negative buffer is
      applied first, otherwise the buffer operations are applied in
      reverse. Defaults to True.

  Returns:
    Union[geom.Polygon, gpd.GeoSeries]: the cleaned Polygon or GeoSeries.
  &#34;&#34;&#34;
  if shrink_then_grow:
    return polygon.buffer(
      -RESOLUTION * 10, join_style = "mitre", cap_style = "square").buffer(
      RESOLUTION * 10, join_style = "mitre", cap_style = "square")
  else:
    return polygon.buffer(
      RESOLUTION * 10, join_style = "mitre", cap_style = "square").buffer(
      -RESOLUTION * 10, join_style = "mitre", cap_style = "square")</code></pre>
</details>
<div class="desc"><p>Convenience function to 'repair' a shapely polyon or GeoSeries by applying
a negative buffer then the same positive buffer.</p>
<p>Optionally the buffer may be applied in the opposite order (i.e. grow then
shrink). This operation may also convert a MultiPolygon that has some 'stray'
parts to a Polygon.</p>
<p>This is method is often unofficially recommended (on stackexchange etc.)
even in the shapely docs, to resolve topology issues and extraneous
additional vertices appearing when spatial operations are repeatedly
applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>Union[geom.Polygon, gpd.GeoSeries]</code></dt>
<dd>Polygon or GeoSeries to clean.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>buffer size to use. Defaults to 1e-3.</dd>
<dt><strong><code>shrink_then_grow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True the negative buffer is
applied first, otherwise the buffer operations are applied in
reverse. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[geom.Polygon, gpd.GeoSeries]</code></dt>
<dd>the cleaned Polygon or GeoSeries.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.reverse_transform"><code class="name flex">
<span>def <span class="ident">reverse_transform</span></span>(<span>transform: list[float]) ‑> list[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_transform(transform:list[float]) -&gt; list[float]:
  &#34;&#34;&#34;Returns the inverse shapely affine transform of the supplied transform.

  Args:
    transform (list[float]): the transform for which the inverse is desired.

  Returns:
    list[float]: shapely affine transform tuple that will invert the supplied
      transform.
  &#34;&#34;&#34;
  return as_shapely_transform(
    np.linalg.inv(as_numpy_matrix(transform)))</code></pre>
</details>
<div class="desc"><p>Returns the inverse shapely affine transform of the supplied transform.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>the transform for which the inverse is desired.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>shapely affine transform tuple that will invert the supplied
transform.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.rotate_preserving_order"><code class="name flex">
<span>def <span class="ident">rotate_preserving_order</span></span>(<span>polygon: geom.Polygon, angle: float, centre: geom.Point) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_preserving_order(polygon:geom.Polygon, angle:float,
                            centre:geom.Point) -&gt; geom.Polygon:
  &#34;&#34;&#34;Returns the supplied polygon rotated with the order of its corner points
  preserved (not guaranteed by shapely.affinity.rotate).

  Args:
      polygon (geom.Polygon): polygon to rotate.
      angle (float): desired angle of rotation (in degrees).
      centre (geom.Point): the rotation centre (passed on to shapely.affinity.
        rotate).

  Returns:
      geom.Polygon: rotated polygon.
  &#34;&#34;&#34;
  corners = get_corners(polygon, repeat_first = False)
  return geom.Polygon([affine.rotate(c, angle, centre) for c in corners])</code></pre>
</details>
<div class="desc"><p>Returns the supplied polygon rotated with the order of its corner points
preserved (not guaranteed by shapely.affinity.rotate).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>polygon to rotate.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>desired angle of rotation (in degrees).</dd>
<dt><strong><code>centre</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>the rotation centre (passed on to shapely.affinity.
rotate).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.Polygon</code></dt>
<dd>rotated polygon.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.safe_union"><code class="name flex">
<span>def <span class="ident">safe_union</span></span>(<span>gs: gpd.GeoSeries, as_polygon: bool = False) ‑> shapely.geometry.polygon.Polygon | geopandas.geoseries.GeoSeries</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_union(gs:gpd.GeoSeries,
               as_polygon:bool = False) -&gt; Union[gpd.GeoSeries, geom.Polygon]:
  &#34;&#34;&#34;Unions the supplied GeoSeries of Polygons while buffering them to avoid
  gaps and odd internal floating edges. Optionally returns a Polygon or a
  GeoSeries.

  Frequently when unioning polygons that are ostensibly adjacent &#39;rogue&#39;
  internal boundaries remain in the result. We can avoid this by buffering the
  polygons before unioning them, then reversing the buffer on the unioned
  shape.

  Args:
    gs (gpd.GeoSeries): the Polygons to union.
    res (float, optional): size of the buffer to use. Defaults to 1e-3.
    as_polygon (bool, optional): if True returns a Polygon, otherwise
      returns a one Polygon GeoSeries. Defaults to False.

  Returns:
    Union[gpd.GeoSeries, geom.Polygon]: the resulting union of supplied
      polygons.
  &#34;&#34;&#34;
  union = gs.buffer(RESOLUTION * 10, join_style = "mitre", cap_style = "square") \
    .unary_union.buffer(-RESOLUTION * 10, join_style = "mitre", cap_style = "square")
  if as_polygon:
    return gridify(union)
  else:
    return gridify(gpd.GeoSeries([union], crs = gs.crs))</code></pre>
</details>
<div class="desc"><p>Unions the supplied GeoSeries of Polygons while buffering them to avoid
gaps and odd internal floating edges. Optionally returns a Polygon or a
GeoSeries.</p>
<p>Frequently when unioning polygons that are ostensibly adjacent 'rogue'
internal boundaries remain in the result. We can avoid this by buffering the
polygons before unioning them, then reversing the buffer on the unioned
shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gs</code></strong> :&ensp;<code>gpd.GeoSeries</code></dt>
<dd>the Polygons to union.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>size of the buffer to use. Defaults to 1e-3.</dd>
<dt><strong><code>as_polygon</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True returns a Polygon, otherwise
returns a one Polygon GeoSeries. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[gpd.GeoSeries, geom.Polygon]</code></dt>
<dd>the resulting union of supplied
polygons.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.sort_cw"><code class="name flex">
<span>def <span class="ident">sort_cw</span></span>(<span>pts_ids: list[tuple[float, float, str]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_cw(pts_ids:list[tuple[float, float, str]]):
  &#34;&#34;&#34;Sorts supplied tuple of x, y, ID into clockwise order relative to their
  mean centre.

  Args:
    pts_ids (list[tuple[float, float, str]]): A tuple of a pair of
      floats and a string.

  Returns:
    list: a list in the same format as supplied sorted into
      clockwise order of the point locations.
  &#34;&#34;&#34;
  x = [p[0] for p in pts_ids]
  y = [p[1] for p in pts_ids]
  cx, cy = np.mean(x), np.mean(y)
  dx = [_ - cx for _ in x]
  dy = [_ - cy for _ in y]
  angles = [np.arctan2(dy, dx) for dx, dy in zip(dx, dy)]
  d = dict(zip(angles, pts_ids))
  return [pt_id for angle, pt_id in reversed(sorted(d.items()))]</code></pre>
</details>
<div class="desc"><p>Sorts supplied tuple of x, y, ID into clockwise order relative to their
mean centre.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pts_ids</code></strong> :&ensp;<code>list[tuple[float, float, str]]</code></dt>
<dd>A tuple of a pair of
floats and a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a list in the same format as supplied sorted into
clockwise order of the point locations.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.touch_along_an_edge"><code class="name flex">
<span>def <span class="ident">touch_along_an_edge</span></span>(<span>p1: geom.Polygon, p2: geom.Polygon) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def touch_along_an_edge(p1:geom.Polygon, p2:geom.Polygon) -&gt; bool:
  &#34;&#34;&#34;Tests if two polygons touch along an edge.

  Checks that the intersection area of the two polygons buffered by
  a small amount is large enough to indicate that they neighbour at more
  than a corner.

  Args:
    p1 (geom.Polygon): First polygon
    p2 (geom.Polygon): Second polygon

  Returns:
    bool: True if they neighbour along an edge
  &#34;&#34;&#34;
  return p1.buffer(RESOLUTION, join_style = "mitre", cap_style = "square") \
    .intersection(p2.buffer(RESOLUTION, join_style = "mitre", cap_style = "square")) \
      .area &gt; 16 * RESOLUTION ** 2</code></pre>
</details>
<div class="desc"><p>Tests if two polygons touch along an edge.</p>
<p>Checks that the intersection area of the two polygons buffered by
a small amount is large enough to indicate that they neighbour at more
than a corner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p1</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>First polygon</dd>
<dt><strong><code>p2</code></strong> :&ensp;<code>geom.Polygon</code></dt>
<dd>Second polygon</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if they neighbour along an edge</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.write_map_to_layers"><code class="name flex">
<span>def <span class="ident">write_map_to_layers</span></span>(<span>gdf: gpd.GeoDataFrame, fname: str = 'output.gpkg', tile_var: str = 'tile_id') ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_map_to_layers(gdf:gpd.GeoDataFrame, fname:str = &#34;output.gpkg&#34;,
                        tile_var:str = &#34;tile_id&#34;) -&gt; None:
  &#34;&#34;&#34;Writes supplied GeoDataFrame to a GPKG file with layers based on
  the tile_var attribute.

  Args:
    gdf (gpd.GeoDataFrame): the GeoDataFrame.
    fname (str, optional): filename to write.
    tile_var (str, optional): the attribute to use to separate
      output file into layers. Defaults to &#34;tile_id&#34;.
  &#34;&#34;&#34;
  grouped = gdf.groupby(tile_var, as_index = False)
  for e in pd.Series.unique(gdf[tile_var]):
    grouped.get_group(e).to_file(fname, layer = e, driver = &#34;GPKG&#34;)</code></pre>
</details>
<div class="desc"><p>Writes supplied GeoDataFrame to a GPKG file with layers based on
the tile_var attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdf</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the GeoDataFrame.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename to write.</dd>
<dt><strong><code>tile_var</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the attribute to use to separate
output file into layers. Defaults to "tile_id".</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_utils.zigzag_between_points"><code class="name flex">
<span>def <span class="ident">zigzag_between_points</span></span>(<span>p0: geom.Point, p1: geom.Point, n: int, h: float = 1.0, smoothness: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zigzag_between_points(
    p0:geom.Point, p1: geom.Point, n:int, h:float = 1.0,  smoothness: int = 0):

  template_steps = n * 2 + 1
  r = p0.distance(p1)
  
  x = np.linspace(0, n * np.pi, template_steps, endpoint = True)
  y = [np.sin(x) for x in x]
  s = interpolate.InterpolatedUnivariateSpline(x, y, k = 2)

  spline_steps = (n + smoothness) * 2 + 1
  xs = np.linspace(0, n * np.pi, spline_steps, endpoint = True)
  ys = s(xs)
  
  sfx = 1 / max(x) * r
  sfy = h * r / 2
  theta = np.arctan2(p1.y - p0.y, p1.x - p0.x)

  ls = geom.LineString([geom.Point(x, y) for x, y in zip(xs, ys)])
  ls = affine.translate(ls, 0, -(ls.bounds[1] + ls.bounds[3]) / 2)
  ls = affine.scale(ls, xfact = sfx, yfact = sfy, origin = (0, 0))
  ls = affine.rotate(ls, theta, (0, 0), use_radians = True)
  x0, y0 = list(ls.coords)[0]
  return affine.translate(ls, p0.x - x0, p0.y - y0)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="weavingspace.tiling_utils.as_numpy_matrix" href="#weavingspace.tiling_utils.as_numpy_matrix">as_numpy_matrix</a></code></li>
<li><code><a title="weavingspace.tiling_utils.as_shapely_transform" href="#weavingspace.tiling_utils.as_shapely_transform">as_shapely_transform</a></code></li>
<li><code><a title="weavingspace.tiling_utils.centre_offset" href="#weavingspace.tiling_utils.centre_offset">centre_offset</a></code></li>
<li><code><a title="weavingspace.tiling_utils.combine_transforms" href="#weavingspace.tiling_utils.combine_transforms">combine_transforms</a></code></li>
<li><code><a title="weavingspace.tiling_utils.ensure_cw" href="#weavingspace.tiling_utils.ensure_cw">ensure_cw</a></code></li>
<li><code><a title="weavingspace.tiling_utils.geometry_matches" href="#weavingspace.tiling_utils.geometry_matches">geometry_matches</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_angle_bisector" href="#weavingspace.tiling_utils.get_angle_bisector">get_angle_bisector</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_apothem_length" href="#weavingspace.tiling_utils.get_apothem_length">get_apothem_length</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_bounding_ellipse" href="#weavingspace.tiling_utils.get_bounding_ellipse">get_bounding_ellipse</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_clean_polygon" href="#weavingspace.tiling_utils.get_clean_polygon">get_clean_polygon</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_collapse_distance" href="#weavingspace.tiling_utils.get_collapse_distance">get_collapse_distance</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_corners" href="#weavingspace.tiling_utils.get_corners">get_corners</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_dual_tile_unit" href="#weavingspace.tiling_utils.get_dual_tile_unit">get_dual_tile_unit</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_inner_angle" href="#weavingspace.tiling_utils.get_inner_angle">get_inner_angle</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_interior_angles" href="#weavingspace.tiling_utils.get_interior_angles">get_interior_angles</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_largest_polygon" href="#weavingspace.tiling_utils.get_largest_polygon">get_largest_polygon</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_outer_angle" href="#weavingspace.tiling_utils.get_outer_angle">get_outer_angle</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_polygon_sector" href="#weavingspace.tiling_utils.get_polygon_sector">get_polygon_sector</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_reflection_transform" href="#weavingspace.tiling_utils.get_reflection_transform">get_reflection_transform</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_regular_polygon" href="#weavingspace.tiling_utils.get_regular_polygon">get_regular_polygon</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_rotation_transform" href="#weavingspace.tiling_utils.get_rotation_transform">get_rotation_transform</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_side_bearings" href="#weavingspace.tiling_utils.get_side_bearings">get_side_bearings</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_side_bisector" href="#weavingspace.tiling_utils.get_side_bisector">get_side_bisector</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_side_lengths" href="#weavingspace.tiling_utils.get_side_lengths">get_side_lengths</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_sides" href="#weavingspace.tiling_utils.get_sides">get_sides</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_strand_ids" href="#weavingspace.tiling_utils.get_strand_ids">get_strand_ids</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_tiling_edges" href="#weavingspace.tiling_utils.get_tiling_edges">get_tiling_edges</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_translation_transform" href="#weavingspace.tiling_utils.get_translation_transform">get_translation_transform</a></code></li>
<li><code><a title="weavingspace.tiling_utils.get_width_height_left_bottom" href="#weavingspace.tiling_utils.get_width_height_left_bottom">get_width_height_left_bottom</a></code></li>
<li><code><a title="weavingspace.tiling_utils.gridify" href="#weavingspace.tiling_utils.gridify">gridify</a></code></li>
<li><code><a title="weavingspace.tiling_utils.incentre" href="#weavingspace.tiling_utils.incentre">incentre</a></code></li>
<li><code><a title="weavingspace.tiling_utils.is_convex" href="#weavingspace.tiling_utils.is_convex">is_convex</a></code></li>
<li><code><a title="weavingspace.tiling_utils.is_regular_polygon" href="#weavingspace.tiling_utils.is_regular_polygon">is_regular_polygon</a></code></li>
<li><code><a title="weavingspace.tiling_utils.is_tangential" href="#weavingspace.tiling_utils.is_tangential">is_tangential</a></code></li>
<li><code><a title="weavingspace.tiling_utils.offset_polygon_corners" href="#weavingspace.tiling_utils.offset_polygon_corners">offset_polygon_corners</a></code></li>
<li><code><a title="weavingspace.tiling_utils.order_of_pts_cw_around_centre" href="#weavingspace.tiling_utils.order_of_pts_cw_around_centre">order_of_pts_cw_around_centre</a></code></li>
<li><code><a title="weavingspace.tiling_utils.relabel" href="#weavingspace.tiling_utils.relabel">relabel</a></code></li>
<li><code><a title="weavingspace.tiling_utils.repair_polygon" href="#weavingspace.tiling_utils.repair_polygon">repair_polygon</a></code></li>
<li><code><a title="weavingspace.tiling_utils.reverse_transform" href="#weavingspace.tiling_utils.reverse_transform">reverse_transform</a></code></li>
<li><code><a title="weavingspace.tiling_utils.rotate_preserving_order" href="#weavingspace.tiling_utils.rotate_preserving_order">rotate_preserving_order</a></code></li>
<li><code><a title="weavingspace.tiling_utils.safe_union" href="#weavingspace.tiling_utils.safe_union">safe_union</a></code></li>
<li><code><a title="weavingspace.tiling_utils.sort_cw" href="#weavingspace.tiling_utils.sort_cw">sort_cw</a></code></li>
<li><code><a title="weavingspace.tiling_utils.touch_along_an_edge" href="#weavingspace.tiling_utils.touch_along_an_edge">touch_along_an_edge</a></code></li>
<li><code><a title="weavingspace.tiling_utils.write_map_to_layers" href="#weavingspace.tiling_utils.write_map_to_layers">write_map_to_layers</a></code></li>
<li><code><a title="weavingspace.tiling_utils.zigzag_between_points" href="#weavingspace.tiling_utils.zigzag_between_points">zigzag_between_points</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
