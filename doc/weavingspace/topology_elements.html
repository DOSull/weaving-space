<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.topology_elements API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.topology_elements</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.topology_elements.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>corners: list[<a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge:
  &#34;&#34;&#34;Class to represent edges in a tiling (not tile sides) per the definitions
  in Grünbaum and Shephard.
  &#34;&#34;&#34;
  ID: tuple[int]
  &#34;&#34;&#34;IDs of the vertices at ends of the edge. Used as key in the containing 
  Topology&#39;s edges dictionary.&#34;&#34;&#34;
  vertices: list[&#34;Vertex&#34;]
  &#34;&#34;&#34;two item list of the end vertices.&#34;&#34;&#34;
  corners: list[&#34;Vertex&#34;]
  &#34;&#34;&#34;list of all the vertices in the edge (including its end vertices). In a 
  &#39;normal&#39; edge to edge tiling corners and vertices will be identical.&#34;&#34;&#34;
  right_tile: &#34;Tile&#34; = None
  &#34;&#34;&#34;the tile to the right of the edge traversed from its first to its last 
  vertex. Given clockwise winding default, all edges will have a right_tile.&#34;&#34;&#34;
  left_tile: &#34;Tile&#34; = None
  &#34;&#34;&#34;the tile to the left of the edge traversed from its first to its last 
  vertex. Exterior edges of the tiles in a Topology will not have a left_tile.
  &#34;&#34;&#34;
  base_ID: tuple[int] = (1_000_000, 1_000_000)
  &#34;&#34;&#34;ID of corresponding edge in the base tileable&#34;&#34;&#34;
  transitivity_class: int = None
  &#34;&#34;&#34;transitivity class of the edge under symmetries of the tiling&#34;&#34;&#34;
  label: str = &#34;&#34;
  &#34;&#34;&#34;the (lower case letter) label of the edge under the symmetries of the 
  tiling.&#34;&#34;&#34;
  
  def __init__(self, corners:list[Vertex]):
    &#34;&#34;&#34;Class constructor. Initialises the corners and vertices lists and sets ID
    to (vertices[0].ID, vertices[1].ID). The vertices list is all the corners
    with is_tiling_vertex property True -- Note that during initialisation the
    default of this property is True until after the relations between tiles and
    vertices have been determined.

    Args:
      corners (list[Vertex]): list of all corners along the edge.
    &#34;&#34;&#34;
    self.corners = corners
    self.vertices = [v for v in self.corners if v.is_tiling_vertex]
    self.ID = tuple(v.ID for v in self.vertices)

  def __str__(self) -&gt; str:
    &#34;&#34;&#34;Returns a string representation of  the Edge.

    Returns:
        str: include ID and a list of corner vertex IDs.
    &#34;&#34;&#34;
    return f&#34;Edge {self.ID} Corners: {[c.ID for c in self.corners]}&#34;

  def __repr__(self) -&gt; str:
    return str(self)

  def get_corner_IDs(self) -&gt; list[int]:
    &#34;&#34;&#34;Convenience method to get the IDs of edge corners.

    Returns:
        list[int]: IDs of all corners.
    &#34;&#34;&#34;
    return [c.ID for c in self.corners]

  def get_vertex_IDs(self) -&gt; list[int]:
    &#34;&#34;&#34;Convenience method to get IDs of edge vertices.

    Returns:
        list[int]: list of IDs of the vertices.
    &#34;&#34;&#34;
    return [v.ID for v in self.vertices]

  def insert_vertex(self, v:&#34;Vertex&#34;, predecessor:&#34;Vertex&#34;) -&gt; list[&#34;Edge&#34;]:
    &#34;&#34;&#34;Inserts a vertex along this edge after the specified predecessor 
    Vertex and returns this edge modified and a new edge. 
    
    If the initial edge was (say) (0 1 2 5) and the predecessor was set to 1 
    the returned edges would be (0 1 v) and (v 2 5).
    &#34;&#34;&#34;
    i = self.corners.index(predecessor)
    new_edge = Edge([v] + self.corners[(i+1):])
    if not self.right_tile is None:
      new_edge.right_tile = self.right_tile
    if not self.left_tile is None:
      new_edge.left_tile = self.left_tile
    self.corners = self.corners[:(i+1)] + [v]
    self.vertices = [self.vertices[0], v]
    self.ID = tuple(v.ID for v in self.vertices)
    return [self, new_edge]

  def get_geometry(self, forward = True) -&gt; geom.LineString:
    &#34;&#34;&#34;Returns a geom.LineString representing the geometry (including all
    corners) of this Edge, optionally starting at either end.

    Args:
      forward (bool, optional): if True the returned LineString starts at
        corners[0], else at corners[-1]. Defaults to True.

    Returns:
      geom.LineString: the required LineString.
    &#34;&#34;&#34;
    if forward:
      return geom.LineString([v.point for v in self.corners])
    else:
      return geom.LineString([v.point for v in self.corners[::-1]])

  def get_topology(self, forward = True) -&gt; geom.LineString:
    &#34;&#34;&#34;Returns a LineString connecting the first and last corners (i.e. the
    vertices) of this tilin edge, optionally starting from either end.

    Args:
      forward (bool, optional): if True LineString starts at vertices[0], 
        else at vertices[1]. Defaults to True.

    Returns:
        geom.LineString: the required LineString.
    &#34;&#34;&#34;
    if forward:
      return geom.LineString([v.point for v in self.vertices])
    else:
      return geom.LineString([v.point for v in self.vertices[::-1]])</code></pre>
</details>
<div class="desc"><p>Class to represent edges in a tiling (not tile sides) per the definitions
in Grünbaum and Shephard.</p>
<p>Class constructor. Initialises the corners and vertices lists and sets ID
to (vertices[0].ID, vertices[1].ID). The vertices list is all the corners
with is_tiling_vertex property True &ndash; Note that during initialisation the
default of this property is True until after the relations between tiles and
vertices have been determined.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>corners</code></strong> :&ensp;<code>list[<a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>]</code></dt>
<dd>list of all corners along the edge.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.topology_elements.Edge.ID"><code class="name">var <span class="ident">ID</span> : tuple[int]</code></dt>
<dd>
<div class="desc"><p>IDs of the vertices at ends of the edge. Used as key in the containing
Topology's edges dictionary.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.base_ID"><code class="name">var <span class="ident">base_ID</span> : tuple[int]</code></dt>
<dd>
<div class="desc"><p>ID of corresponding edge in the base tileable</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.corners"><code class="name">var <span class="ident">corners</span> : list[<a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>]</code></dt>
<dd>
<div class="desc"><p>list of all the vertices in the edge (including its end vertices). In a
'normal' edge to edge tiling corners and vertices will be identical.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>the (lower case letter) label of the edge under the symmetries of the
tiling.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.left_tile"><code class="name">var <span class="ident">left_tile</span> : <a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a></code></dt>
<dd>
<div class="desc"><p>the tile to the left of the edge traversed from its first to its last
vertex. Exterior edges of the tiles in a Topology will not have a left_tile.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.right_tile"><code class="name">var <span class="ident">right_tile</span> : <a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a></code></dt>
<dd>
<div class="desc"><p>the tile to the right of the edge traversed from its first to its last
vertex. Given clockwise winding default, all edges will have a right_tile.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.transitivity_class"><code class="name">var <span class="ident">transitivity_class</span> : int</code></dt>
<dd>
<div class="desc"><p>transitivity class of the edge under symmetries of the tiling</p></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.vertices"><code class="name">var <span class="ident">vertices</span> : list[<a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>]</code></dt>
<dd>
<div class="desc"><p>two item list of the end vertices.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.topology_elements.Edge.get_corner_IDs"><code class="name flex">
<span>def <span class="ident">get_corner_IDs</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner_IDs(self) -&gt; list[int]:
  &#34;&#34;&#34;Convenience method to get the IDs of edge corners.

  Returns:
      list[int]: IDs of all corners.
  &#34;&#34;&#34;
  return [c.ID for c in self.corners]</code></pre>
</details>
<div class="desc"><p>Convenience method to get the IDs of edge corners.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[int]</code></dt>
<dd>IDs of all corners.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.get_geometry"><code class="name flex">
<span>def <span class="ident">get_geometry</span></span>(<span>self, forward=True) ‑> shapely.geometry.linestring.LineString</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geometry(self, forward = True) -&gt; geom.LineString:
  &#34;&#34;&#34;Returns a geom.LineString representing the geometry (including all
  corners) of this Edge, optionally starting at either end.

  Args:
    forward (bool, optional): if True the returned LineString starts at
      corners[0], else at corners[-1]. Defaults to True.

  Returns:
    geom.LineString: the required LineString.
  &#34;&#34;&#34;
  if forward:
    return geom.LineString([v.point for v in self.corners])
  else:
    return geom.LineString([v.point for v in self.corners[::-1]])</code></pre>
</details>
<div class="desc"><p>Returns a geom.LineString representing the geometry (including all
corners) of this Edge, optionally starting at either end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forward</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True the returned LineString starts at
corners[0], else at corners[-1]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.LineString</code></dt>
<dd>the required LineString.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.get_topology"><code class="name flex">
<span>def <span class="ident">get_topology</span></span>(<span>self, forward=True) ‑> shapely.geometry.linestring.LineString</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topology(self, forward = True) -&gt; geom.LineString:
  &#34;&#34;&#34;Returns a LineString connecting the first and last corners (i.e. the
  vertices) of this tilin edge, optionally starting from either end.

  Args:
    forward (bool, optional): if True LineString starts at vertices[0], 
      else at vertices[1]. Defaults to True.

  Returns:
      geom.LineString: the required LineString.
  &#34;&#34;&#34;
  if forward:
    return geom.LineString([v.point for v in self.vertices])
  else:
    return geom.LineString([v.point for v in self.vertices[::-1]])</code></pre>
</details>
<div class="desc"><p>Returns a LineString connecting the first and last corners (i.e. the
vertices) of this tilin edge, optionally starting from either end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forward</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True LineString starts at vertices[0],
else at vertices[1]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geom.LineString</code></dt>
<dd>the required LineString.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.get_vertex_IDs"><code class="name flex">
<span>def <span class="ident">get_vertex_IDs</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertex_IDs(self) -&gt; list[int]:
  &#34;&#34;&#34;Convenience method to get IDs of edge vertices.

  Returns:
      list[int]: list of IDs of the vertices.
  &#34;&#34;&#34;
  return [v.ID for v in self.vertices]</code></pre>
</details>
<div class="desc"><p>Convenience method to get IDs of edge vertices.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[int]</code></dt>
<dd>list of IDs of the vertices.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Edge.insert_vertex"><code class="name flex">
<span>def <span class="ident">insert_vertex</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>,<br>predecessor: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>) ‑> list[<a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_vertex(self, v:&#34;Vertex&#34;, predecessor:&#34;Vertex&#34;) -&gt; list[&#34;Edge&#34;]:
  &#34;&#34;&#34;Inserts a vertex along this edge after the specified predecessor 
  Vertex and returns this edge modified and a new edge. 
  
  If the initial edge was (say) (0 1 2 5) and the predecessor was set to 1 
  the returned edges would be (0 1 v) and (v 2 5).
  &#34;&#34;&#34;
  i = self.corners.index(predecessor)
  new_edge = Edge([v] + self.corners[(i+1):])
  if not self.right_tile is None:
    new_edge.right_tile = self.right_tile
  if not self.left_tile is None:
    new_edge.left_tile = self.left_tile
  self.corners = self.corners[:(i+1)] + [v]
  self.vertices = [self.vertices[0], v]
  self.ID = tuple(v.ID for v in self.vertices)
  return [self, new_edge]</code></pre>
</details>
<div class="desc"><p>Inserts a vertex along this edge after the specified predecessor
Vertex and returns this edge modified and a new edge. </p>
<p>If the initial edge was (say) (0 1 2 5) and the predecessor was set to 1
the returned edges would be (0 1 v) and (v 2 5).</p></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.topology_elements.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>ID: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tile(object):
  &#34;&#34;&#34;Class to capture and manipulate essential features of polygons in a tiling.
  &#34;&#34;&#34;
  ID: int
  &#34;&#34;&#34;integer ID number which indexes the Tile in the containing Topology tiles 
  list.&#34;&#34;&#34;
  base_ID: int
  &#34;&#34;&#34;ID of corresponding Tile in the base tileable unit&#34;&#34;&#34;
  corners: list[&#34;Vertex&#34;]
  &#34;&#34;&#34;list of Vertex objects. This includes all corners of the original polygon 
  and any tiling vertices induced by (for example) a the corner of an adjacent 
  tile lying halfway along an edge of the original polygon on which this tile 
  is based. Vertex objects are stored in strictly clockwise sequence.&#34;&#34;&#34;
  edges: list[&#34;Edge&#34;]
  &#34;&#34;&#34;list of Edge objects that together compose the tile boundary.&#34;&#34;&#34;
  edges_CW: list[bool]
  &#34;&#34;&#34;list of Edge direction. Edges are stored only once in a Topology so some 
  edges are in clockwise order and others  are in counter-clockwise order. 
  These boolean flags are True if the corresponding Edge is clockwise, False if 
  counter-clockwise.&#34;&#34;&#34;
  label: str
  &#34;&#34;&#34;tile_id label from the tileable source&#34;&#34;&#34;
  vertex_labels: list[str]
  &#34;&#34;&#34;list of (upper case) letter labels of the tile corners (i.e. all corners, 
  not only tiling vertices).&#34;&#34;&#34;
  edge_labels: list[str]
  &#34;&#34;&#34;list of (lower case) letter labels of the tile edges (tiling edges, not 
  tile sides).&#34;&#34;&#34;
  shape: geom.Polygon = None
  &#34;&#34;&#34;the tile geometry (which may include some redundant points along sides 
  where neighbouring tiles induce a tiling vertex). So for example a rectangle 
  might have additional points along its sides:
      
        +---+-------+
        |   |   2   |
        | 1 A---B---E---+
        |   |   |   4   |
        +---C 3 D-------+
            |   |
            +---+
      
  In the above Tile 1 has additional point A, 2 has B and 3 has C and D induced 
  by the corners of neighbouring tiles.&#34;&#34;&#34;
  centre: geom.Point = None
  &#34;&#34;&#34;a point centre for the Tile (determined by weavingspace.tiling_utils.
  incentre).&#34;&#34;&#34;
  shape_group: int = None
  &#34;&#34;&#34;the tile shape group of this tile in its containing Topology.&#34;&#34;&#34;
  transitivity_class: int = None
  &#34;&#34;&#34;the tile transitivity class of this tile its containing Topology&#34;&#34;&#34;
  
  def __init__(self, ID:int):
    &#34;&#34;&#34;Class constructor.

    Args:
      ID (int): Tile ID which indexes it in the containing Topology tiles list.
    &#34;&#34;&#34;
    # self.set_shape(tiling_utils.get_clean_polygon(shape))
    self.ID = ID
    self.corners = []
    self.edges = []
    self.edges_CW = []
    self.vertex_labels = []
    self.edge_labels = []

  def __str__(self) -&gt; str:
    &#34;&#34;&#34;Returns string representation of the Tile.

    Returns:
      str: string including Tile ID, list of corner vertex IDs and list of
        edge IDs.
    &#34;&#34;&#34;
    return f&#34;Tile {self.ID} Corners: {self.get_corner_IDs()} Edges: {self.get_edge_IDs()}&#34;
  
  def __repr__(self) -&gt; str:
    return str(self)

  def get_corner_IDs(self) -&gt; list[int]:
    &#34;&#34;&#34;Convenience method to return list of corner IDs (not Vertex objects).

    Returns:
      list[int]: list of integer IDs of tile corners.
    &#34;&#34;&#34;
    return [c.ID for c in self.corners]

  def get_edge_IDs(self) -&gt; list[tuple[int]]:
    &#34;&#34;&#34;Convenience method to return list of edge IDs (not Edge objects).

    Returns:
      list[tuple[int]]: list of 2-element tuples of the start and end Vertex IDs
        of each edge.
    &#34;&#34;&#34;
    return [e.ID for e in self.edges]

  def set_shape_from_corners(self):
    &#34;&#34;&#34;Sets the shape attribute based on the current list of corners, and sets 
    the associated tile centre.
    &#34;&#34;&#34;
    self.shape = geom.Polygon([c.point for c in self.corners])
    self.centre = tiling_utils.get_incentre(
      tiling_utils.get_clean_polygon(self.shape))

  def set_corners_from_edges(self, update_shape:bool = True):
    &#34;&#34;&#34;Sets the corners attribute from the edges attribute. Typically called 
    after modification of topology edges. Optionally the shape attribute is NOT
    updated, which may save time when multiple changes to the edges of a tile
    are in process (i.e., only update the shape after all changes are complete).

    Args:
      update_shape (bool, optional): if True the shape attribute will be 
        updated, otherwise not. Defaults to True.
    &#34;&#34;&#34;
    self.corners = []
    for e, cw in zip(self.edges, self.edges_CW):
      if cw: # clockwise to extend by all but the first corner
        self.corners.extend(e.corners[:-1])
      else: # counter-clockwise so extend in reverse
        self.corners.extend(e.corners[1:][::-1])
    if update_shape:
      self.set_shape_from_corners()

  def set_edge_directions(self):
    &#34;&#34;&#34;Sets up the edges_CW attribute by inspection of the edges list.
    It is (frankly!) hard to keep track of the correct sequence of CW/CCW order
    of edges as new ones are created or old ones merged. This method inspects
    the &#39;tail-head&#39; relations between consecutive edges to set these flags 
    correctly.

    The test is simply to check if the &#39;tail&#39; Vertex ID in each edge appears
    in the ID tuple of the following edge, i.e. if successive edge 
    IDs are (0, 1) (2, 1) or (0, 1) (1, 2), then edge (0, 1) is in clockwise
    direction, but if we have (0, 1) (2, 3) then it is not.
    &#34;&#34;&#34;
    edge_IDs = self.get_edge_IDs()
    self.edges_CW = [e1[-1] in e2 for e1, e2 in 
                     zip(edge_IDs, edge_IDs[1:] + edge_IDs[:1])]

  def insert_vertex_at(self, v:&#34;Vertex&#34;, i:int, 
                       update_shape:bool = False) -&gt; tuple:
    &#34;&#34;&#34;Method to insert the supplied Vertex into tile at index position i, 
    optionally updating the shape attribute. Both corners and edges attributes
    are updated, and the old edge IDs for removal and the new edge itself are
    returned to the calling context (the containing Topology) for update of its
    edges collection.

    This is NOT a generic vertex insertion method: it is only for use during 
    Topology initialisation, and does not guarantee correct maintenance of 
    all tile, edge and vertex relations in the general case---at any rate it
    has not been tested for this!

    Args:
        v (Vertex): the Vertex to insert.
        i (int): index position in current corners after which to insert 
          supplied Vertex.
        update_shape (bool, optional): if True shape attribute is updated. 
          Defaults to False.

    Returns:
      tuple: the (tuple) ID of the old edge which should be deleted, and 
        the new Edges arising from insertion of this Vertex.
    &#34;&#34;&#34;
    self.corners = self.corners[:i] + [v] + self.corners[i:]
    old_edge = self.edges[i - 1]
    # store current ID of the affected edge for return to calling context
    old_edge_ID = old_edge.ID
    new_edges = old_edge.insert_vertex(v, self.corners[i - 1])
    self.edges = self.edges[:(i-1)] + new_edges + self.edges[i:]
    self.set_edge_directions()
    if update_shape:
      self.set_shape_from_corners()
    return old_edge_ID, new_edges

  def merge_edges_at_vertex(self, v:&#34;Vertex&#34;) -&gt; tuple:
    &#34;&#34;&#34;Method to merge the edges that meet at the supplied Vertex. It is 
    assumed that only two tiles are impacted this one, and its neighbour across
    the Edge on which v lies. Both are updated. For this reason the work is
    delegated to get_updated_edges_from_merge which is run on both affected
    tiles, but only determines the edges to remove and the new edge to be added
    once. See that method for details.
    
    Args:
      v (Vertex): Vertex at which to merge Edges. This should currently be an
        end
    
    Returns:
      tuple: 2 item list of the edge IDs to be removed and a new Edge object to
        be added by the calling context (i.e. the containing Topology).
    &#34;&#34;&#34;
    to_remove, new_edge = self.get_updated_edges_from_merge(v)
    if len(v.tiles) &gt; 1:
      v.tiles[1].get_updated_edges_from_merge(v, new_edge)
    return to_remove, new_edge

  def get_updated_edges_from_merge(self, v:&#34;Vertex&#34;, new_edge:&#34;Edge&#34; = None):
    &#34;&#34;&#34;Updates the edges and edges_CW attributes based on insertion of 
    the supplied Vertex. If new_edge is supplied then the neighbour tile at
    v has already created the needed new Edge and this Edge is the one that
    will be &#39;slotted in&#39; at the appropriate spot in the edges list.

    The edges_CW is also updated to maintain correct directions of the edges.
    The corners attribute is unaffected by these changes.

    Args:
      v (Vertex): existing Vertex at which to carry out the merge.
      new_edge (Edge, optional): if another Tile has already carried out this 
        merge this should be the resulting new Edge for insertion into this 
        Tile. Defaults to None (when the new Edge will be constructed).
  
    Returns:
      Union[None, tuple]: either None (if a new edge was supplied) or a tuple 
        of the two edge IDs to be removed and the new edge added for return to
        the calling context (i.e. the containing Topology).
    &#34;&#34;&#34;
    # get the two edge list index positions in which Vertex v is found
    i, j = self.get_edge_IDs_including_vertex(v)
    if new_edge is None: # then we must make a new one
      # also record existing edge IDs to be removed
      to_remove = [self.edges[i].ID, self.edges[j].ID]
      new_edge = self.get_merged_edge(i, j)
      return_edge_updates = True
    else:
      return_edge_updates = False
    if abs(i - j) != 1:
      # edge indices &#39;wrap&#39; around from end of edge list to start so drop 
      # first and last current edges and stick new one on at the end
      self.edges = self.edges[1:-1] + [new_edge] 
    else:
      # insert new edge into list in place of the two old ones
      self.edges = self.edges[:i] + [new_edge] + self.edges[j+1:]
    # update the edge directions
    self.set_edge_directions()
    if return_edge_updates:
      return to_remove, new_edge
    else:
      return None

  def get_edge_IDs_including_vertex(self, v:&#34;Vertex&#34;) -&gt; tuple[int]:
    &#34;&#34;&#34;Gets the (two) index positions of the edges that include supplied Vertex.

    Args:
        v (Vertex): Vertex of interest.

    Returns:
      tuple[int]: two index positions of Edges in edges list that contain v.
    &#34;&#34;&#34;
    return (i for i, e in enumerate(self.edges) if v.ID in e.ID)

  def get_merged_edge(self, i:int, j:int) -&gt; &#34;Edge&#34;:
    &#34;&#34;&#34;Returns the new edge resulting from merging the two existing edges at
    index positions i and j in the edges list. For example, if the current list 
    of edge IDs was

        (0 1 2) (4 2) (4 5) (5 0)

    and the merge Vertex was #2, the resulting new edge is constructed from 
    vertices (0 1 2 4). 

    Returns:
      Edge: the requested new Edge.
    &#34;&#34;&#34;
    # if i and j are not consecutive, then j is predecessor edge
    if abs(i - j) != 1:
      i, j = j, i
    # get edges and their directions
    ei, ej = self.edges[i], self.edges[j]
    CWi, CWj = self.edges_CW[i], self.edges_CW[j]
    # DON&#39;T MESS WITH THIS!!!
    # for predecessors (the head) we want everything including the Vertex 
    # where the merge is occurring; for successors (the tail) we want all but 
    # the first Vertex (which is the one where the merge is occurring). In both 
    # cases contingent on whether existing Edges are CW or CCW we may need to 
    # flip the Vertex sequence to ensure that the merge Vertex is in the middle 
    # of the new edge that will be created
    head = ei.corners if CWi else ei.corners[::-1]
    tail = ej.corners[1:] if CWj else ej.corners[::-1][1:]
    v_sequence = (head if CWi else head[::-1]) + (tail if CWj else tail[::-1])
    return Edge(v_sequence)

  def offset_corners(self, offset:int):
    &#34;&#34;&#34;Shifts shape, corners, edges, and edges_CW by an offset amount. This is
    used to align tiles that are similar, which is required for correct 
    transfer of &#39;base&#39; tile labelling on to &#39;radius 1&#39; tiles during Topology 
    construction.

    Args:
      offset int: the number of positions to shift the lists.
    &#34;&#34;&#34;
    if not offset is None or offset == 0:
      self.shape = tiling_utils.offset_polygon_corners(self.shape, offset)
      self.corners = self.corners[offset:] + self.corners[:offset]
      self.edges = self.edges[offset:] + self.edges[:offset]
      self.edges_CW = self.edges_CW[offset:] + self.edges_CW[:offset]

  def get_edge_label(self, e:&#34;Edge&#34;) -&gt; str:
    &#34;&#34;&#34;Returns edge label of specified edge.

    Args:
        e (Edge): Edge whose label is required.

    Returns:
        str: requested edge label.
    &#34;&#34;&#34;
    return self.edge_labels[self.get_edge_IDs().index(e.ID)]

  def get_corner_label(self, v:&#34;Vertex&#34;) -&gt; str:
    &#34;&#34;&#34;Returns corner label of specified corner.

    Args:
        v (Vertex): corner whose label is required.

    Returns:
        str: requested corner label.
    &#34;&#34;&#34;
    return self.edge_labels[self.get_corner_IDs().index(v.ID)]

  def get_vertex_label_positions(self) -&gt; list[geom.Point]:
    &#34;&#34;&#34;Returns a viable location at which to position corner labels inside
    tile shape. The method is convoluted because a negative buffer may remove
    colinear corners resulting in fewer positions than we have corners in the
    tile shape!

    Returns:
        list[geom.Point]: list of locations.
    &#34;&#34;&#34;
    d = (self.shape.area ** 0.5) / 8
    c = self.centre
    corners = [c.point for c in self.corners]
    return [geom.LineString([p, c]).line_interpolate_point(d) for p in corners]
    
  def get_edge_label_positions(self) -&gt; list[geom.Point]:
    &#34;&#34;&#34;Returns a reasonable location at which to position edge labels inside
    tile shape.

    Returns:
        list[geom.Point]: list of locations
    &#34;&#34;&#34;
    d = (self.shape.area ** 0.5) / 8
    c = self.centre
    # note direction is important as edge might not be a simple line segment
    sides = [e.get_geometry(CW) for e, CW in zip(self.edges, self.edges_CW)]
    return [geom.LineString([s.centroid, c]).line_interpolate_point(d) 
            for s in sides]

  def angle_at(self, v:&#34;Vertex&#34;) -&gt; float:
    &#34;&#34;&#34;Returns interior angle at the specified corner (in degrees).

    Args:
        v (Vertex): corner where angle is requested.

    Returns:
        float: angle at corner v in degrees.
    &#34;&#34;&#34;
    i = self.corners.index(v)
    n = len(self.corners)
    return tiling_utils.get_inner_angle(self.corners[i-1].point,
                                        self.corners[i].point,
                                        self.corners[(i + 1) % n].point)</code></pre>
</details>
<div class="desc"><p>Class to capture and manipulate essential features of polygons in a tiling.</p>
<p>Class constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile ID which indexes it in the containing Topology tiles list.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.topology_elements.Tile.ID"><code class="name">var <span class="ident">ID</span> : int</code></dt>
<dd>
<div class="desc"><p>integer ID number which indexes the Tile in the containing Topology tiles
list.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.base_ID"><code class="name">var <span class="ident">base_ID</span> : int</code></dt>
<dd>
<div class="desc"><p>ID of corresponding Tile in the base tileable unit</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.centre"><code class="name">var <span class="ident">centre</span> : shapely.geometry.point.Point</code></dt>
<dd>
<div class="desc"><p>a point centre for the Tile (determined by weavingspace.tiling_utils.
incentre).</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.corners"><code class="name">var <span class="ident">corners</span> : list[<a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>]</code></dt>
<dd>
<div class="desc"><p>list of Vertex objects. This includes all corners of the original polygon
and any tiling vertices induced by (for example) a the corner of an adjacent
tile lying halfway along an edge of the original polygon on which this tile
is based. Vertex objects are stored in strictly clockwise sequence.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.edge_labels"><code class="name">var <span class="ident">edge_labels</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>list of (lower case) letter labels of the tile edges (tiling edges, not
tile sides).</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.edges"><code class="name">var <span class="ident">edges</span> : list[<a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a>]</code></dt>
<dd>
<div class="desc"><p>list of Edge objects that together compose the tile boundary.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.edges_CW"><code class="name">var <span class="ident">edges_CW</span> : list[bool]</code></dt>
<dd>
<div class="desc"><p>list of Edge direction. Edges are stored only once in a Topology so some
edges are in clockwise order and others
are in counter-clockwise order.
These boolean flags are True if the corresponding Edge is clockwise, False if
counter-clockwise.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>tile_id label from the tileable source</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.shape"><code class="name">var <span class="ident">shape</span> : shapely.geometry.polygon.Polygon</code></dt>
<dd>
<div class="desc"><p>the tile geometry (which may include some redundant points along sides
where neighbouring tiles induce a tiling vertex). So for example a rectangle
might have additional points along its sides:</p>
<pre><code>  +---+-------+
  |   |   2   |
  | 1 A---B---E---+
  |   |   |   4   |
  +---C 3 D-------+
      |   |
      +---+
</code></pre>
<p>In the above Tile 1 has additional point A, 2 has B and 3 has C and D induced
by the corners of neighbouring tiles.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.shape_group"><code class="name">var <span class="ident">shape_group</span> : int</code></dt>
<dd>
<div class="desc"><p>the tile shape group of this tile in its containing Topology.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.transitivity_class"><code class="name">var <span class="ident">transitivity_class</span> : int</code></dt>
<dd>
<div class="desc"><p>the tile transitivity class of this tile its containing Topology</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.vertex_labels"><code class="name">var <span class="ident">vertex_labels</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>list of (upper case) letter labels of the tile corners (i.e. all corners,
not only tiling vertices).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.topology_elements.Tile.angle_at"><code class="name flex">
<span>def <span class="ident">angle_at</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle_at(self, v:&#34;Vertex&#34;) -&gt; float:
  &#34;&#34;&#34;Returns interior angle at the specified corner (in degrees).

  Args:
      v (Vertex): corner where angle is requested.

  Returns:
      float: angle at corner v in degrees.
  &#34;&#34;&#34;
  i = self.corners.index(v)
  n = len(self.corners)
  return tiling_utils.get_inner_angle(self.corners[i-1].point,
                                      self.corners[i].point,
                                      self.corners[(i + 1) % n].point)</code></pre>
</details>
<div class="desc"><p>Returns interior angle at the specified corner (in degrees).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>corner where angle is requested.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>angle at corner v in degrees.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_corner_IDs"><code class="name flex">
<span>def <span class="ident">get_corner_IDs</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner_IDs(self) -&gt; list[int]:
  &#34;&#34;&#34;Convenience method to return list of corner IDs (not Vertex objects).

  Returns:
    list[int]: list of integer IDs of tile corners.
  &#34;&#34;&#34;
  return [c.ID for c in self.corners]</code></pre>
</details>
<div class="desc"><p>Convenience method to return list of corner IDs (not Vertex objects).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[int]</code></dt>
<dd>list of integer IDs of tile corners.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_corner_label"><code class="name flex">
<span>def <span class="ident">get_corner_label</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_corner_label(self, v:&#34;Vertex&#34;) -&gt; str:
  &#34;&#34;&#34;Returns corner label of specified corner.

  Args:
      v (Vertex): corner whose label is required.

  Returns:
      str: requested corner label.
  &#34;&#34;&#34;
  return self.edge_labels[self.get_corner_IDs().index(v.ID)]</code></pre>
</details>
<div class="desc"><p>Returns corner label of specified corner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>corner whose label is required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>requested corner label.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_edge_IDs"><code class="name flex">
<span>def <span class="ident">get_edge_IDs</span></span>(<span>self) ‑> list[tuple[int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_IDs(self) -&gt; list[tuple[int]]:
  &#34;&#34;&#34;Convenience method to return list of edge IDs (not Edge objects).

  Returns:
    list[tuple[int]]: list of 2-element tuples of the start and end Vertex IDs
      of each edge.
  &#34;&#34;&#34;
  return [e.ID for e in self.edges]</code></pre>
</details>
<div class="desc"><p>Convenience method to return list of edge IDs (not Edge objects).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[tuple[int]]</code></dt>
<dd>list of 2-element tuples of the start and end Vertex IDs
of each edge.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_edge_IDs_including_vertex"><code class="name flex">
<span>def <span class="ident">get_edge_IDs_including_vertex</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>) ‑> tuple[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_IDs_including_vertex(self, v:&#34;Vertex&#34;) -&gt; tuple[int]:
  &#34;&#34;&#34;Gets the (two) index positions of the edges that include supplied Vertex.

  Args:
      v (Vertex): Vertex of interest.

  Returns:
    tuple[int]: two index positions of Edges in edges list that contain v.
  &#34;&#34;&#34;
  return (i for i, e in enumerate(self.edges) if v.ID in e.ID)</code></pre>
</details>
<div class="desc"><p>Gets the (two) index positions of the edges that include supplied Vertex.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>Vertex of interest.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int]</code></dt>
<dd>two index positions of Edges in edges list that contain v.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_edge_label"><code class="name flex">
<span>def <span class="ident">get_edge_label</span></span>(<span>self,<br>e: <a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_label(self, e:&#34;Edge&#34;) -&gt; str:
  &#34;&#34;&#34;Returns edge label of specified edge.

  Args:
      e (Edge): Edge whose label is required.

  Returns:
      str: requested edge label.
  &#34;&#34;&#34;
  return self.edge_labels[self.get_edge_IDs().index(e.ID)]</code></pre>
</details>
<div class="desc"><p>Returns edge label of specified edge.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>e</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a></code></dt>
<dd>Edge whose label is required.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>requested edge label.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_edge_label_positions"><code class="name flex">
<span>def <span class="ident">get_edge_label_positions</span></span>(<span>self) ‑> list[shapely.geometry.point.Point]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_label_positions(self) -&gt; list[geom.Point]:
  &#34;&#34;&#34;Returns a reasonable location at which to position edge labels inside
  tile shape.

  Returns:
      list[geom.Point]: list of locations
  &#34;&#34;&#34;
  d = (self.shape.area ** 0.5) / 8
  c = self.centre
  # note direction is important as edge might not be a simple line segment
  sides = [e.get_geometry(CW) for e, CW in zip(self.edges, self.edges_CW)]
  return [geom.LineString([s.centroid, c]).line_interpolate_point(d) 
          for s in sides]</code></pre>
</details>
<div class="desc"><p>Returns a reasonable location at which to position edge labels inside
tile shape.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.Point]</code></dt>
<dd>list of locations</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_merged_edge"><code class="name flex">
<span>def <span class="ident">get_merged_edge</span></span>(<span>self, i: int, j: int) ‑> <a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_merged_edge(self, i:int, j:int) -&gt; &#34;Edge&#34;:
  &#34;&#34;&#34;Returns the new edge resulting from merging the two existing edges at
  index positions i and j in the edges list. For example, if the current list 
  of edge IDs was

      (0 1 2) (4 2) (4 5) (5 0)

  and the merge Vertex was #2, the resulting new edge is constructed from 
  vertices (0 1 2 4). 

  Returns:
    Edge: the requested new Edge.
  &#34;&#34;&#34;
  # if i and j are not consecutive, then j is predecessor edge
  if abs(i - j) != 1:
    i, j = j, i
  # get edges and their directions
  ei, ej = self.edges[i], self.edges[j]
  CWi, CWj = self.edges_CW[i], self.edges_CW[j]
  # DON&#39;T MESS WITH THIS!!!
  # for predecessors (the head) we want everything including the Vertex 
  # where the merge is occurring; for successors (the tail) we want all but 
  # the first Vertex (which is the one where the merge is occurring). In both 
  # cases contingent on whether existing Edges are CW or CCW we may need to 
  # flip the Vertex sequence to ensure that the merge Vertex is in the middle 
  # of the new edge that will be created
  head = ei.corners if CWi else ei.corners[::-1]
  tail = ej.corners[1:] if CWj else ej.corners[::-1][1:]
  v_sequence = (head if CWi else head[::-1]) + (tail if CWj else tail[::-1])
  return Edge(v_sequence)</code></pre>
</details>
<div class="desc"><p>Returns the new edge resulting from merging the two existing edges at
index positions i and j in the edges list. For example, if the current list
of edge IDs was</p>
<pre><code>(0 1 2) (4 2) (4 5) (5 0)
</code></pre>
<p>and the merge Vertex was #2, the resulting new edge is constructed from
vertices (0 1 2 4). </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a></code></dt>
<dd>the requested new Edge.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_updated_edges_from_merge"><code class="name flex">
<span>def <span class="ident">get_updated_edges_from_merge</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>,<br>new_edge: <a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a> = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_updated_edges_from_merge(self, v:&#34;Vertex&#34;, new_edge:&#34;Edge&#34; = None):
  &#34;&#34;&#34;Updates the edges and edges_CW attributes based on insertion of 
  the supplied Vertex. If new_edge is supplied then the neighbour tile at
  v has already created the needed new Edge and this Edge is the one that
  will be &#39;slotted in&#39; at the appropriate spot in the edges list.

  The edges_CW is also updated to maintain correct directions of the edges.
  The corners attribute is unaffected by these changes.

  Args:
    v (Vertex): existing Vertex at which to carry out the merge.
    new_edge (Edge, optional): if another Tile has already carried out this 
      merge this should be the resulting new Edge for insertion into this 
      Tile. Defaults to None (when the new Edge will be constructed).

  Returns:
    Union[None, tuple]: either None (if a new edge was supplied) or a tuple 
      of the two edge IDs to be removed and the new edge added for return to
      the calling context (i.e. the containing Topology).
  &#34;&#34;&#34;
  # get the two edge list index positions in which Vertex v is found
  i, j = self.get_edge_IDs_including_vertex(v)
  if new_edge is None: # then we must make a new one
    # also record existing edge IDs to be removed
    to_remove = [self.edges[i].ID, self.edges[j].ID]
    new_edge = self.get_merged_edge(i, j)
    return_edge_updates = True
  else:
    return_edge_updates = False
  if abs(i - j) != 1:
    # edge indices &#39;wrap&#39; around from end of edge list to start so drop 
    # first and last current edges and stick new one on at the end
    self.edges = self.edges[1:-1] + [new_edge] 
  else:
    # insert new edge into list in place of the two old ones
    self.edges = self.edges[:i] + [new_edge] + self.edges[j+1:]
  # update the edge directions
  self.set_edge_directions()
  if return_edge_updates:
    return to_remove, new_edge
  else:
    return None</code></pre>
</details>
<div class="desc"><p>Updates the edges and edges_CW attributes based on insertion of
the supplied Vertex. If new_edge is supplied then the neighbour tile at
v has already created the needed new Edge and this Edge is the one that
will be 'slotted in' at the appropriate spot in the edges list.</p>
<p>The edges_CW is also updated to maintain correct directions of the edges.
The corners attribute is unaffected by these changes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>existing Vertex at which to carry out the merge.</dd>
<dt><strong><code>new_edge</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a></code>, optional</dt>
<dd>if another Tile has already carried out this
merge this should be the resulting new Edge for insertion into this
Tile. Defaults to None (when the new Edge will be constructed).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, tuple]</code></dt>
<dd>either None (if a new edge was supplied) or a tuple
of the two edge IDs to be removed and the new edge added for return to
the calling context (i.e. the containing Topology).</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.get_vertex_label_positions"><code class="name flex">
<span>def <span class="ident">get_vertex_label_positions</span></span>(<span>self) ‑> list[shapely.geometry.point.Point]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertex_label_positions(self) -&gt; list[geom.Point]:
  &#34;&#34;&#34;Returns a viable location at which to position corner labels inside
  tile shape. The method is convoluted because a negative buffer may remove
  colinear corners resulting in fewer positions than we have corners in the
  tile shape!

  Returns:
      list[geom.Point]: list of locations.
  &#34;&#34;&#34;
  d = (self.shape.area ** 0.5) / 8
  c = self.centre
  corners = [c.point for c in self.corners]
  return [geom.LineString([p, c]).line_interpolate_point(d) for p in corners]</code></pre>
</details>
<div class="desc"><p>Returns a viable location at which to position corner labels inside
tile shape. The method is convoluted because a negative buffer may remove
colinear corners resulting in fewer positions than we have corners in the
tile shape!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.Point]</code></dt>
<dd>list of locations.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.insert_vertex_at"><code class="name flex">
<span>def <span class="ident">insert_vertex_at</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>,<br>i: int,<br>update_shape: bool = False) ‑> tuple</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_vertex_at(self, v:&#34;Vertex&#34;, i:int, 
                     update_shape:bool = False) -&gt; tuple:
  &#34;&#34;&#34;Method to insert the supplied Vertex into tile at index position i, 
  optionally updating the shape attribute. Both corners and edges attributes
  are updated, and the old edge IDs for removal and the new edge itself are
  returned to the calling context (the containing Topology) for update of its
  edges collection.

  This is NOT a generic vertex insertion method: it is only for use during 
  Topology initialisation, and does not guarantee correct maintenance of 
  all tile, edge and vertex relations in the general case---at any rate it
  has not been tested for this!

  Args:
      v (Vertex): the Vertex to insert.
      i (int): index position in current corners after which to insert 
        supplied Vertex.
      update_shape (bool, optional): if True shape attribute is updated. 
        Defaults to False.

  Returns:
    tuple: the (tuple) ID of the old edge which should be deleted, and 
      the new Edges arising from insertion of this Vertex.
  &#34;&#34;&#34;
  self.corners = self.corners[:i] + [v] + self.corners[i:]
  old_edge = self.edges[i - 1]
  # store current ID of the affected edge for return to calling context
  old_edge_ID = old_edge.ID
  new_edges = old_edge.insert_vertex(v, self.corners[i - 1])
  self.edges = self.edges[:(i-1)] + new_edges + self.edges[i:]
  self.set_edge_directions()
  if update_shape:
    self.set_shape_from_corners()
  return old_edge_ID, new_edges</code></pre>
</details>
<div class="desc"><p>Method to insert the supplied Vertex into tile at index position i,
optionally updating the shape attribute. Both corners and edges attributes
are updated, and the old edge IDs for removal and the new edge itself are
returned to the calling context (the containing Topology) for update of its
edges collection.</p>
<p>This is NOT a generic vertex insertion method: it is only for use during
Topology initialisation, and does not guarantee correct maintenance of
all tile, edge and vertex relations in the general case&mdash;at any rate it
has not been tested for this!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>the Vertex to insert.</dd>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>index position in current corners after which to insert
supplied Vertex.</dd>
<dt><strong><code>update_shape</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True shape attribute is updated.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>the (tuple) ID of the old edge which should be deleted, and
the new Edges arising from insertion of this Vertex.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.merge_edges_at_vertex"><code class="name flex">
<span>def <span class="ident">merge_edges_at_vertex</span></span>(<span>self,<br>v: <a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a>) ‑> tuple</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_edges_at_vertex(self, v:&#34;Vertex&#34;) -&gt; tuple:
  &#34;&#34;&#34;Method to merge the edges that meet at the supplied Vertex. It is 
  assumed that only two tiles are impacted this one, and its neighbour across
  the Edge on which v lies. Both are updated. For this reason the work is
  delegated to get_updated_edges_from_merge which is run on both affected
  tiles, but only determines the edges to remove and the new edge to be added
  once. See that method for details.
  
  Args:
    v (Vertex): Vertex at which to merge Edges. This should currently be an
      end
  
  Returns:
    tuple: 2 item list of the edge IDs to be removed and a new Edge object to
      be added by the calling context (i.e. the containing Topology).
  &#34;&#34;&#34;
  to_remove, new_edge = self.get_updated_edges_from_merge(v)
  if len(v.tiles) &gt; 1:
    v.tiles[1].get_updated_edges_from_merge(v, new_edge)
  return to_remove, new_edge</code></pre>
</details>
<div class="desc"><p>Method to merge the edges that meet at the supplied Vertex. It is
assumed that only two tiles are impacted this one, and its neighbour across
the Edge on which v lies. Both are updated. For this reason the work is
delegated to get_updated_edges_from_merge which is run on both affected
tiles, but only determines the edges to remove and the new edge to be added
once. See that method for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></dt>
<dd>Vertex at which to merge Edges. This should currently be an
end</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>2 item list of the edge IDs to be removed and a new Edge object to
be added by the calling context (i.e. the containing Topology).</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.offset_corners"><code class="name flex">
<span>def <span class="ident">offset_corners</span></span>(<span>self, offset: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset_corners(self, offset:int):
  &#34;&#34;&#34;Shifts shape, corners, edges, and edges_CW by an offset amount. This is
  used to align tiles that are similar, which is required for correct 
  transfer of &#39;base&#39; tile labelling on to &#39;radius 1&#39; tiles during Topology 
  construction.

  Args:
    offset int: the number of positions to shift the lists.
  &#34;&#34;&#34;
  if not offset is None or offset == 0:
    self.shape = tiling_utils.offset_polygon_corners(self.shape, offset)
    self.corners = self.corners[offset:] + self.corners[:offset]
    self.edges = self.edges[offset:] + self.edges[:offset]
    self.edges_CW = self.edges_CW[offset:] + self.edges_CW[:offset]</code></pre>
</details>
<div class="desc"><p>Shifts shape, corners, edges, and edges_CW by an offset amount. This is
used to align tiles that are similar, which is required for correct
transfer of 'base' tile labelling on to 'radius 1' tiles during Topology
construction.</p>
<h2 id="args">Args</h2>
<p>offset int: the number of positions to shift the lists.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.set_corners_from_edges"><code class="name flex">
<span>def <span class="ident">set_corners_from_edges</span></span>(<span>self, update_shape: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_corners_from_edges(self, update_shape:bool = True):
  &#34;&#34;&#34;Sets the corners attribute from the edges attribute. Typically called 
  after modification of topology edges. Optionally the shape attribute is NOT
  updated, which may save time when multiple changes to the edges of a tile
  are in process (i.e., only update the shape after all changes are complete).

  Args:
    update_shape (bool, optional): if True the shape attribute will be 
      updated, otherwise not. Defaults to True.
  &#34;&#34;&#34;
  self.corners = []
  for e, cw in zip(self.edges, self.edges_CW):
    if cw: # clockwise to extend by all but the first corner
      self.corners.extend(e.corners[:-1])
    else: # counter-clockwise so extend in reverse
      self.corners.extend(e.corners[1:][::-1])
  if update_shape:
    self.set_shape_from_corners()</code></pre>
</details>
<div class="desc"><p>Sets the corners attribute from the edges attribute. Typically called
after modification of topology edges. Optionally the shape attribute is NOT
updated, which may save time when multiple changes to the edges of a tile
are in process (i.e., only update the shape after all changes are complete).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>update_shape</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True the shape attribute will be
updated, otherwise not. Defaults to True.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.set_edge_directions"><code class="name flex">
<span>def <span class="ident">set_edge_directions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edge_directions(self):
  &#34;&#34;&#34;Sets up the edges_CW attribute by inspection of the edges list.
  It is (frankly!) hard to keep track of the correct sequence of CW/CCW order
  of edges as new ones are created or old ones merged. This method inspects
  the &#39;tail-head&#39; relations between consecutive edges to set these flags 
  correctly.

  The test is simply to check if the &#39;tail&#39; Vertex ID in each edge appears
  in the ID tuple of the following edge, i.e. if successive edge 
  IDs are (0, 1) (2, 1) or (0, 1) (1, 2), then edge (0, 1) is in clockwise
  direction, but if we have (0, 1) (2, 3) then it is not.
  &#34;&#34;&#34;
  edge_IDs = self.get_edge_IDs()
  self.edges_CW = [e1[-1] in e2 for e1, e2 in 
                   zip(edge_IDs, edge_IDs[1:] + edge_IDs[:1])]</code></pre>
</details>
<div class="desc"><p>Sets up the edges_CW attribute by inspection of the edges list.
It is (frankly!) hard to keep track of the correct sequence of CW/CCW order
of edges as new ones are created or old ones merged. This method inspects
the 'tail-head' relations between consecutive edges to set these flags
correctly.</p>
<p>The test is simply to check if the 'tail' Vertex ID in each edge appears
in the ID tuple of the following edge, i.e. if successive edge
IDs are (0, 1) (2, 1) or (0, 1) (1, 2), then edge (0, 1) is in clockwise
direction, but if we have (0, 1) (2, 3) then it is not.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Tile.set_shape_from_corners"><code class="name flex">
<span>def <span class="ident">set_shape_from_corners</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shape_from_corners(self):
  &#34;&#34;&#34;Sets the shape attribute based on the current list of corners, and sets 
  the associated tile centre.
  &#34;&#34;&#34;
  self.shape = geom.Polygon([c.point for c in self.corners])
  self.centre = tiling_utils.get_incentre(
    tiling_utils.get_clean_polygon(self.shape))</code></pre>
</details>
<div class="desc"><p>Sets the shape attribute based on the current list of corners, and sets
the associated tile centre.</p></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.topology_elements.Vertex"><code class="flex name class">
<span>class <span class="ident">Vertex</span></span>
<span>(</span><span>point: shapely.geometry.point.Point, ID: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vertex:
  &#34;&#34;&#34;Class to store attributes of a vertex in a tiling.&#34;&#34;&#34;
  point: geom.Point
  &#34;&#34;&#34;point (geom.Point): point location of the vertex.&#34;&#34;&#34;
  ID: int
  &#34;&#34;&#34;integer (mostly but not necessarily in sequence) of vertex keyed into the 
  points dictionary of the containing Topology.&#34;&#34;&#34;
  tiles: list[&#34;Tile&#34;]
  &#34;&#34;&#34;list of Tiles incident on this vertex.&#34;&#34;&#34;
  neighbours: list[int]
  &#34;&#34;&#34;list of the immediately adjacent other corner IDs. Only required to 
  determine if a point is a tiling vertex (when it will have) three or more 
  neighbours, so only IDs are stored.&#34;&#34;&#34;
  base_ID: int = 1_000_000
  &#34;&#34;&#34;ID of corresponding Vertex in the tileable base_unit&#34;&#34;&#34;
  transitivity_class: int = None
  &#34;&#34;&#34;transitivity class of the vertex under symmetries of the tiling&#34;&#34;&#34;
  label: str = &#34;&#34;
  &#34;&#34;&#34;the (upper case letter) label of the vertex under the symmetries of the 
  tiling.&#34;&#34;&#34;
  is_tiling_vertex: bool = True
  &#34;&#34;&#34;is_tiling_vertex (bool): True if this is a tiling vertex, rather than a 
  tile corner. E.g., A below is a corner, not a tiling vertex. B is a tiling 
  vertex:
      
      +-------+
      | 1     |
      |   A---B---+
      |   | 2     |
      +---C   +---+
          |   |
          +---+&#34;&#34;&#34;
  
  def __init__(self, point:geom.Point, ID:int):
    &#34;&#34;&#34;Class constructor.

    Args:
      point (geom.Point): point location of the vertex.
      ID (int): a unique integer ID (which will be its key in the containing
        Topology points dictionary).
    &#34;&#34;&#34;
    self.point = point
    self.ID = ID
    self.base_ID = self.ID
    self.tiles = []
    self.neighbours = []

  def __str__(self) -&gt; str:
    &#34;&#34;&#34;Returns string representation of Vertex.
    
    Returns:
        str: string including ID, point and list of incident Tiles.
    &#34;&#34;&#34;
    return f&#34;Vertex {self.ID} at {self.point} Tiles: {self.get_tile_IDs()}&#34;

  def __repr__(self) -&gt; str:
    return str(self)

  def get_tile_IDs(self) -&gt; list[int]:
    &#34;&#34;&#34;Convenience method to return list of Tile IDs (not the Tiles themselves).

    Returns:
        list[int]: list of Tile IDs
    &#34;&#34;&#34;
    return [t.ID for t in self.tiles]

  def add_tile(self, tile:Tile):
    &#34;&#34;&#34;Adds supplied Tile to the tiles list if it is not already present.

    Args:
        tile (Tile): Tile to add.
    &#34;&#34;&#34;
    if not tile in self.tiles:
      self.tiles.append(tile)

  def add_neighbour(self, vertex_id:int):
    &#34;&#34;&#34;Adds supplied ID to the neighbours list if it is not already present

    Args:
      vertex_id (int): ID to add to the neighbours list.
    &#34;&#34;&#34;
    if not vertex_id in self.neighbours:
      self.neighbours.append(vertex_id)

  def clockwise_order_incident_tiles(self):
    &#34;&#34;&#34;Reorders the tiles list clockwise (this is for dual tiling construction)
    &#34;&#34;&#34;
    cw_order = tiling_utils.order_of_pts_cw_around_centre(
      [t.centre for t in self.tiles], self.point)
    self.tiles = [self.tiles[i] for i in cw_order]

  def is_interior(self) -&gt; bool:
    &#34;&#34;&#34;Tests if vertex is completely enclosed by its incident Tiles. Based on
    summing the interior angles of the incident tiles at this vertex.

    Returns:
        bool: True if vertex is completely enclosed by incident Tiles.
    &#34;&#34;&#34;
    return abs(360 - sum([t.angle_at(self) for t in self.tiles])) \
                     &lt; tiling_utils.RESOLUTION</code></pre>
</details>
<div class="desc"><p>Class to store attributes of a vertex in a tiling.</p>
<p>Class constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>geom.Point</code></dt>
<dd>point location of the vertex.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>int</code></dt>
<dd>a unique integer ID (which will be its key in the containing
Topology points dictionary).</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.topology_elements.Vertex.ID"><code class="name">var <span class="ident">ID</span> : int</code></dt>
<dd>
<div class="desc"><p>integer (mostly but not necessarily in sequence) of vertex keyed into the
points dictionary of the containing Topology.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.base_ID"><code class="name">var <span class="ident">base_ID</span> : int</code></dt>
<dd>
<div class="desc"><p>ID of corresponding Vertex in the tileable base_unit</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.is_tiling_vertex"><code class="name">var <span class="ident">is_tiling_vertex</span> : bool</code></dt>
<dd>
<div class="desc"><p>is_tiling_vertex (bool): True if this is a tiling vertex, rather than a
tile corner. E.g., A below is a corner, not a tiling vertex. B is a tiling
vertex:</p>
<pre><code>+-------+
| 1     |
|   A---B---+
|   | 2     |
+---C   +---+
    |   |
    +---+
</code></pre></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>the (upper case letter) label of the vertex under the symmetries of the
tiling.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.neighbours"><code class="name">var <span class="ident">neighbours</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>list of the immediately adjacent other corner IDs. Only required to
determine if a point is a tiling vertex (when it will have) three or more
neighbours, so only IDs are stored.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.point"><code class="name">var <span class="ident">point</span> : shapely.geometry.point.Point</code></dt>
<dd>
<div class="desc"><p>point (geom.Point): point location of the vertex.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.tiles"><code class="name">var <span class="ident">tiles</span> : list[<a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a>]</code></dt>
<dd>
<div class="desc"><p>list of Tiles incident on this vertex.</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.transitivity_class"><code class="name">var <span class="ident">transitivity_class</span> : int</code></dt>
<dd>
<div class="desc"><p>transitivity class of the vertex under symmetries of the tiling</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.topology_elements.Vertex.add_neighbour"><code class="name flex">
<span>def <span class="ident">add_neighbour</span></span>(<span>self, vertex_id: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_neighbour(self, vertex_id:int):
  &#34;&#34;&#34;Adds supplied ID to the neighbours list if it is not already present

  Args:
    vertex_id (int): ID to add to the neighbours list.
  &#34;&#34;&#34;
  if not vertex_id in self.neighbours:
    self.neighbours.append(vertex_id)</code></pre>
</details>
<div class="desc"><p>Adds supplied ID to the neighbours list if it is not already present</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertex_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID to add to the neighbours list.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.add_tile"><code class="name flex">
<span>def <span class="ident">add_tile</span></span>(<span>self,<br>tile: <a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tile(self, tile:Tile):
  &#34;&#34;&#34;Adds supplied Tile to the tiles list if it is not already present.

  Args:
      tile (Tile): Tile to add.
  &#34;&#34;&#34;
  if not tile in self.tiles:
    self.tiles.append(tile)</code></pre>
</details>
<div class="desc"><p>Adds supplied Tile to the tiles list if it is not already present.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tile</code></strong> :&ensp;<code><a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a></code></dt>
<dd>Tile to add.</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.clockwise_order_incident_tiles"><code class="name flex">
<span>def <span class="ident">clockwise_order_incident_tiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clockwise_order_incident_tiles(self):
  &#34;&#34;&#34;Reorders the tiles list clockwise (this is for dual tiling construction)
  &#34;&#34;&#34;
  cw_order = tiling_utils.order_of_pts_cw_around_centre(
    [t.centre for t in self.tiles], self.point)
  self.tiles = [self.tiles[i] for i in cw_order]</code></pre>
</details>
<div class="desc"><p>Reorders the tiles list clockwise (this is for dual tiling construction)</p></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.get_tile_IDs"><code class="name flex">
<span>def <span class="ident">get_tile_IDs</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tile_IDs(self) -&gt; list[int]:
  &#34;&#34;&#34;Convenience method to return list of Tile IDs (not the Tiles themselves).

  Returns:
      list[int]: list of Tile IDs
  &#34;&#34;&#34;
  return [t.ID for t in self.tiles]</code></pre>
</details>
<div class="desc"><p>Convenience method to return list of Tile IDs (not the Tiles themselves).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[int]</code></dt>
<dd>list of Tile IDs</dd>
</dl></div>
</dd>
<dt id="weavingspace.topology_elements.Vertex.is_interior"><code class="name flex">
<span>def <span class="ident">is_interior</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_interior(self) -&gt; bool:
  &#34;&#34;&#34;Tests if vertex is completely enclosed by its incident Tiles. Based on
  summing the interior angles of the incident tiles at this vertex.

  Returns:
      bool: True if vertex is completely enclosed by incident Tiles.
  &#34;&#34;&#34;
  return abs(360 - sum([t.angle_at(self) for t in self.tiles])) \
                   &lt; tiling_utils.RESOLUTION</code></pre>
</details>
<div class="desc"><p>Tests if vertex is completely enclosed by its incident Tiles. Based on
summing the interior angles of the incident tiles at this vertex.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if vertex is completely enclosed by incident Tiles.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.topology_elements.Edge" href="#weavingspace.topology_elements.Edge">Edge</a></code></h4>
<ul class="two-column">
<li><code><a title="weavingspace.topology_elements.Edge.ID" href="#weavingspace.topology_elements.Edge.ID">ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.base_ID" href="#weavingspace.topology_elements.Edge.base_ID">base_ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.corners" href="#weavingspace.topology_elements.Edge.corners">corners</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.get_corner_IDs" href="#weavingspace.topology_elements.Edge.get_corner_IDs">get_corner_IDs</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.get_geometry" href="#weavingspace.topology_elements.Edge.get_geometry">get_geometry</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.get_topology" href="#weavingspace.topology_elements.Edge.get_topology">get_topology</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.get_vertex_IDs" href="#weavingspace.topology_elements.Edge.get_vertex_IDs">get_vertex_IDs</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.insert_vertex" href="#weavingspace.topology_elements.Edge.insert_vertex">insert_vertex</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.label" href="#weavingspace.topology_elements.Edge.label">label</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.left_tile" href="#weavingspace.topology_elements.Edge.left_tile">left_tile</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.right_tile" href="#weavingspace.topology_elements.Edge.right_tile">right_tile</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.transitivity_class" href="#weavingspace.topology_elements.Edge.transitivity_class">transitivity_class</a></code></li>
<li><code><a title="weavingspace.topology_elements.Edge.vertices" href="#weavingspace.topology_elements.Edge.vertices">vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.topology_elements.Tile" href="#weavingspace.topology_elements.Tile">Tile</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.topology_elements.Tile.ID" href="#weavingspace.topology_elements.Tile.ID">ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.angle_at" href="#weavingspace.topology_elements.Tile.angle_at">angle_at</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.base_ID" href="#weavingspace.topology_elements.Tile.base_ID">base_ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.centre" href="#weavingspace.topology_elements.Tile.centre">centre</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.corners" href="#weavingspace.topology_elements.Tile.corners">corners</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.edge_labels" href="#weavingspace.topology_elements.Tile.edge_labels">edge_labels</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.edges" href="#weavingspace.topology_elements.Tile.edges">edges</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.edges_CW" href="#weavingspace.topology_elements.Tile.edges_CW">edges_CW</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_corner_IDs" href="#weavingspace.topology_elements.Tile.get_corner_IDs">get_corner_IDs</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_corner_label" href="#weavingspace.topology_elements.Tile.get_corner_label">get_corner_label</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_edge_IDs" href="#weavingspace.topology_elements.Tile.get_edge_IDs">get_edge_IDs</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_edge_IDs_including_vertex" href="#weavingspace.topology_elements.Tile.get_edge_IDs_including_vertex">get_edge_IDs_including_vertex</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_edge_label" href="#weavingspace.topology_elements.Tile.get_edge_label">get_edge_label</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_edge_label_positions" href="#weavingspace.topology_elements.Tile.get_edge_label_positions">get_edge_label_positions</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_merged_edge" href="#weavingspace.topology_elements.Tile.get_merged_edge">get_merged_edge</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_updated_edges_from_merge" href="#weavingspace.topology_elements.Tile.get_updated_edges_from_merge">get_updated_edges_from_merge</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.get_vertex_label_positions" href="#weavingspace.topology_elements.Tile.get_vertex_label_positions">get_vertex_label_positions</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.insert_vertex_at" href="#weavingspace.topology_elements.Tile.insert_vertex_at">insert_vertex_at</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.label" href="#weavingspace.topology_elements.Tile.label">label</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.merge_edges_at_vertex" href="#weavingspace.topology_elements.Tile.merge_edges_at_vertex">merge_edges_at_vertex</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.offset_corners" href="#weavingspace.topology_elements.Tile.offset_corners">offset_corners</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.set_corners_from_edges" href="#weavingspace.topology_elements.Tile.set_corners_from_edges">set_corners_from_edges</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.set_edge_directions" href="#weavingspace.topology_elements.Tile.set_edge_directions">set_edge_directions</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.set_shape_from_corners" href="#weavingspace.topology_elements.Tile.set_shape_from_corners">set_shape_from_corners</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.shape" href="#weavingspace.topology_elements.Tile.shape">shape</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.shape_group" href="#weavingspace.topology_elements.Tile.shape_group">shape_group</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.transitivity_class" href="#weavingspace.topology_elements.Tile.transitivity_class">transitivity_class</a></code></li>
<li><code><a title="weavingspace.topology_elements.Tile.vertex_labels" href="#weavingspace.topology_elements.Tile.vertex_labels">vertex_labels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.topology_elements.Vertex" href="#weavingspace.topology_elements.Vertex">Vertex</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.topology_elements.Vertex.ID" href="#weavingspace.topology_elements.Vertex.ID">ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.add_neighbour" href="#weavingspace.topology_elements.Vertex.add_neighbour">add_neighbour</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.add_tile" href="#weavingspace.topology_elements.Vertex.add_tile">add_tile</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.base_ID" href="#weavingspace.topology_elements.Vertex.base_ID">base_ID</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.clockwise_order_incident_tiles" href="#weavingspace.topology_elements.Vertex.clockwise_order_incident_tiles">clockwise_order_incident_tiles</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.get_tile_IDs" href="#weavingspace.topology_elements.Vertex.get_tile_IDs">get_tile_IDs</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.is_interior" href="#weavingspace.topology_elements.Vertex.is_interior">is_interior</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.is_tiling_vertex" href="#weavingspace.topology_elements.Vertex.is_tiling_vertex">is_tiling_vertex</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.label" href="#weavingspace.topology_elements.Vertex.label">label</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.neighbours" href="#weavingspace.topology_elements.Vertex.neighbours">neighbours</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.point" href="#weavingspace.topology_elements.Vertex.point">point</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.tiles" href="#weavingspace.topology_elements.Vertex.tiles">tiles</a></code></li>
<li><code><a title="weavingspace.topology_elements.Vertex.transitivity_class" href="#weavingspace.topology_elements.Vertex.transitivity_class">transitivity_class</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
