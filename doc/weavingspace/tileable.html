<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.tileable API documentation</title>
<meta name="description" content="Implements `weavingspace.tileable.TileShape` and
`weavingspace.tileable.Tileable` the base classes for
`weavingspace.tile_unit.TileUnit` and …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tileable</code></h1>
</header>
<section id="section-intro">
<p>Implements <code><a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code> and
<code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> the base classes for
<code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> and <code><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code>.</p>
<p><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> should not be called directly, but is instead accessed from the
<code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> or <code><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code>
constructor.</p>
<p>Several methods of <code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> are generally useful and
can be accessed through its subclasses.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.tileable.TileShape"><code class="flex name class">
<span>class <span class="ident">TileShape</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TileShape(Enum):
  &#34;&#34;&#34;The available base tile shapes.

  NOTE: the TRIANGLE type does not persist, but should be converted to a
  DIAMOND or HEXAGON type during `Tileable` construction.
  &#34;&#34;&#34;

  RECTANGLE = &#34;rectangle&#34;
  HEXAGON = &#34;hexagon&#34;
  TRIANGLE = &#34;triangle&#34;
  DIAMOND = &#34;diamond&#34;</code></pre>
</details>
<div class="desc"><p>The available base tile shapes.</p>
<p>NOTE: the TRIANGLE type does not persist, but should be converted to a
DIAMOND or HEXAGON type during <code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> construction.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tileable.TileShape.DIAMOND"><code class="name">var <span class="ident">DIAMOND</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.tileable.TileShape.HEXAGON"><code class="name">var <span class="ident">HEXAGON</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.tileable.TileShape.RECTANGLE"><code class="name">var <span class="ident">RECTANGLE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="weavingspace.tileable.TileShape.TRIANGLE"><code class="name">var <span class="ident">TRIANGLE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.tileable.Tileable"><code class="flex name class">
<span>class <span class="ident">Tileable</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Tileable:
  &#34;&#34;&#34;Class to represent a tileable set of tile geometries.
  &#34;&#34;&#34;

  tiles: gpd.GeoDataFrame = None
  &#34;&#34;&#34;the geometries with associated `title_id` attribute encoding their 
  different colouring.&#34;&#34;&#34;
  prototile: gpd.GeoDataFrame = None
  &#34;&#34;&#34;the tileable polygon (rectangle, hexagon or diamond)&#34;&#34;&#34;
  spacing: float = 1000.0
  &#34;&#34;&#34;the tile spacing effectively the resolution of the tiling. Defaults to
  1000&#34;&#34;&#34;
  base_shape: TileShape = TileShape.RECTANGLE
  &#34;&#34;&#34;the tile shape. Defaults to &#39;RECTANGLE&#39;&#34;&#34;&#34;
  vectors: dict[tuple[int], tuple[float]] = None
  &#34;&#34;&#34;translation vector symmetries of the tiling&#34;&#34;&#34;
  regularised_prototile: gpd.GeoDataFrame = None
  &#34;&#34;&#34;polygon containing the tiles of this tileable, usually a union of its
  tile polygons&#34;&#34;&#34;
  crs: int = 3857
  &#34;&#34;&#34;coordinate reference system of the tile. Most often an ESPG code but
  any valid geopandas CRS specification is valid. Defaults to 3857 (i.e. Web
  Mercator).&#34;&#34;&#34;
  rotation: float = 0.0
  &#34;&#34;&#34;cumulative rotation of the tileable.&#34;&#34;&#34;
  debug: bool = False
  &#34;&#34;&#34;if True prints debug messages. Defaults to False.&#34;&#34;&#34;

  # Tileable constructor called by subclasses - should not be used directly
  def __init__(self, **kwargs):
    for k, v in kwargs.items():
      self.__dict__[k] = v
    if self.debug:
      print(
        f&#34;&#34;&#34;Debugging messages enabled for Tileable (but there aren&#39;t
          any at the moment...)&#34;&#34;&#34;
      )
    self._setup_tiles()
    self.setup_vectors()
    self._setup_regularised_prototile()
    return


  def setup_vectors(self) -&gt; None:
    &#34;&#34;&#34;Sets up the symmetry translation vectors as floating point pairs
    indexed by integer tuples with respect to either a rectangular or
    triangular grid location.

    Derived from the size and shape of the tile attribute. These are not
    the minimal translation vectors, but the &#39;face to face&#39; vectors of the
    tile, such that a hexagonal tile will have 3 vectors, not the minimal
    parallelogram pair. Also supplies the inverse vectors.

    The vectors are stored in a dictionary indexed by their
    coordinates, e.g.

      {( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
       (-1,  0): (-100, 0), ( 0, -1): (0, -100)}

    For a tileable of type `TileShape.HEXAGON`, the indexing tuples
    have three components. See https://www.redblobgames.com/grids/hexagons/
    &#34;&#34;&#34;
    t = self.prototile.geometry[0]
    pts = [p for p in t.exterior.coords][:-1]
    n_pts = len(pts)
    vec_dict = {}
    if n_pts == 4:
      vecs = [(q[0] - p[0], q[1] - p[1])
          for p, q in zip(pts, pts[1:] + pts[:1])]
      i = [1, 0, -1,  0]
      j = [0, 1,  0, -1]
      vec_dict = {(i, j): v for i, j, v in zip(i, j, vecs)}
    elif n_pts == 6:
      vecs = [(q[0] - p[0], q[1] - p[1])
          for p, q in zip(pts, pts[2:] + pts[:2])]
      # hex grid coordinates associated with each of the vectors
      i = [ 0,  1,  1,  0, -1, -1]
      j = [ 1,  0, -1, -1,  0,  1]
      k = [-1, -1,  0,  1,  1,  0]
      vec_dict = {(i, j, k): v for i, j, k, v in zip(i, j, k, vecs)}
    self.vectors = vec_dict


  def get_vectors(
      self, as_dict: bool = False
    ) -&gt; Union[dict[tuple[int], tuple[float]], list[tuple[float]]]:
    &#34;&#34;&#34;
    Returns symmetry translation vectors as floating point pairs.
    Optionally returns the vectors in a dictionary indexed by their
    coordinates, e.g.

      {( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
       (-1,  0): (-100, 0), ( 0, -1): (0, -100)}

    Returns:
      Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]:
        either the vectors as a list of float tuples, or a dictionary
        of those vectors indexed by integer coordinate tuples.
    &#34;&#34;&#34;
    if as_dict:
      return self.vectors
    else:
      return list(self.vectors.values())


  # Make up a regularised tile by carefully unioning the tiles
  def setup_regularised_prototile_from_tiles(self) -&gt; None:
    &#34;&#34;&#34;Sets the regularised tile to a union of the tiles.&#34;&#34;&#34;
    self.regularised_prototile = copy.deepcopy(self.prototile)
    self.regularised_prototile.geometry = [tiling_utils.safe_union(
      self.tiles.geometry, as_polygon = True)]
    # This simplification seems very crude but fixes all kinds of issues...
    # particularly with the triaxial weave units... where intersection 
    # operations are prone to creating spurious vertices, etc.
    self.regularised_prototile.loc[0, &#39;geometry&#39;] = \
      self.regularised_prototile.loc[0, &#39;geometry&#39;].simplify(
        self.spacing * tiling_utils.RESOLUTION)
    # self.regularised_prototile.geometry[0] = \
    #   self.regularised_prototile.geometry[0].simplify(
    #     self.spacing * tiling_utils.RESOLUTION)
    return


  def merge_fragments(self, fragments:list[geom.Polygon]) -&gt; list[geom.Polygon]:
    &#34;&#34;&#34;
    Merges a set of polygons based on testing if they touch when subjected
    to the translation vectors provided by `get_vectors()`.

    Called by `regularise_tiles()` to combine tiles in a tile unit that
    may be fragmented as supplied but will combine after tiling into single
    tiles. This step makes for more efficient implementation of the
    tiling of map regions.

    Args:
      fragments (list[geom.Polygon]): A set of polygons to merge.

    Returns:
      list[geom.Polygon]: A minimal list of merged polygons.
    &#34;&#34;&#34;
    if len(fragments) == 1:
      return [f for f in fragments if not f.is_empty]
    fragments = [f for f in fragments if not f.is_empty]
    prototile = self.prototile.geometry[0]
    reg_prototile = copy.deepcopy(self.regularised_prototile.geometry[0])
    changes_made = True
    while changes_made:
      changes_made = False
      for v in self.vectors.values():
        # empty list to collect the new fragments
        # assembled in this iteration
        next_frags = []
        t_frags = [affine.translate(f, v[0], v[1]) for f in fragments]
        # build a set of any near matching pairs of
        # fragments and their translated copies
        matches = set()
        for i, f1 in enumerate(fragments):
          for j, f2, in enumerate(t_frags):
            if i &lt; j and tiling_utils.touch_along_an_edge(f1, f2):
              matches.add((i, j))
        # determine which of these when unioned has the larger area in common # with the prototile
        frags_to_remove = set()
        for i, j in matches:
          f1, f2 = fragments[i], t_frags[j]
          u1 = f1.buffer(tiling_utils.RESOLUTION, join_style = 2, cap_style = 3).union(
            f2.buffer(tiling_utils.RESOLUTION, join_style = 2, cap_style = 3))
          u2 = affine.translate(u1, -v[0], -v[1])
          if prototile.intersection(u1).area &gt; prototile.intersection(u2).area:
            u1 = u1.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
            u2 = u2.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
            next_frags.append(u1)
            reg_prototile = reg_prototile.union(u1).difference(u2)
          else:
            u1 = u1.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
            u2 = u2.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
            next_frags.append(u2)
            reg_prototile = reg_prototile.union(u2).difference(u1)
          changes_made = True
          frags_to_remove.add(i)
          frags_to_remove.add(j)
        fragments = [f for i, f in enumerate(fragments)
                     if not (i in frags_to_remove)] + next_frags
    self.regularised_prototile.loc[0, &#34;geometry&#34;] = reg_prototile
    # self.regularised_prototile.geometry[0] = reg_prototile
    return [f for f in fragments if not f.is_empty] # don&#39;t return any duds


  def reattach_tiles(self) -&gt; None:
    &#34;&#34;&#34;Move tiles that are outside the regularised prototile main polygon
    back inside it adjusting regularised prototile if needed.
    &#34;&#34;&#34;
    reg_prototile = self.regularised_prototile.geometry[0]
    new_reg_prototile = copy.deepcopy(reg_prototile)
    new_tiles = list(self.tiles.geometry)
    for i, p in enumerate(self.tiles.geometry):
      if np.isclose(reg_prototile.intersection(p).area, p.area):
        new_tiles[i] = p
        continue
      for v in self.vectors.values():
        t_p = affine.translate(p, v[0], v[1])
        if reg_prototile.intersects(t_p):
          new_reg_prototile = new_reg_prototile.union(t_p)
          new_tiles[i] = t_p
    self.tiles.geometry = gpd.GeoSeries(new_tiles)
    self.regularised_prototile.loc[0, &#34;geometry&#34;] = new_reg_prototile
    # self.regularised_prototile.geometry[0] = new_reg_prototile
    return None


  def regularise_tiles(self) -&gt; None:
    &#34;&#34;&#34;Combines separate tiles that share a tile_id value into
    single tiles, if they would end up touching after tiling.

    Also adjusts the `Tileable.regularised_prototile`
    attribute accordingly.
    &#34;&#34;&#34;
    self.regularised_prototile = copy.deepcopy(self.prototile)
    # This preserves order while finding uniques, unlike list(set()).
    # Reordering ids might cause confusion when colour palettes
    # are not assigned explicitly to each id, but in the order
    # encountered in the tile_id Series of the GeoDataFrame.
    tiles, tile_ids = [], []
    ids = list(self.tiles.tile_id.unique())
    for id in ids:
      fragment_set = list(
        self.tiles[self.tiles.tile_id == id].geometry)
      merge_result = self.merge_fragments(fragment_set)
      tiles.extend(merge_result)
      tile_ids.extend([id] * len(merge_result))

    self.tiles = gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: tile_ids},
      crs = self.crs,
      geometry = gpd.GeoSeries([tiling_utils.get_clean_polygon(t) 
                                for t in tiles]))

    self.regularised_prototile = \
      self.regularised_prototile.explode(ignore_index = True)
    if self.regularised_prototile.shape[0] &gt; 1:
      self.regularised_prototile.geometry = tiling_utils.get_largest_polygon(
        self.regularised_prototile.geometry)
    return None


  def get_local_patch(self, r: int = 1,
                      include_0: bool = False) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Returns a GeoDataFrame with translated copies of the Tileable.

    The geodataframe takes the same form as the `Tileable.tile` attribute.

    Args:
      r (int, optional): the number of &#39;layers&#39; out from the unit to
        which the translate copies will extendt. Defaults to `1`.
      include_0 (bool, optional): If True includes the Tileable itself at
        (0, 0). Defaults to `False`.

    Returns:
      gpd.GeoDataFrame: A GeoDataframe of the tiles extended by a number 
        of &#39;layers&#39;.
    &#34;&#34;&#34;
    # a dictionary of all the vectors we need, starting with (0, 0)
    vecs = (
      {(0, 0, 0): (0, 0)}
      if self.base_shape in (TileShape.HEXAGON,)
      else {(0, 0): (0, 0)}
    )
    steps = r if self.base_shape in (TileShape.HEXAGON,) else r * 2
    # a dictionary of the last &#39;layer&#39; of added vectors
    last_vecs = copy.deepcopy(vecs)
    # get the translation vectors in a dictionary indexed by coordinates
    # we keep track of the sum of vectors using the (integer) coordinates
    # to avoid duplication of moves due to floating point inaccuracies
    vectors = self.get_vectors(as_dict = True)
    for i in range(steps):
      new_vecs = {}
      for k1, v1 in last_vecs.items():
        for k2, v2 in vectors.items():
          # add the coordinates to make a new key...
          new_key = tuple([k1[i] + k2[i] for i in range(len(k1))])
          # ... and the vector components to make a new value
          new_val = (v1[0] + v2[0], v1[1] + v2[1])
          # if we haven&#39;t reached here before store it
          if not new_key in vecs:
            new_vecs[new_key] = new_val
      # extend the vectors and set the last layer to the set just added
      vecs = vecs | new_vecs
      last_vecs = new_vecs
    if not include_0:  # throw away the identity vector
      vecs.pop((0, 0, 0) if self.base_shape in (TileShape.HEXAGON,) else (0, 0))
    ids, tiles = [], []
    # we need to add the translated prototiles in order of their distance from # tile 0, esp. in the square case, i.e. something like this:
    #
    #      5 4 3 4 5
    #      4 2 1 2 4
    #      3 1 0 1 3
    #      4 2 1 2 4
    #      5 4 3 4 5
    #
    # this is important for topology detection, where filtering back to the
    # local patch of radius 1 is greatly eased if prototiles have been added in 
    # this order. We use the vector index tuples not the euclidean distances
    # because this may be more resistant to odd effects for non-convex tiles
    extent = self.prototile.geometry.scale(
      2 * r + tiling_utils.RESOLUTION, 2 * r + tiling_utils.RESOLUTION,
      origin = self.prototile.geometry[0].centroid)[0]
    vector_lengths = {index: np.sqrt(sum([_ ** 2 for _ in index]))
                      for index in vecs.keys()}
    ordered_vector_keys = [k for k, v in sorted(vector_lengths.items(), 
                                                key = lambda item: item[1])]
    for k in ordered_vector_keys:
      v = vecs[k]
      if geom.Point(v[0], v[1]).within(extent):
        ids.extend(self.tiles.tile_id)
        tiles.extend(
          self.tiles.geometry.apply(affine.translate, xoff = v[0], yoff = v[1]))
    return gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: ids}, crs=self.crs,
      geometry = tiling_utils.gridify(gpd.GeoSeries(tiles))
    )


  def fit_tiles_to_prototile(self, centre_tile: int = 0) -&gt; None:
    &#34;&#34;&#34;Fits the tiles so they sit inside the prototile boundary.

    If tiles project outside the boundaries of the prototile, this
    method will clip them so that they don&#39;t. This may result in
    &#39;fragmented&#39; tiles, i.e. pieces that would form a single tile
    after tiling which are separated into fragments.

    Args:
      centre_tile (int, optional): the index position of the central
        tile. Defaults to `0`.
    &#34;&#34;&#34;
    dxy = self.tiles.geometry[centre_tile].centroid
    self.tiles.geometry = self.tiles.translate(-dxy.x, -dxy.y)
    # use r = 2 because rectangular tiles may need diagonal neighbours
    patch = (
      self.get_local_patch(r=2, include_0=True)
      if self.base_shape in (TileShape.RECTANGLE,)
      else self.get_local_patch(r=1, include_0=True)
    )
    self.tiles = patch.clip(self.prototile)
    # repair any weirdness...
    self.tiles.geometry = tiling_utils.repair_polygon(self.tiles.geometry)
    self.tiles = self.tiles[self.tiles.geometry.area &gt; 0]
    self.regularised_prototile = copy.deepcopy(self.prototile)
    return None


  # applicable to both TileUnits and WeaveUnits
  def inset_tiles(self, inset: float = 0) -&gt; &#34;Tileable&#34;:
    &#34;&#34;&#34;Returns a new Tileable with an inset applied around the tiles.

    Works by applying a negative buffer of specfied size to all tiles.
    Tiles that collapse to zero area are removed and the tile_id
    attribute updated accordingly.

    NOTE: this method is likely to not preserve the relative area of tiles.

    Args:
      inset (float, optional): The distance to inset. Defaults to `0`.

    Returns:
      &#34;Tileable&#34;: the new inset Tileable.
    &#34;&#34;&#34;
    inset_tiles, inset_ids = [], []
    for p, id in zip(self.tiles.geometry, self.tiles.tile_id):
      b = p.buffer(-inset, join_style = 2, cap_style = 3)
      if not b.area &lt;= 0:
        inset_tiles.append(b)
        inset_ids.append(id)
    result = copy.deepcopy(self)
    result.tiles = gpd.GeoDataFrame(
      data={&#34;tile_id&#34;: inset_ids},
      crs=self.crs,
      geometry=gpd.GeoSeries(inset_tiles),
    )
    return result


  def plot(self, ax = None, show_prototile: bool = True, 
    show_reg_prototile: bool = True, show_ids: str = &#34;tile_id&#34;,
    show_vectors: bool = False, r: int = 0, prototile_edgecolour: str = &#34;k&#34;, 
    reg_prototile_edgecolour: str = &#34;r&#34;, r_alpha: float = 0.3, 
    cmap: list[str] = None, figsize: tuple[float] = (8, 8), **kwargs) -&gt; pyplot.axes:
    &#34;&#34;&#34;Plots a representation of the Tileable on the supplied axis. **kwargs
    are passed on to matplotlib.plot()

    Args:
      ax (_type_, optional): matplotlib axis to draw to. Defaults to None.
      show_prototile (bool, optional): if `True` show the tile outline.
        Defaults to `True`.
      show_reg_prototile (bool, optional): if `True` show the regularised tile
        outline. Defaults to `True`.
      show_ids (str, optional): if `tile_id` show the tile_ids. If
        `id` show index number. If None or `&#39;&#39;` don&#39;t label tiles.
        Defaults to `tile_id`.
      show_vectors (bool, optional): if `True` show the translation
        vectors (not the minimal pair, but those used by
        `get_local_patch()`). Defaults to `False`.
      r (int, optional): passed to `get_local_patch()` to show context if
        greater than 0. Defaults to `0`.
      r_alpha (float, optional): alpha setting for units other than the
        central one. Defaults to 0.3.
      prototile_edgecolour (str, optional): outline colour for the tile.
        Defaults to `&#34;k&#34;`.
      reg_prototile_edgecolour (str, optional): outline colour for the
        regularised. Defaults to `&#34;r&#34;`.
      cmap (list[str], optional): colour map to apply to the central
        tiles. Defaults to `None`.
      figsize (tuple[float], optional): size of the figure.
        Defaults to `(8, 8)`.
    
    Returns:
      pyplot.axes: to which calling context may add things.
    &#34;&#34;&#34;
    w = self.prototile.geometry[0].bounds[2] - \
      self.prototile.geometry[0].bounds[0]
    n_cols = len(set(self.tiles.tile_id))
    if cmap is None:
      cm = &#34;Dark2&#34; if n_cols &lt;= 8 else &#34;Paired&#34;
    else:
      cm = cmap
    if ax is None:
      ax = self.tiles.plot(
        column=&#34;tile_id&#34;, cmap=cm, figsize=figsize, **kwargs)
    else:
      self.tiles.plot(
        ax=ax, column=&#34;tile_id&#34;, cmap=cm, figsize=figsize, **kwargs)
    if show_ids != None and show_ids != &#34;&#34;:
      do_label = True
      if show_ids == &#34;tile_id&#34; or show_ids == True:
        labels = self.tiles.tile_id
      elif show_ids == &#34;id&#34;:
        labels = [str(i) for i in range(self.tiles.shape[0])]
      else:
        do_label = False
      if do_label:
        for id, tile in zip(labels, self.tiles.geometry):
          ax.annotate(id, (tile.centroid.x, tile.centroid.y),
            ha = &#34;center&#34;, va = &#34;center&#34;, bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})
    if r &gt; 0:
      self.get_local_patch(r=r).plot(
        ax = ax, column = &#34;tile_id&#34;, alpha = r_alpha, cmap = cm, **kwargs)
    if show_prototile:
      self.prototile.plot(ax = ax, ec = prototile_edgecolour, lw = 0.5, 
                          fc = &#34;#00000000&#34;, **kwargs)
    if show_vectors:  # note that arrows in mpl are dimensioned in plotspace
      vecs = self.get_vectors()
      for v in vecs[: len(vecs) // 2]:
        ax.arrow(0, 0, v[0], v[1], color = &#34;k&#34;, width = w * 0.002,
          head_width = w * 0.05, length_includes_head = True, zorder = 3)
    if show_reg_prototile:
      self.regularised_prototile.plot(
        ax = ax, ec = reg_prototile_edgecolour, fc = &#34;#00000000&#34;, 
        lw = 1.5, zorder = 2, **kwargs)
    return ax


  def _get_legend_tiles(self):
    &#34;&#34;&#34;Returns the tiles augmented by a rotation column.

    This base implementation may be overridden by specific tile unit types.
    In particular see
    `weavingspace.weave_unit.WeaveUnit._get_legend_tiles()`.
    &#34;&#34;&#34;
    tiles = copy.deepcopy(self.tiles)
    tiles[&#34;rotation&#34;] = 0
    return tiles


  def transform_scale(self, xscale: float = 1.0, yscale: float = 1.0) -&gt; &#34;Tileable&#34;:
    &#34;&#34;&#34;Transforms tileable by scaling.

    Args:
      xscale (float, optional): x scale factor. Defaults to 1.0.
      yscale (float, optional): y scale factor. Defaults to 1.0.

    Returns:
      Tileable: the transformed Tileable.
    &#34;&#34;&#34;
    result = copy.deepcopy(self)
    result.tiles.geometry = tiling_utils.gridify(
      self.tiles.geometry.scale(xscale, yscale, origin=(0, 0)))
    result.prototile.geometry = tiling_utils.gridify(
      self.prototile.geometry.scale(xscale, yscale, origin=(0, 0)))
    result.regularised_prototile.geometry = tiling_utils.gridify(
      self.regularised_prototile.geometry.scale(xscale, yscale, origin=(0, 0)))
    result.setup_vectors()
    return result


  def transform_rotate(self, angle: float = 0.0) -&gt; &#34;Tileable&#34;:
    &#34;&#34;&#34;Transforms tiling by rotation.

    Args:
      angle (float, optional): angle to rotate by. Defaults to 0.0.

    Returns:
      Tileable: the transformed Tileable.
    &#34;&#34;&#34;
    result = copy.deepcopy(self)
    result.tiles.geometry = tiling_utils.gridify(
      self.tiles.geometry.rotate(angle, origin=(0, 0)))
    result.prototile.geometry = tiling_utils.gridify(
      self.prototile.geometry.rotate(angle, origin=(0, 0)))
    result.regularised_prototile.geometry = tiling_utils.gridify(
      self.regularised_prototile.geometry.rotate(angle, origin=(0, 0)))
    result.setup_vectors()
    result.rotation = result.rotation + angle
    return result


  def transform_skew(self, xa: float = 0.0, ya: float = 0.0) -&gt; &#34;Tileable&#34;:
    &#34;&#34;&#34;Transforms tiling by skewing

    Args:
      xa (float, optional): x direction skew. Defaults to 0.0.
      ya (float, optional): y direction skew. Defaults to 0.0.

    Returns:
      Tileable: the transformed Tileable.
    &#34;&#34;&#34;
    result = copy.deepcopy(self)
    result.tiles.geometry = tiling_utils.gridify(
      self.tiles.geometry.skew(xa, ya, origin=(0, 0)))
    result.prototile.geometry = tiling_utils.gridify(
      self.prototile.geometry.skew(xa, ya, origin=(0, 0)))
    result.regularised_prototile.geometry = tiling_utils.gridify(
      self.regularised_prototile.geometry.skew(xa, ya, origin=(0, 0)))
    result.setup_vectors()
    return result</code></pre>
</details>
<div class="desc"><p>Class to represent a tileable set of tile geometries.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></li>
<li><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tileable.Tileable.base_shape"><code class="name">var <span class="ident">base_shape</span> : <a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code></dt>
<dd>
<div class="desc"><p>the tile shape. Defaults to 'RECTANGLE'</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.crs"><code class="name">var <span class="ident">crs</span> : int</code></dt>
<dd>
<div class="desc"><p>coordinate reference system of the tile. Most often an ESPG code but
any valid geopandas CRS specification is valid. Defaults to 3857 (i.e. Web
Mercator).</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.debug"><code class="name">var <span class="ident">debug</span> : bool</code></dt>
<dd>
<div class="desc"><p>if True prints debug messages. Defaults to False.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.prototile"><code class="name">var <span class="ident">prototile</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the tileable polygon (rectangle, hexagon or diamond)</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.regularised_prototile"><code class="name">var <span class="ident">regularised_prototile</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>polygon containing the tiles of this tileable, usually a union of its
tile polygons</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.rotation"><code class="name">var <span class="ident">rotation</span> : float</code></dt>
<dd>
<div class="desc"><p>cumulative rotation of the tileable.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.spacing"><code class="name">var <span class="ident">spacing</span> : float</code></dt>
<dd>
<div class="desc"><p>the tile spacing effectively the resolution of the tiling. Defaults to
1000</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.tiles"><code class="name">var <span class="ident">tiles</span> : geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"><p>the geometries with associated <code>title_id</code> attribute encoding their
different colouring.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.vectors"><code class="name">var <span class="ident">vectors</span> : dict[tuple[int], tuple[float]]</code></dt>
<dd>
<div class="desc"><p>translation vector symmetries of the tiling</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.tileable.Tileable.fit_tiles_to_prototile"><code class="name flex">
<span>def <span class="ident">fit_tiles_to_prototile</span></span>(<span>self, centre_tile: int = 0) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_tiles_to_prototile(self, centre_tile: int = 0) -&gt; None:
  &#34;&#34;&#34;Fits the tiles so they sit inside the prototile boundary.

  If tiles project outside the boundaries of the prototile, this
  method will clip them so that they don&#39;t. This may result in
  &#39;fragmented&#39; tiles, i.e. pieces that would form a single tile
  after tiling which are separated into fragments.

  Args:
    centre_tile (int, optional): the index position of the central
      tile. Defaults to `0`.
  &#34;&#34;&#34;
  dxy = self.tiles.geometry[centre_tile].centroid
  self.tiles.geometry = self.tiles.translate(-dxy.x, -dxy.y)
  # use r = 2 because rectangular tiles may need diagonal neighbours
  patch = (
    self.get_local_patch(r=2, include_0=True)
    if self.base_shape in (TileShape.RECTANGLE,)
    else self.get_local_patch(r=1, include_0=True)
  )
  self.tiles = patch.clip(self.prototile)
  # repair any weirdness...
  self.tiles.geometry = tiling_utils.repair_polygon(self.tiles.geometry)
  self.tiles = self.tiles[self.tiles.geometry.area &gt; 0]
  self.regularised_prototile = copy.deepcopy(self.prototile)
  return None</code></pre>
</details>
<div class="desc"><p>Fits the tiles so they sit inside the prototile boundary.</p>
<p>If tiles project outside the boundaries of the prototile, this
method will clip them so that they don't. This may result in
'fragmented' tiles, i.e. pieces that would form a single tile
after tiling which are separated into fragments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>centre_tile</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the index position of the central
tile. Defaults to <code>0</code>.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.get_local_patch"><code class="name flex">
<span>def <span class="ident">get_local_patch</span></span>(<span>self, r: int = 1, include_0: bool = False) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_patch(self, r: int = 1,
                    include_0: bool = False) -&gt; gpd.GeoDataFrame:
  &#34;&#34;&#34;Returns a GeoDataFrame with translated copies of the Tileable.

  The geodataframe takes the same form as the `Tileable.tile` attribute.

  Args:
    r (int, optional): the number of &#39;layers&#39; out from the unit to
      which the translate copies will extendt. Defaults to `1`.
    include_0 (bool, optional): If True includes the Tileable itself at
      (0, 0). Defaults to `False`.

  Returns:
    gpd.GeoDataFrame: A GeoDataframe of the tiles extended by a number 
      of &#39;layers&#39;.
  &#34;&#34;&#34;
  # a dictionary of all the vectors we need, starting with (0, 0)
  vecs = (
    {(0, 0, 0): (0, 0)}
    if self.base_shape in (TileShape.HEXAGON,)
    else {(0, 0): (0, 0)}
  )
  steps = r if self.base_shape in (TileShape.HEXAGON,) else r * 2
  # a dictionary of the last &#39;layer&#39; of added vectors
  last_vecs = copy.deepcopy(vecs)
  # get the translation vectors in a dictionary indexed by coordinates
  # we keep track of the sum of vectors using the (integer) coordinates
  # to avoid duplication of moves due to floating point inaccuracies
  vectors = self.get_vectors(as_dict = True)
  for i in range(steps):
    new_vecs = {}
    for k1, v1 in last_vecs.items():
      for k2, v2 in vectors.items():
        # add the coordinates to make a new key...
        new_key = tuple([k1[i] + k2[i] for i in range(len(k1))])
        # ... and the vector components to make a new value
        new_val = (v1[0] + v2[0], v1[1] + v2[1])
        # if we haven&#39;t reached here before store it
        if not new_key in vecs:
          new_vecs[new_key] = new_val
    # extend the vectors and set the last layer to the set just added
    vecs = vecs | new_vecs
    last_vecs = new_vecs
  if not include_0:  # throw away the identity vector
    vecs.pop((0, 0, 0) if self.base_shape in (TileShape.HEXAGON,) else (0, 0))
  ids, tiles = [], []
  # we need to add the translated prototiles in order of their distance from # tile 0, esp. in the square case, i.e. something like this:
  #
  #      5 4 3 4 5
  #      4 2 1 2 4
  #      3 1 0 1 3
  #      4 2 1 2 4
  #      5 4 3 4 5
  #
  # this is important for topology detection, where filtering back to the
  # local patch of radius 1 is greatly eased if prototiles have been added in 
  # this order. We use the vector index tuples not the euclidean distances
  # because this may be more resistant to odd effects for non-convex tiles
  extent = self.prototile.geometry.scale(
    2 * r + tiling_utils.RESOLUTION, 2 * r + tiling_utils.RESOLUTION,
    origin = self.prototile.geometry[0].centroid)[0]
  vector_lengths = {index: np.sqrt(sum([_ ** 2 for _ in index]))
                    for index in vecs.keys()}
  ordered_vector_keys = [k for k, v in sorted(vector_lengths.items(), 
                                              key = lambda item: item[1])]
  for k in ordered_vector_keys:
    v = vecs[k]
    if geom.Point(v[0], v[1]).within(extent):
      ids.extend(self.tiles.tile_id)
      tiles.extend(
        self.tiles.geometry.apply(affine.translate, xoff = v[0], yoff = v[1]))
  return gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: ids}, crs=self.crs,
    geometry = tiling_utils.gridify(gpd.GeoSeries(tiles))
  )</code></pre>
</details>
<div class="desc"><p>Returns a GeoDataFrame with translated copies of the Tileable.</p>
<p>The geodataframe takes the same form as the <code>Tileable.tile</code> attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of 'layers' out from the unit to
which the translate copies will extendt. Defaults to <code>1</code>.</dd>
<dt><strong><code>include_0</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True includes the Tileable itself at
(0, 0). Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>A GeoDataframe of the tiles extended by a number
of 'layers'.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.get_vectors"><code class="name flex">
<span>def <span class="ident">get_vectors</span></span>(<span>self, as_dict: bool = False) ‑> dict[tuple[int], tuple[float]] | list[tuple[float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vectors(
    self, as_dict: bool = False
  ) -&gt; Union[dict[tuple[int], tuple[float]], list[tuple[float]]]:
  &#34;&#34;&#34;
  Returns symmetry translation vectors as floating point pairs.
  Optionally returns the vectors in a dictionary indexed by their
  coordinates, e.g.

    {( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
     (-1,  0): (-100, 0), ( 0, -1): (0, -100)}

  Returns:
    Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]:
      either the vectors as a list of float tuples, or a dictionary
      of those vectors indexed by integer coordinate tuples.
  &#34;&#34;&#34;
  if as_dict:
    return self.vectors
  else:
    return list(self.vectors.values())</code></pre>
</details>
<div class="desc"><p>Returns symmetry translation vectors as floating point pairs.
Optionally returns the vectors in a dictionary indexed by their
coordinates, e.g.</p>
<p>{( 1,
0): ( 100, 0), ( 0,
1): (0,
100),
(-1,
0): (-100, 0), ( 0, -1): (0, -100)}</p>
<h2 id="returns">Returns</h2>
<p>Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]:
either the vectors as a list of float tuples, or a dictionary
of those vectors indexed by integer coordinate tuples.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.inset_tiles"><code class="name flex">
<span>def <span class="ident">inset_tiles</span></span>(<span>self, inset: float = 0) ‑> <a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inset_tiles(self, inset: float = 0) -&gt; &#34;Tileable&#34;:
  &#34;&#34;&#34;Returns a new Tileable with an inset applied around the tiles.

  Works by applying a negative buffer of specfied size to all tiles.
  Tiles that collapse to zero area are removed and the tile_id
  attribute updated accordingly.

  NOTE: this method is likely to not preserve the relative area of tiles.

  Args:
    inset (float, optional): The distance to inset. Defaults to `0`.

  Returns:
    &#34;Tileable&#34;: the new inset Tileable.
  &#34;&#34;&#34;
  inset_tiles, inset_ids = [], []
  for p, id in zip(self.tiles.geometry, self.tiles.tile_id):
    b = p.buffer(-inset, join_style = 2, cap_style = 3)
    if not b.area &lt;= 0:
      inset_tiles.append(b)
      inset_ids.append(id)
  result = copy.deepcopy(self)
  result.tiles = gpd.GeoDataFrame(
    data={&#34;tile_id&#34;: inset_ids},
    crs=self.crs,
    geometry=gpd.GeoSeries(inset_tiles),
  )
  return result</code></pre>
</details>
<div class="desc"><p>Returns a new Tileable with an inset applied around the tiles.</p>
<p>Works by applying a negative buffer of specfied size to all tiles.
Tiles that collapse to zero area are removed and the tile_id
attribute updated accordingly.</p>
<p>NOTE: this method is likely to not preserve the relative area of tiles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The distance to inset. Defaults to <code>0</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>"Tileable": the new inset Tileable.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.merge_fragments"><code class="name flex">
<span>def <span class="ident">merge_fragments</span></span>(<span>self, fragments: list[shapely.geometry.polygon.Polygon]) ‑> list[shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_fragments(self, fragments:list[geom.Polygon]) -&gt; list[geom.Polygon]:
  &#34;&#34;&#34;
  Merges a set of polygons based on testing if they touch when subjected
  to the translation vectors provided by `get_vectors()`.

  Called by `regularise_tiles()` to combine tiles in a tile unit that
  may be fragmented as supplied but will combine after tiling into single
  tiles. This step makes for more efficient implementation of the
  tiling of map regions.

  Args:
    fragments (list[geom.Polygon]): A set of polygons to merge.

  Returns:
    list[geom.Polygon]: A minimal list of merged polygons.
  &#34;&#34;&#34;
  if len(fragments) == 1:
    return [f for f in fragments if not f.is_empty]
  fragments = [f for f in fragments if not f.is_empty]
  prototile = self.prototile.geometry[0]
  reg_prototile = copy.deepcopy(self.regularised_prototile.geometry[0])
  changes_made = True
  while changes_made:
    changes_made = False
    for v in self.vectors.values():
      # empty list to collect the new fragments
      # assembled in this iteration
      next_frags = []
      t_frags = [affine.translate(f, v[0], v[1]) for f in fragments]
      # build a set of any near matching pairs of
      # fragments and their translated copies
      matches = set()
      for i, f1 in enumerate(fragments):
        for j, f2, in enumerate(t_frags):
          if i &lt; j and tiling_utils.touch_along_an_edge(f1, f2):
            matches.add((i, j))
      # determine which of these when unioned has the larger area in common # with the prototile
      frags_to_remove = set()
      for i, j in matches:
        f1, f2 = fragments[i], t_frags[j]
        u1 = f1.buffer(tiling_utils.RESOLUTION, join_style = 2, cap_style = 3).union(
          f2.buffer(tiling_utils.RESOLUTION, join_style = 2, cap_style = 3))
        u2 = affine.translate(u1, -v[0], -v[1])
        if prototile.intersection(u1).area &gt; prototile.intersection(u2).area:
          u1 = u1.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
          u2 = u2.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
          next_frags.append(u1)
          reg_prototile = reg_prototile.union(u1).difference(u2)
        else:
          u1 = u1.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
          u2 = u2.buffer(-tiling_utils.RESOLUTION, join_style = 2, cap_style = 3)
          next_frags.append(u2)
          reg_prototile = reg_prototile.union(u2).difference(u1)
        changes_made = True
        frags_to_remove.add(i)
        frags_to_remove.add(j)
      fragments = [f for i, f in enumerate(fragments)
                   if not (i in frags_to_remove)] + next_frags
  self.regularised_prototile.loc[0, &#34;geometry&#34;] = reg_prototile
  # self.regularised_prototile.geometry[0] = reg_prototile
  return [f for f in fragments if not f.is_empty] # don&#39;t return any duds</code></pre>
</details>
<div class="desc"><p>Merges a set of polygons based on testing if they touch when subjected
to the translation vectors provided by <code>get_vectors()</code>.</p>
<p>Called by <code>regularise_tiles()</code> to combine tiles in a tile unit that
may be fragmented as supplied but will combine after tiling into single
tiles. This step makes for more efficient implementation of the
tiling of map regions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fragments</code></strong> :&ensp;<code>list[geom.Polygon]</code></dt>
<dd>A set of polygons to merge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.Polygon]</code></dt>
<dd>A minimal list of merged polygons.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self,<br>ax=None,<br>show_prototile: bool = True,<br>show_reg_prototile: bool = True,<br>show_ids: str = 'tile_id',<br>show_vectors: bool = False,<br>r: int = 0,<br>prototile_edgecolour: str = 'k',<br>reg_prototile_edgecolour: str = 'r',<br>r_alpha: float = 0.3,<br>cmap: list[str] = None,<br>figsize: tuple[float] = (8, 8),<br>**kwargs) ‑> <function axes at 0x11e8caca0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, ax = None, show_prototile: bool = True, 
  show_reg_prototile: bool = True, show_ids: str = &#34;tile_id&#34;,
  show_vectors: bool = False, r: int = 0, prototile_edgecolour: str = &#34;k&#34;, 
  reg_prototile_edgecolour: str = &#34;r&#34;, r_alpha: float = 0.3, 
  cmap: list[str] = None, figsize: tuple[float] = (8, 8), **kwargs) -&gt; pyplot.axes:
  &#34;&#34;&#34;Plots a representation of the Tileable on the supplied axis. **kwargs
  are passed on to matplotlib.plot()

  Args:
    ax (_type_, optional): matplotlib axis to draw to. Defaults to None.
    show_prototile (bool, optional): if `True` show the tile outline.
      Defaults to `True`.
    show_reg_prototile (bool, optional): if `True` show the regularised tile
      outline. Defaults to `True`.
    show_ids (str, optional): if `tile_id` show the tile_ids. If
      `id` show index number. If None or `&#39;&#39;` don&#39;t label tiles.
      Defaults to `tile_id`.
    show_vectors (bool, optional): if `True` show the translation
      vectors (not the minimal pair, but those used by
      `get_local_patch()`). Defaults to `False`.
    r (int, optional): passed to `get_local_patch()` to show context if
      greater than 0. Defaults to `0`.
    r_alpha (float, optional): alpha setting for units other than the
      central one. Defaults to 0.3.
    prototile_edgecolour (str, optional): outline colour for the tile.
      Defaults to `&#34;k&#34;`.
    reg_prototile_edgecolour (str, optional): outline colour for the
      regularised. Defaults to `&#34;r&#34;`.
    cmap (list[str], optional): colour map to apply to the central
      tiles. Defaults to `None`.
    figsize (tuple[float], optional): size of the figure.
      Defaults to `(8, 8)`.
  
  Returns:
    pyplot.axes: to which calling context may add things.
  &#34;&#34;&#34;
  w = self.prototile.geometry[0].bounds[2] - \
    self.prototile.geometry[0].bounds[0]
  n_cols = len(set(self.tiles.tile_id))
  if cmap is None:
    cm = &#34;Dark2&#34; if n_cols &lt;= 8 else &#34;Paired&#34;
  else:
    cm = cmap
  if ax is None:
    ax = self.tiles.plot(
      column=&#34;tile_id&#34;, cmap=cm, figsize=figsize, **kwargs)
  else:
    self.tiles.plot(
      ax=ax, column=&#34;tile_id&#34;, cmap=cm, figsize=figsize, **kwargs)
  if show_ids != None and show_ids != &#34;&#34;:
    do_label = True
    if show_ids == &#34;tile_id&#34; or show_ids == True:
      labels = self.tiles.tile_id
    elif show_ids == &#34;id&#34;:
      labels = [str(i) for i in range(self.tiles.shape[0])]
    else:
      do_label = False
    if do_label:
      for id, tile in zip(labels, self.tiles.geometry):
        ax.annotate(id, (tile.centroid.x, tile.centroid.y),
          ha = &#34;center&#34;, va = &#34;center&#34;, bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})
  if r &gt; 0:
    self.get_local_patch(r=r).plot(
      ax = ax, column = &#34;tile_id&#34;, alpha = r_alpha, cmap = cm, **kwargs)
  if show_prototile:
    self.prototile.plot(ax = ax, ec = prototile_edgecolour, lw = 0.5, 
                        fc = &#34;#00000000&#34;, **kwargs)
  if show_vectors:  # note that arrows in mpl are dimensioned in plotspace
    vecs = self.get_vectors()
    for v in vecs[: len(vecs) // 2]:
      ax.arrow(0, 0, v[0], v[1], color = &#34;k&#34;, width = w * 0.002,
        head_width = w * 0.05, length_includes_head = True, zorder = 3)
  if show_reg_prototile:
    self.regularised_prototile.plot(
      ax = ax, ec = reg_prototile_edgecolour, fc = &#34;#00000000&#34;, 
      lw = 1.5, zorder = 2, **kwargs)
  return ax</code></pre>
</details>
<div class="desc"><p>Plots a representation of the Tileable on the supplied axis. **kwargs
are passed on to matplotlib.plot()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>matplotlib axis to draw to. Defaults to None.</dd>
<dt><strong><code>show_prototile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the tile outline.
Defaults to <code>True</code>.</dd>
<dt><strong><code>show_reg_prototile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the regularised tile
outline. Defaults to <code>True</code>.</dd>
<dt><strong><code>show_ids</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>if <code>tile_id</code> show the tile_ids. If
<code>id</code> show index number. If None or <code>''</code> don't label tiles.
Defaults to <code>tile_id</code>.</dd>
<dt><strong><code>show_vectors</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the translation
vectors (not the minimal pair, but those used by
<code>get_local_patch()</code>). Defaults to <code>False</code>.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>passed to <code>get_local_patch()</code> to show context if
greater than 0. Defaults to <code>0</code>.</dd>
<dt><strong><code>r_alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>alpha setting for units other than the
central one. Defaults to 0.3.</dd>
<dt><strong><code>prototile_edgecolour</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>outline colour for the tile.
Defaults to <code>"k"</code>.</dd>
<dt><strong><code>reg_prototile_edgecolour</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>outline colour for the
regularised. Defaults to <code>"r"</code>.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>list[str]</code>, optional</dt>
<dd>colour map to apply to the central
tiles. Defaults to <code>None</code>.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>size of the figure.
Defaults to <code>(8, 8)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pyplot.axes</code></dt>
<dd>to which calling context may add things.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.reattach_tiles"><code class="name flex">
<span>def <span class="ident">reattach_tiles</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reattach_tiles(self) -&gt; None:
  &#34;&#34;&#34;Move tiles that are outside the regularised prototile main polygon
  back inside it adjusting regularised prototile if needed.
  &#34;&#34;&#34;
  reg_prototile = self.regularised_prototile.geometry[0]
  new_reg_prototile = copy.deepcopy(reg_prototile)
  new_tiles = list(self.tiles.geometry)
  for i, p in enumerate(self.tiles.geometry):
    if np.isclose(reg_prototile.intersection(p).area, p.area):
      new_tiles[i] = p
      continue
    for v in self.vectors.values():
      t_p = affine.translate(p, v[0], v[1])
      if reg_prototile.intersects(t_p):
        new_reg_prototile = new_reg_prototile.union(t_p)
        new_tiles[i] = t_p
  self.tiles.geometry = gpd.GeoSeries(new_tiles)
  self.regularised_prototile.loc[0, &#34;geometry&#34;] = new_reg_prototile
  # self.regularised_prototile.geometry[0] = new_reg_prototile
  return None</code></pre>
</details>
<div class="desc"><p>Move tiles that are outside the regularised prototile main polygon
back inside it adjusting regularised prototile if needed.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.regularise_tiles"><code class="name flex">
<span>def <span class="ident">regularise_tiles</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regularise_tiles(self) -&gt; None:
  &#34;&#34;&#34;Combines separate tiles that share a tile_id value into
  single tiles, if they would end up touching after tiling.

  Also adjusts the `Tileable.regularised_prototile`
  attribute accordingly.
  &#34;&#34;&#34;
  self.regularised_prototile = copy.deepcopy(self.prototile)
  # This preserves order while finding uniques, unlike list(set()).
  # Reordering ids might cause confusion when colour palettes
  # are not assigned explicitly to each id, but in the order
  # encountered in the tile_id Series of the GeoDataFrame.
  tiles, tile_ids = [], []
  ids = list(self.tiles.tile_id.unique())
  for id in ids:
    fragment_set = list(
      self.tiles[self.tiles.tile_id == id].geometry)
    merge_result = self.merge_fragments(fragment_set)
    tiles.extend(merge_result)
    tile_ids.extend([id] * len(merge_result))

  self.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: tile_ids},
    crs = self.crs,
    geometry = gpd.GeoSeries([tiling_utils.get_clean_polygon(t) 
                              for t in tiles]))

  self.regularised_prototile = \
    self.regularised_prototile.explode(ignore_index = True)
  if self.regularised_prototile.shape[0] &gt; 1:
    self.regularised_prototile.geometry = tiling_utils.get_largest_polygon(
      self.regularised_prototile.geometry)
  return None</code></pre>
</details>
<div class="desc"><p>Combines separate tiles that share a tile_id value into
single tiles, if they would end up touching after tiling.</p>
<p>Also adjusts the <code><a title="weavingspace.tileable.Tileable.regularised_prototile" href="#weavingspace.tileable.Tileable.regularised_prototile">Tileable.regularised_prototile</a></code>
attribute accordingly.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles"><code class="name flex">
<span>def <span class="ident">setup_regularised_prototile_from_tiles</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_regularised_prototile_from_tiles(self) -&gt; None:
  &#34;&#34;&#34;Sets the regularised tile to a union of the tiles.&#34;&#34;&#34;
  self.regularised_prototile = copy.deepcopy(self.prototile)
  self.regularised_prototile.geometry = [tiling_utils.safe_union(
    self.tiles.geometry, as_polygon = True)]
  # This simplification seems very crude but fixes all kinds of issues...
  # particularly with the triaxial weave units... where intersection 
  # operations are prone to creating spurious vertices, etc.
  self.regularised_prototile.loc[0, &#39;geometry&#39;] = \
    self.regularised_prototile.loc[0, &#39;geometry&#39;].simplify(
      self.spacing * tiling_utils.RESOLUTION)
  # self.regularised_prototile.geometry[0] = \
  #   self.regularised_prototile.geometry[0].simplify(
  #     self.spacing * tiling_utils.RESOLUTION)
  return</code></pre>
</details>
<div class="desc"><p>Sets the regularised tile to a union of the tiles.</p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.setup_vectors"><code class="name flex">
<span>def <span class="ident">setup_vectors</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_vectors(self) -&gt; None:
  &#34;&#34;&#34;Sets up the symmetry translation vectors as floating point pairs
  indexed by integer tuples with respect to either a rectangular or
  triangular grid location.

  Derived from the size and shape of the tile attribute. These are not
  the minimal translation vectors, but the &#39;face to face&#39; vectors of the
  tile, such that a hexagonal tile will have 3 vectors, not the minimal
  parallelogram pair. Also supplies the inverse vectors.

  The vectors are stored in a dictionary indexed by their
  coordinates, e.g.

    {( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
     (-1,  0): (-100, 0), ( 0, -1): (0, -100)}

  For a tileable of type `TileShape.HEXAGON`, the indexing tuples
  have three components. See https://www.redblobgames.com/grids/hexagons/
  &#34;&#34;&#34;
  t = self.prototile.geometry[0]
  pts = [p for p in t.exterior.coords][:-1]
  n_pts = len(pts)
  vec_dict = {}
  if n_pts == 4:
    vecs = [(q[0] - p[0], q[1] - p[1])
        for p, q in zip(pts, pts[1:] + pts[:1])]
    i = [1, 0, -1,  0]
    j = [0, 1,  0, -1]
    vec_dict = {(i, j): v for i, j, v in zip(i, j, vecs)}
  elif n_pts == 6:
    vecs = [(q[0] - p[0], q[1] - p[1])
        for p, q in zip(pts, pts[2:] + pts[:2])]
    # hex grid coordinates associated with each of the vectors
    i = [ 0,  1,  1,  0, -1, -1]
    j = [ 1,  0, -1, -1,  0,  1]
    k = [-1, -1,  0,  1,  1,  0]
    vec_dict = {(i, j, k): v for i, j, k, v in zip(i, j, k, vecs)}
  self.vectors = vec_dict</code></pre>
</details>
<div class="desc"><p>Sets up the symmetry translation vectors as floating point pairs
indexed by integer tuples with respect to either a rectangular or
triangular grid location.</p>
<p>Derived from the size and shape of the tile attribute. These are not
the minimal translation vectors, but the 'face to face' vectors of the
tile, such that a hexagonal tile will have 3 vectors, not the minimal
parallelogram pair. Also supplies the inverse vectors.</p>
<p>The vectors are stored in a dictionary indexed by their
coordinates, e.g.</p>
<p>{( 1,
0): ( 100, 0), ( 0,
1): (0,
100),
(-1,
0): (-100, 0), ( 0, -1): (0, -100)}</p>
<p>For a tileable of type <code><a title="weavingspace.tileable.TileShape.HEXAGON" href="#weavingspace.tileable.TileShape.HEXAGON">TileShape.HEXAGON</a></code>, the indexing tuples
have three components. See <a href="https://www.redblobgames.com/grids/hexagons/">https://www.redblobgames.com/grids/hexagons/</a></p></div>
</dd>
<dt id="weavingspace.tileable.Tileable.transform_rotate"><code class="name flex">
<span>def <span class="ident">transform_rotate</span></span>(<span>self, angle: float = 0.0) ‑> <a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_rotate(self, angle: float = 0.0) -&gt; &#34;Tileable&#34;:
  &#34;&#34;&#34;Transforms tiling by rotation.

  Args:
    angle (float, optional): angle to rotate by. Defaults to 0.0.

  Returns:
    Tileable: the transformed Tileable.
  &#34;&#34;&#34;
  result = copy.deepcopy(self)
  result.tiles.geometry = tiling_utils.gridify(
    self.tiles.geometry.rotate(angle, origin=(0, 0)))
  result.prototile.geometry = tiling_utils.gridify(
    self.prototile.geometry.rotate(angle, origin=(0, 0)))
  result.regularised_prototile.geometry = tiling_utils.gridify(
    self.regularised_prototile.geometry.rotate(angle, origin=(0, 0)))
  result.setup_vectors()
  result.rotation = result.rotation + angle
  return result</code></pre>
</details>
<div class="desc"><p>Transforms tiling by rotation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>angle to rotate by. Defaults to 0.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code></dt>
<dd>the transformed Tileable.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.transform_scale"><code class="name flex">
<span>def <span class="ident">transform_scale</span></span>(<span>self, xscale: float = 1.0, yscale: float = 1.0) ‑> <a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_scale(self, xscale: float = 1.0, yscale: float = 1.0) -&gt; &#34;Tileable&#34;:
  &#34;&#34;&#34;Transforms tileable by scaling.

  Args:
    xscale (float, optional): x scale factor. Defaults to 1.0.
    yscale (float, optional): y scale factor. Defaults to 1.0.

  Returns:
    Tileable: the transformed Tileable.
  &#34;&#34;&#34;
  result = copy.deepcopy(self)
  result.tiles.geometry = tiling_utils.gridify(
    self.tiles.geometry.scale(xscale, yscale, origin=(0, 0)))
  result.prototile.geometry = tiling_utils.gridify(
    self.prototile.geometry.scale(xscale, yscale, origin=(0, 0)))
  result.regularised_prototile.geometry = tiling_utils.gridify(
    self.regularised_prototile.geometry.scale(xscale, yscale, origin=(0, 0)))
  result.setup_vectors()
  return result</code></pre>
</details>
<div class="desc"><p>Transforms tileable by scaling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xscale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>x scale factor. Defaults to 1.0.</dd>
<dt><strong><code>yscale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>y scale factor. Defaults to 1.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code></dt>
<dd>the transformed Tileable.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tileable.Tileable.transform_skew"><code class="name flex">
<span>def <span class="ident">transform_skew</span></span>(<span>self, xa: float = 0.0, ya: float = 0.0) ‑> <a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_skew(self, xa: float = 0.0, ya: float = 0.0) -&gt; &#34;Tileable&#34;:
  &#34;&#34;&#34;Transforms tiling by skewing

  Args:
    xa (float, optional): x direction skew. Defaults to 0.0.
    ya (float, optional): y direction skew. Defaults to 0.0.

  Returns:
    Tileable: the transformed Tileable.
  &#34;&#34;&#34;
  result = copy.deepcopy(self)
  result.tiles.geometry = tiling_utils.gridify(
    self.tiles.geometry.skew(xa, ya, origin=(0, 0)))
  result.prototile.geometry = tiling_utils.gridify(
    self.prototile.geometry.skew(xa, ya, origin=(0, 0)))
  result.regularised_prototile.geometry = tiling_utils.gridify(
    self.regularised_prototile.geometry.skew(xa, ya, origin=(0, 0)))
  result.setup_vectors()
  return result</code></pre>
</details>
<div class="desc"><p>Transforms tiling by skewing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xa</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>x direction skew. Defaults to 0.0.</dd>
<dt><strong><code>ya</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>y direction skew. Defaults to 0.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code></dt>
<dd>the transformed Tileable.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tileable.TileShape.DIAMOND" href="#weavingspace.tileable.TileShape.DIAMOND">DIAMOND</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.HEXAGON" href="#weavingspace.tileable.TileShape.HEXAGON">HEXAGON</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.RECTANGLE" href="#weavingspace.tileable.TileShape.RECTANGLE">RECTANGLE</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.TRIANGLE" href="#weavingspace.tileable.TileShape.TRIANGLE">TRIANGLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tileable.Tileable.base_shape" href="#weavingspace.tileable.Tileable.base_shape">base_shape</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.crs" href="#weavingspace.tileable.Tileable.crs">crs</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.debug" href="#weavingspace.tileable.Tileable.debug">debug</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.fit_tiles_to_prototile" href="#weavingspace.tileable.Tileable.fit_tiles_to_prototile">fit_tiles_to_prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_local_patch" href="#weavingspace.tileable.Tileable.get_local_patch">get_local_patch</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_vectors" href="#weavingspace.tileable.Tileable.get_vectors">get_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.inset_tiles" href="#weavingspace.tileable.Tileable.inset_tiles">inset_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.merge_fragments" href="#weavingspace.tileable.Tileable.merge_fragments">merge_fragments</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.plot" href="#weavingspace.tileable.Tileable.plot">plot</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.prototile" href="#weavingspace.tileable.Tileable.prototile">prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.reattach_tiles" href="#weavingspace.tileable.Tileable.reattach_tiles">reattach_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularise_tiles" href="#weavingspace.tileable.Tileable.regularise_tiles">regularise_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularised_prototile" href="#weavingspace.tileable.Tileable.regularised_prototile">regularised_prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.rotation" href="#weavingspace.tileable.Tileable.rotation">rotation</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles" href="#weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles">setup_regularised_prototile_from_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_vectors" href="#weavingspace.tileable.Tileable.setup_vectors">setup_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.spacing" href="#weavingspace.tileable.Tileable.spacing">spacing</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.tiles" href="#weavingspace.tileable.Tileable.tiles">tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_rotate" href="#weavingspace.tileable.Tileable.transform_rotate">transform_rotate</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_scale" href="#weavingspace.tileable.Tileable.transform_scale">transform_scale</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_skew" href="#weavingspace.tileable.Tileable.transform_skew">transform_skew</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.vectors" href="#weavingspace.tileable.Tileable.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
