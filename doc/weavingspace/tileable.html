<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weavingspace.tileable API documentation</title>
<meta name="description" content="Implements `weavingspace.tileable.TileShape` and
`weavingspace.tileable.Tileable` the base classes for
`weavingspace.tile_unit.TileUnit` and â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tileable</code></h1>
</header>
<section id="section-intro">
<p>Implements <code><a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code> and
<code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> the base classes for
<code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> and <code><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code>.</p>
<p>These should not normally be accessed directly although several methods of
<code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> are generally useful and can be accessed
through its subclasses.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

&#34;&#34;&#34;Implements `weavingspace.tileable.TileShape` and 
`weavingspace.tileable.Tileable` the base classes for 
`weavingspace.tile_unit.TileUnit` and `weavingspace.weave_unit.WeaveUnit`.

These should not normally be accessed directly although several methods of
`weavingspace.tileable.Tileable` are generally useful and can be accessed 
through its subclasses.
&#34;&#34;&#34;

from enum import Enum
from typing import Union
from dataclasses import dataclass
import copy

import geopandas as gpd
import numpy as np
import shapely.geometry as geom
import shapely.affinity as affine

import weavingspace.tiling_utils as tiling_utils


class TileShape(Enum):
    &#34;&#34;&#34;The available base tile shapes.
    
    NOTE: the TRIANGLE type does not persist, but should be converted to a
    DIAMOND or HEXAGON type during `Tileable` construction.
    &#34;&#34;&#34;
    RECTANGLE = &#34;rectangle&#34;
    HEXAGON = &#34;hexagon&#34;
    TRIANGLE = &#34;triangle&#34;
    DIAMOND = &#34;diamond&#34;


@dataclass
class Tileable:
    &#34;&#34;&#34;Class to represent a tileable set of geometries.
    &#34;&#34;&#34;
    elements:gpd.GeoDataFrame = None
    tile:gpd.GeoDataFrame = None
    spacing:float = 1000.
    tile_shape:TileShape = TileShape.RECTANGLE
    vectors:list[tuple[float]] = None
    regularised_tile:gpd.GeoDataFrame = None
    crs:int = 3857
    fudge_factor:float = 1e-3
    
    def __init__(self, **kwargs):
        &#34;&#34;&#34;Stores any supplied attributes, sets up the tile, its elements, 
        vectors and regularised tile.
        
        The `Tileable` constructor should not be called directly, but is 
        instead accessed from the `weavingspace.tile_unit.TileUnit` or 
        `weavingspace.weave_unit.WeaveUnit` constructor. These can accept as
        arguments any of the arguments below.
        
        Args:
            elements (gpd.GeoDataFrame): the strand geometries with associated
                element_id attribute encoding their different colouring.
            tile (gpd.GeoDataFrame): the tileable polygon (a rectangle, a
                hexagon, or a diamond).
            spacing (float): the tile spacing -- effectively the &#39;resolution&#39; of
                the tiling. Defaults to `1000`.
            tile_shape (TileShape): the tile shape. Defaults to 
                `TileShape.RECTANGLE`.
            vectors (list[tuple[float]]): translation vector symmetries of the 
                tiling.
            regularised_tile (gpd.GeoDataFrame): a polygon containing the 
                elements of this `weavingspace.tileable.Tileable` --- most 
                often a union of those polygons.
            crs (int): the coordinate reference system of the tile. Most often 
                an EPSG code, but any valid geopandas CRS specification is
                valid. Defaults to 3857 (i.e. Web Mercator).
            fudge_factor (float): a distance in units of self.crs to be used in
                geometry clean ups (for example this buffer distance is applied
                before unioning polygons.) Defaults to `1e-3`.
        &#34;&#34;&#34;
        for k, v in kwargs.items():
            self.__dict__[k] = v
        self.setup_tile_and_elements()
        self.setup_vectors()
        if self.regularised_tile is None:
            self.regularise_elements()
        return
        
        
    def setup_vectors(self) -&gt; None:
        &#34;&#34;&#34;Sets up the translation vectors of the tiling.
        &#34;&#34;&#34;
        self.vectors = self.get_vectors()
        return None
    
        
    def get_vectors(self, return_values:bool = True
        ) -&gt; Union[ dict[tuple[int], tuple[float]],list[tuple[float]] ]:
        &#34;&#34;&#34;
        Returns symmetry translation vectors as floating point pairs. 
        
        Derived from the size and shape of the tile attribute. These are not the minimal translation vectors, but the &#39;face to face&#39; vectors of the tile, such that a hexagonal tile will have 3 vectors, not the minimal parallelogram pair. Also supplies the inverse vectors.
        
        Optionally returns the vectors in a dictionary indexed by their 
        coordinates, e.g.
        
            {
                ( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
                (-1,  0): (-100, 0), ( 0, -1): (0, -100)
            }
            
        For a tileable of type `TileShape.HEXAGON`, the indexing tuples 
        have three components. See https://www.redblobgames.com/grids/hexagons/ 
        
        Args:
            return_values (bool): If `True` returns the vectors only. If
                `False` returns a dictionary of the vectors indexed by tuples
                in the grid coordinate system. Defaults to `True`.
        
        Returns:
            Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]: 
                either the vectors as a list of float tuples, or a dictionary 
                of those vectors indexed by integer coordinate tuples. 
        &#34;&#34;&#34;
        bb = self.tile.geometry[0].bounds
        w, h = bb[2] - bb[0], bb[3] - bb[1]
        vec_dict = {}
        if self.tile_shape in (TileShape.RECTANGLE, ):
            vec_dict[(1, 0)] = (w, 0)
            vec_dict[(0, 1)] = (0, h)
            vec_dict[(-1, 0)] = (-w, 0)
            vec_dict[(0, -1)] = (0, -h)
        elif self.tile_shape in (TileShape.HEXAGON, ):
            # hex grid coordinates associated with each of the vectors
            i = [0, 1, 1, 0, -1, -1]
            j = [1, 0, -1, -1, 0, 1]
            k = [-1, -1, 0, 1, 1, 0]
            angles = [np.pi * 2 * i / 12 for i in range(1, 12, 2)]
            vecs = [(h * np.cos(a), h * np.sin(a)) for a in angles]
            vec_dict = {(i, j, k): v for i, j, k, v in zip(i, j, k, vecs)}
        else: # DIAMOND
            vec_dict[(1, 0)] = (w / 2, h / 2)
            vec_dict[(0, 1)] = (-w / 2, h / 2)
            vec_dict[(-1, 0)] = (-w / 2, -h / 2)
            vec_dict[(0, -1)] = (w / 2, -h / 2)
        return (list(vec_dict.values())
                if return_values
                else vec_dict)
        
        
    # Make up a regularised tile by carefully unioning the elements
    def setup_regularised_tile_from_elements(self) -&gt; None:
        &#34;&#34;&#34;Sets the regularised tile to a union of the elements.
        &#34;&#34;&#34;
        self.regularised_tile = copy.deepcopy(self.tile)
        self.regularised_tile.geometry = tiling_utils.safe_union(
            self.elements.geometry)
        # This simplification seems very crude but fixes all kinds of issues...
        self.regularised_tile.geometry[0] = \
            self.regularised_tile.geometry[0].simplify(self.spacing / 100)
        return
        
    
    def merge_fragments(
                self, fragments:list[geom.Polygon]) -&gt; list[geom.Polygon]:
        &#34;&#34;&#34;
        Merges a set of polygons based on testing if they touch when subjected 
        to the translation vectors provided by `get_vectors()`. 
        
        Called by `regularise_elements()` to combine elements in a tile that 
        may be fragmented as supplied but will combine when tiled into single 
        elements. This step makes for more efficient implementation of the 
        tiling of map regions.

        Args:
            fragments (list[geom.Polygon]): A set of polygons to merge.

        Returns:
            list[geom.Polygon]: A minimal list of merged polygons.
        &#34;&#34;&#34;
        tile = self.tile.geometry[0]
        reg_tile = self.regularised_tile.geometry[0].buffer(
            self.fudge_factor, resolution = 1, join_style = 2)
        if len(fragments) == 1:
            return fragments
        changes_made = True
        while changes_made:
            changes_made = False
            for v in self.vectors:
                next_frags = []
                t_fragments = [affine.translate(f, v[0], v[1]) 
                               for f in fragments]
                # build a set of any near matching pairs of 
                # fragments and their translated copies
                matches = set()
                for i, f1 in enumerate(fragments):
                    for j, f2, in enumerate(t_fragments):
                        if i != j and tiling_utils.touch_along_an_edge(f1, f2):
                            matches.add((i, j))
                # determine which of these when unioned has the 
                # larger area in common with the base tile
                fragments_to_remove = set()
                for i, j in matches:
                    f1 = fragments[i]
                    f2 = t_fragments[j]
                    u1 = (f1.buffer(self.fudge_factor, 
                                    resolution = 1, join_style = 2) | 
                          f2.buffer(self.fudge_factor, 
                                    resolution = 1, join_style = 2))
                    u2 = affine.translate(u1, -v[0], -v[1])
                    if tile.intersection(u1).area &gt; tile.intersection(u2).area:
                        next_frags.append(u1)
                        reg_tile = (reg_tile | u1) - u2
                    else:
                        next_frags.append(u2)
                        reg_tile = (reg_tile | u2) - u1
                    changes_made = True
                    fragments_to_remove.add(i)
                    fragments_to_remove.add(j)
                fragments = [f for i, f in enumerate(fragments) 
                            if not (i in fragments_to_remove)]
                fragments = next_frags + fragments
        self.regularised_tile.geometry[0] = \
            reg_tile.buffer(-self.fudge_factor, resolution = 1, join_style = 2)
        return fragments


    def regularise_elements(self) -&gt; None:
        &#34;&#34;&#34;Combines separate elements that share an element_id value into 
        single elements, if they would end up touching when tiled. 
        
        Also adjusts the `weavingspace.tileable.Tileable.regularised_tile` 
        attribute accordingly.
        &#34;&#34;&#34;
        self.regularised_tile = copy.deepcopy(self.tile)
        self.regularised_tile.geometry = \
            self.regularised_tile.geometry.buffer(
                self.fudge_factor, resolution = 1, join_style = 2)
        # This preserves order while finding uniques, unlike list(set()).
        # Reordering ids might cause confusion when colour palettes
        # are not assigned explicitly to each id, but in the order
        # encountered in the element_id Series of the GeoDataFrame.
        elements, element_ids = [], []
        ids = list(self.elements.element_id.unique())
        for id in ids:
            fragment_set = list(
                self.elements[self.elements.element_id == id].geometry)
            merge_result = self.merge_fragments(fragment_set)
            elements.extend(merge_result)
            element_ids.extend([id] * len(merge_result))

        self.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: element_ids}, crs = self.crs,
            geometry = gpd.GeoSeries(elements))

        self.regularised_tile.geometry = \
            self.regularised_tile.geometry.explode(index_parts = False,
                                                   ignore_index = True)
        if self.regularised_tile.geometry.shape[0] &gt; 1:
            self.regularised_tile.geometry = \
                tiling_utils.get_largest_polygon(self.regularised_tile.geometry)
        # This simplification seems very crude but fixes all kinds of issues...
        self.regularised_tile.geometry[0] = \
            self.regularised_tile.geometry[0].simplify(self.spacing / 100)
        return None
    
    
    def get_local_patch(
            self, r:int = 1, include_0:bool = False) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;Returns a GeoDataFrame with translated copies of the Tileable.
        
        The geodataframe takes the same form as the `Tileable.tile` attribute.

        Args:
            r (int, optional): the number of translation vector steps required. 
                Defaults to `1`.
            include_0 (bool, optional): If True includes the Tileable itself at 
                (0, 0). Defaults to `False`.

        Returns:
            gpd.GeoDataFrame: A GeoDataframe of the elements extended
                by a number of translation vectors.
        &#34;&#34;&#34;
        # a dictionary of all the vectors we need, starting with (0, 0)
        vecs = ({(0, 0, 0): (0, 0)} 
                if self.tile_shape in (TileShape.HEXAGON, )
                else {(0, 0): (0, 0)})
        # a dictionary of the last &#39;layer&#39; of added vectors
        last_vecs = copy.deepcopy(vecs)
        # get the translation vectors in a dictionary indexed by coordinates
        # we keep track of the sum of vectors using the (integer) coordinates
        # to avoid duplication of moves due to floating point inaccuracies 
        vectors = self.get_vectors(return_values = False)
        for i in range(r):
            new_vecs = {}
            for k1, v1 in last_vecs.items():
                for k2, v2 in vectors.items():
                    # add the coordinates to make a new key...
                    new_key = tuple([k1[i] + k2[i] for i in range(len(k1))])
                    # ... and the vector components to make a new value
                    new_val = (v1[0] + v2[0], v1[1] + v2[1])
                    # if we haven&#39;t reached here before store it
                    if not new_val in vecs: 
                        new_vecs[new_key] = new_val
            # extend the vectors and set the last layer to the set just added
            vecs = vecs | new_vecs
            last_vecs = new_vecs
        if not include_0:  # throw away the identity vector
            vecs.pop((0, 0, 0) if self.tile_shape in (TileShape.HEXAGON, )
                     else (0, 0))
        ids, tiles = [], []
        for v in vecs.values():
            ids.extend(self.elements.element_id)
            tiles.extend(self.elements.geometry.apply(
                affine.translate, xoff = v[0], yoff = v[1]))
        return gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: ids}, crs = self.crs,
            geometry = gpd.GeoSeries(tiles)
        )
    
    
    def fit_elements_to_tile(self, centre_element:int = 0) -&gt; None:
        &#34;&#34;&#34;Fits the tile elements so they sit inside the tile boundary.
        
        If elements in a tile project outside the boundaries of the tile, this
        method will clip them so that they don&#39;t. This may result in 
        &#39;fragmented&#39; elements, i.e. elements that would form a single element
        after tiling which are separated into distinct fragments.

        Args:
            centre_element (int, optional): the index position of the central 
                element. Defaults to `0`.
        &#34;&#34;&#34;
        dxy = self.elements.geometry[centre_element].centroid
        self.elements.geometry = self.elements.translate(-dxy.x, -dxy.y)
        # use r = 2 because rectangular tiles may need diagonal neighbours
        patch = (self.get_local_patch(r = 2, include_0 = True)
                 if self.tile_shape in (TileShape.RECTANGLE, )
                 else self.get_local_patch(r = 1, include_0 = True))
        self.elements = patch.clip(self.tile)
        # repair any weirdness...
        self.elements.geometry = tiling_utils.clean_polygon(
            self.elements.geometry)
        self.elements = self.elements[self.elements.geometry.area &gt; 0]
        self.regularised_tile = copy.deepcopy(self.tile)
        return None
    

    # applicable to both TileUnits and WeaveUnits
    def inset_elements(self, inset:float = 0) -&gt; &#34;Tileable&#34;:
        &#34;&#34;&#34;Returns a new Tileable with an inset applied around the edges of the 
        tiling elements.

        Works by applying a negative buffer of specfied size to all elements.
        Elements that collapse to zero area are removed and the element_id
        attribute updated accordingly.

        NOTE: this method is likely to not preserve the relative area of 
        elements.

        Args:
            inset (float, optional): The distance to inset. Defaults to `0`.
        
        Returns:
            &#34;Tileable&#34;: the new inset Tileable.
        &#34;&#34;&#34;
        inset_elements, inset_ids = [], []
        for p, id in zip(self.elements.geometry, self.elements.element_id):
            b = p.buffer(-inset, resolution = 1, join_style = 2)
            if not b.area &lt;= 0:
                inset_elements.append(b)
                inset_ids.append(id)
        result = copy.deepcopy(self)
        result.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: inset_ids}, crs = self.crs,
            geometry = gpd.GeoSeries(inset_elements))
        return result
    

    def plot(self, ax = None, show_tile:bool = True, show_reg_tile:bool = True, 
             show_ids = True, show_vectors:bool = False, r:int = 0,
             tile_edgecolor:str = &#34;k&#34;, reg_tile_edgcolor:str = &#34;r&#34;, 
             cmap:list[str] = None, figsize:tuple[float] = (8, 8), 
             **kwargs) -&gt; None:
        &#34;&#34;&#34;Plots a representation of the Tileable on the supplied axis. **kwargs
        are passed on to matplotlib.plot()

        Args:
            ax (_type_, optional): matplotlib axis to draw to. Defaults to None.
            show_tile (bool, optional): if `True` show the tile outline. 
                Defaults to `True`.
            show_reg_tile (bool, optional): if `True` show the regularised tile 
                outline. Defaults to `True`.
            show_ids (bool, optional): if `True` show the element_ids. 
                Defaults to `True`.
            show_vectors (bool, optional): if `True` show the translation 
                vectors (not the minimal pair, but those used by 
                `get_local_patch()`). Defaults to `False`.
            r (int, optional): passed to `get_local_patch()` to show context if 
                greater than 0. Defaults to `0`.
            tile_edgecolor (str, optional): outline colour for the tile. 
                Defaults to `&#34;k&#34;`.
            reg_tile_edgcolor (str, optional): outline colour for the 
                regularised. Defaults to `&#34;r&#34;`.
            cmap (list[str], optional): colour map to apply to the central 
                tiles. Defaults to `None`.
            figsize (tuple[float], optional): size of the figure. 
                Defaults to `(8, 8)`.
        &#34;&#34;&#34;
        w = self.tile.geometry[0].bounds[2] - self.tile.geometry[0].bounds[0] 
        n_cols = len(set(self.elements.element_id))
        if cmap is None:
            cm = &#34;Dark2&#34; if n_cols &lt;= 8 else &#34;Paired&#34;
        else:
            cm = cmap
        if ax is None:
            ax = self.elements.plot(column = &#34;element_id&#34;, cmap = cm, 
                                    figsize = figsize, **kwargs)
        else:
            self.elements.plot(ax = ax, column = &#34;element_id&#34;, cmap = cm, 
                               figsize = figsize, **kwargs)
        if show_ids:
            for id, tile in zip(self.elements.element_id, 
                                self.elements.geometry):
                ax.annotate(id, (tile.centroid.x, tile.centroid.y),
                            ha = &#34;center&#34;, va = &#34;center&#34;,
                            bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})
        if r &gt; 0:
            self.get_local_patch(r = r).plot(ax = ax, column = &#34;element_id&#34;,
                                             alpha = 0.3, cmap = cm, **kwargs)
        if show_tile:
            self.tile.plot(ax = ax, ec = tile_edgecolor, lw = 0.5,
                           fc = &#34;#00000000&#34;, **kwargs) 
        if show_vectors:  # note that arrows in mpl are dimensioned in plotspace
            for v in self.vectors[:len(self.vectors) // 2]:
                ax.arrow(0, 0, v[0], v[1], color = &#34;k&#34;, width = w * 0.002,
                         head_width = w * 0.05, length_includes_head = True)
        if show_reg_tile:
            self.regularised_tile.plot(ax = ax, ec = reg_tile_edgcolor, 
                                       fc = &#34;#00000000&#34;, lw = 2, **kwargs)


    def _get_legend_elements(self):
        &#34;&#34;&#34;Returns the elements augmented by a rotation column.
        
        This base implementation may be overridden by specific tile unit types.
        In particular see 
        `weavingspace.weave_unit.WeaveUnit._get_legend_elements()`.
        &#34;&#34;&#34;
        elements = copy.deepcopy(self.elements)
        elements[&#34;rotation&#34;] = 0
        return elements</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.tileable.TileShape"><code class="flex name class">
<span>class <span class="ident">TileShape</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The available base tile shapes.</p>
<p>NOTE: the TRIANGLE type does not persist, but should be converted to a
DIAMOND or HEXAGON type during <code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> construction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TileShape(Enum):
    &#34;&#34;&#34;The available base tile shapes.
    
    NOTE: the TRIANGLE type does not persist, but should be converted to a
    DIAMOND or HEXAGON type during `Tileable` construction.
    &#34;&#34;&#34;
    RECTANGLE = &#34;rectangle&#34;
    HEXAGON = &#34;hexagon&#34;
    TRIANGLE = &#34;triangle&#34;
    DIAMOND = &#34;diamond&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tileable.TileShape.DIAMOND"><code class="name">var <span class="ident">DIAMOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.TileShape.HEXAGON"><code class="name">var <span class="ident">HEXAGON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.TileShape.RECTANGLE"><code class="name">var <span class="ident">RECTANGLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.TileShape.TRIANGLE"><code class="name">var <span class="ident">TRIANGLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="weavingspace.tileable.Tileable"><code class="flex name class">
<span>class <span class="ident">Tileable</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent a tileable set of geometries.</p>
<p>Stores any supplied attributes, sets up the tile, its elements,
vectors and regularised tile.</p>
<p>The <code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> constructor should not be called directly, but is
instead accessed from the <code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> or
<code><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code> constructor. These can accept as
arguments any of the arguments below.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the strand geometries with associated
element_id attribute encoding their different colouring.</dd>
<dt><strong><code>tile</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>the tileable polygon (a rectangle, a
hexagon, or a diamond).</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code></dt>
<dd>the tile spacing &ndash; effectively the 'resolution' of
the tiling. Defaults to <code>1000</code>.</dd>
<dt><strong><code>tile_shape</code></strong> :&ensp;<code><a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code></dt>
<dd>the tile shape. Defaults to
<code><a title="weavingspace.tileable.TileShape.RECTANGLE" href="#weavingspace.tileable.TileShape.RECTANGLE">TileShape.RECTANGLE</a></code>.</dd>
<dt><strong><code>vectors</code></strong> :&ensp;<code>list[tuple[float]]</code></dt>
<dd>translation vector symmetries of the
tiling.</dd>
<dt><strong><code>regularised_tile</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>a polygon containing the
elements of this <code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code> &mdash; most
often a union of those polygons.</dd>
<dt><strong><code>crs</code></strong> :&ensp;<code>int</code></dt>
<dd>the coordinate reference system of the tile. Most often
an EPSG code, but any valid geopandas CRS specification is
valid. Defaults to 3857 (i.e. Web Mercator).</dd>
<dt><strong><code>fudge_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>a distance in units of self.crs to be used in
geometry clean ups (for example this buffer distance is applied
before unioning polygons.) Defaults to <code>1e-3</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Tileable:
    &#34;&#34;&#34;Class to represent a tileable set of geometries.
    &#34;&#34;&#34;
    elements:gpd.GeoDataFrame = None
    tile:gpd.GeoDataFrame = None
    spacing:float = 1000.
    tile_shape:TileShape = TileShape.RECTANGLE
    vectors:list[tuple[float]] = None
    regularised_tile:gpd.GeoDataFrame = None
    crs:int = 3857
    fudge_factor:float = 1e-3
    
    def __init__(self, **kwargs):
        &#34;&#34;&#34;Stores any supplied attributes, sets up the tile, its elements, 
        vectors and regularised tile.
        
        The `Tileable` constructor should not be called directly, but is 
        instead accessed from the `weavingspace.tile_unit.TileUnit` or 
        `weavingspace.weave_unit.WeaveUnit` constructor. These can accept as
        arguments any of the arguments below.
        
        Args:
            elements (gpd.GeoDataFrame): the strand geometries with associated
                element_id attribute encoding their different colouring.
            tile (gpd.GeoDataFrame): the tileable polygon (a rectangle, a
                hexagon, or a diamond).
            spacing (float): the tile spacing -- effectively the &#39;resolution&#39; of
                the tiling. Defaults to `1000`.
            tile_shape (TileShape): the tile shape. Defaults to 
                `TileShape.RECTANGLE`.
            vectors (list[tuple[float]]): translation vector symmetries of the 
                tiling.
            regularised_tile (gpd.GeoDataFrame): a polygon containing the 
                elements of this `weavingspace.tileable.Tileable` --- most 
                often a union of those polygons.
            crs (int): the coordinate reference system of the tile. Most often 
                an EPSG code, but any valid geopandas CRS specification is
                valid. Defaults to 3857 (i.e. Web Mercator).
            fudge_factor (float): a distance in units of self.crs to be used in
                geometry clean ups (for example this buffer distance is applied
                before unioning polygons.) Defaults to `1e-3`.
        &#34;&#34;&#34;
        for k, v in kwargs.items():
            self.__dict__[k] = v
        self.setup_tile_and_elements()
        self.setup_vectors()
        if self.regularised_tile is None:
            self.regularise_elements()
        return
        
        
    def setup_vectors(self) -&gt; None:
        &#34;&#34;&#34;Sets up the translation vectors of the tiling.
        &#34;&#34;&#34;
        self.vectors = self.get_vectors()
        return None
    
        
    def get_vectors(self, return_values:bool = True
        ) -&gt; Union[ dict[tuple[int], tuple[float]],list[tuple[float]] ]:
        &#34;&#34;&#34;
        Returns symmetry translation vectors as floating point pairs. 
        
        Derived from the size and shape of the tile attribute. These are not the minimal translation vectors, but the &#39;face to face&#39; vectors of the tile, such that a hexagonal tile will have 3 vectors, not the minimal parallelogram pair. Also supplies the inverse vectors.
        
        Optionally returns the vectors in a dictionary indexed by their 
        coordinates, e.g.
        
            {
                ( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
                (-1,  0): (-100, 0), ( 0, -1): (0, -100)
            }
            
        For a tileable of type `TileShape.HEXAGON`, the indexing tuples 
        have three components. See https://www.redblobgames.com/grids/hexagons/ 
        
        Args:
            return_values (bool): If `True` returns the vectors only. If
                `False` returns a dictionary of the vectors indexed by tuples
                in the grid coordinate system. Defaults to `True`.
        
        Returns:
            Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]: 
                either the vectors as a list of float tuples, or a dictionary 
                of those vectors indexed by integer coordinate tuples. 
        &#34;&#34;&#34;
        bb = self.tile.geometry[0].bounds
        w, h = bb[2] - bb[0], bb[3] - bb[1]
        vec_dict = {}
        if self.tile_shape in (TileShape.RECTANGLE, ):
            vec_dict[(1, 0)] = (w, 0)
            vec_dict[(0, 1)] = (0, h)
            vec_dict[(-1, 0)] = (-w, 0)
            vec_dict[(0, -1)] = (0, -h)
        elif self.tile_shape in (TileShape.HEXAGON, ):
            # hex grid coordinates associated with each of the vectors
            i = [0, 1, 1, 0, -1, -1]
            j = [1, 0, -1, -1, 0, 1]
            k = [-1, -1, 0, 1, 1, 0]
            angles = [np.pi * 2 * i / 12 for i in range(1, 12, 2)]
            vecs = [(h * np.cos(a), h * np.sin(a)) for a in angles]
            vec_dict = {(i, j, k): v for i, j, k, v in zip(i, j, k, vecs)}
        else: # DIAMOND
            vec_dict[(1, 0)] = (w / 2, h / 2)
            vec_dict[(0, 1)] = (-w / 2, h / 2)
            vec_dict[(-1, 0)] = (-w / 2, -h / 2)
            vec_dict[(0, -1)] = (w / 2, -h / 2)
        return (list(vec_dict.values())
                if return_values
                else vec_dict)
        
        
    # Make up a regularised tile by carefully unioning the elements
    def setup_regularised_tile_from_elements(self) -&gt; None:
        &#34;&#34;&#34;Sets the regularised tile to a union of the elements.
        &#34;&#34;&#34;
        self.regularised_tile = copy.deepcopy(self.tile)
        self.regularised_tile.geometry = tiling_utils.safe_union(
            self.elements.geometry)
        # This simplification seems very crude but fixes all kinds of issues...
        self.regularised_tile.geometry[0] = \
            self.regularised_tile.geometry[0].simplify(self.spacing / 100)
        return
        
    
    def merge_fragments(
                self, fragments:list[geom.Polygon]) -&gt; list[geom.Polygon]:
        &#34;&#34;&#34;
        Merges a set of polygons based on testing if they touch when subjected 
        to the translation vectors provided by `get_vectors()`. 
        
        Called by `regularise_elements()` to combine elements in a tile that 
        may be fragmented as supplied but will combine when tiled into single 
        elements. This step makes for more efficient implementation of the 
        tiling of map regions.

        Args:
            fragments (list[geom.Polygon]): A set of polygons to merge.

        Returns:
            list[geom.Polygon]: A minimal list of merged polygons.
        &#34;&#34;&#34;
        tile = self.tile.geometry[0]
        reg_tile = self.regularised_tile.geometry[0].buffer(
            self.fudge_factor, resolution = 1, join_style = 2)
        if len(fragments) == 1:
            return fragments
        changes_made = True
        while changes_made:
            changes_made = False
            for v in self.vectors:
                next_frags = []
                t_fragments = [affine.translate(f, v[0], v[1]) 
                               for f in fragments]
                # build a set of any near matching pairs of 
                # fragments and their translated copies
                matches = set()
                for i, f1 in enumerate(fragments):
                    for j, f2, in enumerate(t_fragments):
                        if i != j and tiling_utils.touch_along_an_edge(f1, f2):
                            matches.add((i, j))
                # determine which of these when unioned has the 
                # larger area in common with the base tile
                fragments_to_remove = set()
                for i, j in matches:
                    f1 = fragments[i]
                    f2 = t_fragments[j]
                    u1 = (f1.buffer(self.fudge_factor, 
                                    resolution = 1, join_style = 2) | 
                          f2.buffer(self.fudge_factor, 
                                    resolution = 1, join_style = 2))
                    u2 = affine.translate(u1, -v[0], -v[1])
                    if tile.intersection(u1).area &gt; tile.intersection(u2).area:
                        next_frags.append(u1)
                        reg_tile = (reg_tile | u1) - u2
                    else:
                        next_frags.append(u2)
                        reg_tile = (reg_tile | u2) - u1
                    changes_made = True
                    fragments_to_remove.add(i)
                    fragments_to_remove.add(j)
                fragments = [f for i, f in enumerate(fragments) 
                            if not (i in fragments_to_remove)]
                fragments = next_frags + fragments
        self.regularised_tile.geometry[0] = \
            reg_tile.buffer(-self.fudge_factor, resolution = 1, join_style = 2)
        return fragments


    def regularise_elements(self) -&gt; None:
        &#34;&#34;&#34;Combines separate elements that share an element_id value into 
        single elements, if they would end up touching when tiled. 
        
        Also adjusts the `weavingspace.tileable.Tileable.regularised_tile` 
        attribute accordingly.
        &#34;&#34;&#34;
        self.regularised_tile = copy.deepcopy(self.tile)
        self.regularised_tile.geometry = \
            self.regularised_tile.geometry.buffer(
                self.fudge_factor, resolution = 1, join_style = 2)
        # This preserves order while finding uniques, unlike list(set()).
        # Reordering ids might cause confusion when colour palettes
        # are not assigned explicitly to each id, but in the order
        # encountered in the element_id Series of the GeoDataFrame.
        elements, element_ids = [], []
        ids = list(self.elements.element_id.unique())
        for id in ids:
            fragment_set = list(
                self.elements[self.elements.element_id == id].geometry)
            merge_result = self.merge_fragments(fragment_set)
            elements.extend(merge_result)
            element_ids.extend([id] * len(merge_result))

        self.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: element_ids}, crs = self.crs,
            geometry = gpd.GeoSeries(elements))

        self.regularised_tile.geometry = \
            self.regularised_tile.geometry.explode(index_parts = False,
                                                   ignore_index = True)
        if self.regularised_tile.geometry.shape[0] &gt; 1:
            self.regularised_tile.geometry = \
                tiling_utils.get_largest_polygon(self.regularised_tile.geometry)
        # This simplification seems very crude but fixes all kinds of issues...
        self.regularised_tile.geometry[0] = \
            self.regularised_tile.geometry[0].simplify(self.spacing / 100)
        return None
    
    
    def get_local_patch(
            self, r:int = 1, include_0:bool = False) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;Returns a GeoDataFrame with translated copies of the Tileable.
        
        The geodataframe takes the same form as the `Tileable.tile` attribute.

        Args:
            r (int, optional): the number of translation vector steps required. 
                Defaults to `1`.
            include_0 (bool, optional): If True includes the Tileable itself at 
                (0, 0). Defaults to `False`.

        Returns:
            gpd.GeoDataFrame: A GeoDataframe of the elements extended
                by a number of translation vectors.
        &#34;&#34;&#34;
        # a dictionary of all the vectors we need, starting with (0, 0)
        vecs = ({(0, 0, 0): (0, 0)} 
                if self.tile_shape in (TileShape.HEXAGON, )
                else {(0, 0): (0, 0)})
        # a dictionary of the last &#39;layer&#39; of added vectors
        last_vecs = copy.deepcopy(vecs)
        # get the translation vectors in a dictionary indexed by coordinates
        # we keep track of the sum of vectors using the (integer) coordinates
        # to avoid duplication of moves due to floating point inaccuracies 
        vectors = self.get_vectors(return_values = False)
        for i in range(r):
            new_vecs = {}
            for k1, v1 in last_vecs.items():
                for k2, v2 in vectors.items():
                    # add the coordinates to make a new key...
                    new_key = tuple([k1[i] + k2[i] for i in range(len(k1))])
                    # ... and the vector components to make a new value
                    new_val = (v1[0] + v2[0], v1[1] + v2[1])
                    # if we haven&#39;t reached here before store it
                    if not new_val in vecs: 
                        new_vecs[new_key] = new_val
            # extend the vectors and set the last layer to the set just added
            vecs = vecs | new_vecs
            last_vecs = new_vecs
        if not include_0:  # throw away the identity vector
            vecs.pop((0, 0, 0) if self.tile_shape in (TileShape.HEXAGON, )
                     else (0, 0))
        ids, tiles = [], []
        for v in vecs.values():
            ids.extend(self.elements.element_id)
            tiles.extend(self.elements.geometry.apply(
                affine.translate, xoff = v[0], yoff = v[1]))
        return gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: ids}, crs = self.crs,
            geometry = gpd.GeoSeries(tiles)
        )
    
    
    def fit_elements_to_tile(self, centre_element:int = 0) -&gt; None:
        &#34;&#34;&#34;Fits the tile elements so they sit inside the tile boundary.
        
        If elements in a tile project outside the boundaries of the tile, this
        method will clip them so that they don&#39;t. This may result in 
        &#39;fragmented&#39; elements, i.e. elements that would form a single element
        after tiling which are separated into distinct fragments.

        Args:
            centre_element (int, optional): the index position of the central 
                element. Defaults to `0`.
        &#34;&#34;&#34;
        dxy = self.elements.geometry[centre_element].centroid
        self.elements.geometry = self.elements.translate(-dxy.x, -dxy.y)
        # use r = 2 because rectangular tiles may need diagonal neighbours
        patch = (self.get_local_patch(r = 2, include_0 = True)
                 if self.tile_shape in (TileShape.RECTANGLE, )
                 else self.get_local_patch(r = 1, include_0 = True))
        self.elements = patch.clip(self.tile)
        # repair any weirdness...
        self.elements.geometry = tiling_utils.clean_polygon(
            self.elements.geometry)
        self.elements = self.elements[self.elements.geometry.area &gt; 0]
        self.regularised_tile = copy.deepcopy(self.tile)
        return None
    

    # applicable to both TileUnits and WeaveUnits
    def inset_elements(self, inset:float = 0) -&gt; &#34;Tileable&#34;:
        &#34;&#34;&#34;Returns a new Tileable with an inset applied around the edges of the 
        tiling elements.

        Works by applying a negative buffer of specfied size to all elements.
        Elements that collapse to zero area are removed and the element_id
        attribute updated accordingly.

        NOTE: this method is likely to not preserve the relative area of 
        elements.

        Args:
            inset (float, optional): The distance to inset. Defaults to `0`.
        
        Returns:
            &#34;Tileable&#34;: the new inset Tileable.
        &#34;&#34;&#34;
        inset_elements, inset_ids = [], []
        for p, id in zip(self.elements.geometry, self.elements.element_id):
            b = p.buffer(-inset, resolution = 1, join_style = 2)
            if not b.area &lt;= 0:
                inset_elements.append(b)
                inset_ids.append(id)
        result = copy.deepcopy(self)
        result.elements = gpd.GeoDataFrame(
            data = {&#34;element_id&#34;: inset_ids}, crs = self.crs,
            geometry = gpd.GeoSeries(inset_elements))
        return result
    

    def plot(self, ax = None, show_tile:bool = True, show_reg_tile:bool = True, 
             show_ids = True, show_vectors:bool = False, r:int = 0,
             tile_edgecolor:str = &#34;k&#34;, reg_tile_edgcolor:str = &#34;r&#34;, 
             cmap:list[str] = None, figsize:tuple[float] = (8, 8), 
             **kwargs) -&gt; None:
        &#34;&#34;&#34;Plots a representation of the Tileable on the supplied axis. **kwargs
        are passed on to matplotlib.plot()

        Args:
            ax (_type_, optional): matplotlib axis to draw to. Defaults to None.
            show_tile (bool, optional): if `True` show the tile outline. 
                Defaults to `True`.
            show_reg_tile (bool, optional): if `True` show the regularised tile 
                outline. Defaults to `True`.
            show_ids (bool, optional): if `True` show the element_ids. 
                Defaults to `True`.
            show_vectors (bool, optional): if `True` show the translation 
                vectors (not the minimal pair, but those used by 
                `get_local_patch()`). Defaults to `False`.
            r (int, optional): passed to `get_local_patch()` to show context if 
                greater than 0. Defaults to `0`.
            tile_edgecolor (str, optional): outline colour for the tile. 
                Defaults to `&#34;k&#34;`.
            reg_tile_edgcolor (str, optional): outline colour for the 
                regularised. Defaults to `&#34;r&#34;`.
            cmap (list[str], optional): colour map to apply to the central 
                tiles. Defaults to `None`.
            figsize (tuple[float], optional): size of the figure. 
                Defaults to `(8, 8)`.
        &#34;&#34;&#34;
        w = self.tile.geometry[0].bounds[2] - self.tile.geometry[0].bounds[0] 
        n_cols = len(set(self.elements.element_id))
        if cmap is None:
            cm = &#34;Dark2&#34; if n_cols &lt;= 8 else &#34;Paired&#34;
        else:
            cm = cmap
        if ax is None:
            ax = self.elements.plot(column = &#34;element_id&#34;, cmap = cm, 
                                    figsize = figsize, **kwargs)
        else:
            self.elements.plot(ax = ax, column = &#34;element_id&#34;, cmap = cm, 
                               figsize = figsize, **kwargs)
        if show_ids:
            for id, tile in zip(self.elements.element_id, 
                                self.elements.geometry):
                ax.annotate(id, (tile.centroid.x, tile.centroid.y),
                            ha = &#34;center&#34;, va = &#34;center&#34;,
                            bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})
        if r &gt; 0:
            self.get_local_patch(r = r).plot(ax = ax, column = &#34;element_id&#34;,
                                             alpha = 0.3, cmap = cm, **kwargs)
        if show_tile:
            self.tile.plot(ax = ax, ec = tile_edgecolor, lw = 0.5,
                           fc = &#34;#00000000&#34;, **kwargs) 
        if show_vectors:  # note that arrows in mpl are dimensioned in plotspace
            for v in self.vectors[:len(self.vectors) // 2]:
                ax.arrow(0, 0, v[0], v[1], color = &#34;k&#34;, width = w * 0.002,
                         head_width = w * 0.05, length_includes_head = True)
        if show_reg_tile:
            self.regularised_tile.plot(ax = ax, ec = reg_tile_edgcolor, 
                                       fc = &#34;#00000000&#34;, lw = 2, **kwargs)


    def _get_legend_elements(self):
        &#34;&#34;&#34;Returns the elements augmented by a rotation column.
        
        This base implementation may be overridden by specific tile unit types.
        In particular see 
        `weavingspace.weave_unit.WeaveUnit._get_legend_elements()`.
        &#34;&#34;&#34;
        elements = copy.deepcopy(self.elements)
        elements[&#34;rotation&#34;] = 0
        return elements</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></li>
<li><a title="weavingspace.weave_unit.WeaveUnit" href="weave_unit.html#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.tileable.Tileable.crs"><code class="name">var <span class="ident">crs</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.elements"><code class="name">var <span class="ident">elements</span> :Â geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.fudge_factor"><code class="name">var <span class="ident">fudge_factor</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.regularised_tile"><code class="name">var <span class="ident">regularised_tile</span> :Â geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.spacing"><code class="name">var <span class="ident">spacing</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.tile"><code class="name">var <span class="ident">tile</span> :Â geopandas.geodataframe.GeoDataFrame</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.tile_shape"><code class="name">var <span class="ident">tile_shape</span> :Â <a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tileable.Tileable.vectors"><code class="name">var <span class="ident">vectors</span> :Â list[tuple[float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="weavingspace.tileable.Tileable.fit_elements_to_tile"><code class="name flex">
<span>def <span class="ident">fit_elements_to_tile</span></span>(<span>self, centre_element:Â intÂ =Â 0) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Fits the tile elements so they sit inside the tile boundary.</p>
<p>If elements in a tile project outside the boundaries of the tile, this
method will clip them so that they don't. This may result in
'fragmented' elements, i.e. elements that would form a single element
after tiling which are separated into distinct fragments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>centre_element</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the index position of the central
element. Defaults to <code>0</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_elements_to_tile(self, centre_element:int = 0) -&gt; None:
    &#34;&#34;&#34;Fits the tile elements so they sit inside the tile boundary.
    
    If elements in a tile project outside the boundaries of the tile, this
    method will clip them so that they don&#39;t. This may result in 
    &#39;fragmented&#39; elements, i.e. elements that would form a single element
    after tiling which are separated into distinct fragments.

    Args:
        centre_element (int, optional): the index position of the central 
            element. Defaults to `0`.
    &#34;&#34;&#34;
    dxy = self.elements.geometry[centre_element].centroid
    self.elements.geometry = self.elements.translate(-dxy.x, -dxy.y)
    # use r = 2 because rectangular tiles may need diagonal neighbours
    patch = (self.get_local_patch(r = 2, include_0 = True)
             if self.tile_shape in (TileShape.RECTANGLE, )
             else self.get_local_patch(r = 1, include_0 = True))
    self.elements = patch.clip(self.tile)
    # repair any weirdness...
    self.elements.geometry = tiling_utils.clean_polygon(
        self.elements.geometry)
    self.elements = self.elements[self.elements.geometry.area &gt; 0]
    self.regularised_tile = copy.deepcopy(self.tile)
    return None</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.get_local_patch"><code class="name flex">
<span>def <span class="ident">get_local_patch</span></span>(<span>self, r:Â intÂ =Â 1, include_0:Â boolÂ =Â False) â€‘>Â geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a GeoDataFrame with translated copies of the Tileable.</p>
<p>The geodataframe takes the same form as the <code><a title="weavingspace.tileable.Tileable.tile" href="#weavingspace.tileable.Tileable.tile">Tileable.tile</a></code> attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of translation vector steps required.
Defaults to <code>1</code>.</dd>
<dt><strong><code>include_0</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True includes the Tileable itself at
(0, 0). Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>A GeoDataframe of the elements extended
by a number of translation vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_patch(
        self, r:int = 1, include_0:bool = False) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Returns a GeoDataFrame with translated copies of the Tileable.
    
    The geodataframe takes the same form as the `Tileable.tile` attribute.

    Args:
        r (int, optional): the number of translation vector steps required. 
            Defaults to `1`.
        include_0 (bool, optional): If True includes the Tileable itself at 
            (0, 0). Defaults to `False`.

    Returns:
        gpd.GeoDataFrame: A GeoDataframe of the elements extended
            by a number of translation vectors.
    &#34;&#34;&#34;
    # a dictionary of all the vectors we need, starting with (0, 0)
    vecs = ({(0, 0, 0): (0, 0)} 
            if self.tile_shape in (TileShape.HEXAGON, )
            else {(0, 0): (0, 0)})
    # a dictionary of the last &#39;layer&#39; of added vectors
    last_vecs = copy.deepcopy(vecs)
    # get the translation vectors in a dictionary indexed by coordinates
    # we keep track of the sum of vectors using the (integer) coordinates
    # to avoid duplication of moves due to floating point inaccuracies 
    vectors = self.get_vectors(return_values = False)
    for i in range(r):
        new_vecs = {}
        for k1, v1 in last_vecs.items():
            for k2, v2 in vectors.items():
                # add the coordinates to make a new key...
                new_key = tuple([k1[i] + k2[i] for i in range(len(k1))])
                # ... and the vector components to make a new value
                new_val = (v1[0] + v2[0], v1[1] + v2[1])
                # if we haven&#39;t reached here before store it
                if not new_val in vecs: 
                    new_vecs[new_key] = new_val
        # extend the vectors and set the last layer to the set just added
        vecs = vecs | new_vecs
        last_vecs = new_vecs
    if not include_0:  # throw away the identity vector
        vecs.pop((0, 0, 0) if self.tile_shape in (TileShape.HEXAGON, )
                 else (0, 0))
    ids, tiles = [], []
    for v in vecs.values():
        ids.extend(self.elements.element_id)
        tiles.extend(self.elements.geometry.apply(
            affine.translate, xoff = v[0], yoff = v[1]))
    return gpd.GeoDataFrame(
        data = {&#34;element_id&#34;: ids}, crs = self.crs,
        geometry = gpd.GeoSeries(tiles)
    )</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.get_vectors"><code class="name flex">
<span>def <span class="ident">get_vectors</span></span>(<span>self, return_values:Â boolÂ =Â True) â€‘>Â Union[dict[tuple[int],Â tuple[float]],Â list[tuple[float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns symmetry translation vectors as floating point pairs. </p>
<p>Derived from the size and shape of the tile attribute. These are not the minimal translation vectors, but the 'face to face' vectors of the tile, such that a hexagonal tile will have 3 vectors, not the minimal parallelogram pair. Also supplies the inverse vectors.</p>
<p>Optionally returns the vectors in a dictionary indexed by their
coordinates, e.g.</p>
<pre><code>{
    ( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
    (-1,  0): (-100, 0), ( 0, -1): (0, -100)
}
</code></pre>
<p>For a tileable of type <code><a title="weavingspace.tileable.TileShape.HEXAGON" href="#weavingspace.tileable.TileShape.HEXAGON">TileShape.HEXAGON</a></code>, the indexing tuples
have three components. See <a href="https://www.redblobgames.com/grids/hexagons/">https://www.redblobgames.com/grids/hexagons/</a> </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>return_values</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code> returns the vectors only. If
<code>False</code> returns a dictionary of the vectors indexed by tuples
in the grid coordinate system. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]</code></dt>
<dd>either the vectors as a list of float tuples, or a dictionary
of those vectors indexed by integer coordinate tuples.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vectors(self, return_values:bool = True
    ) -&gt; Union[ dict[tuple[int], tuple[float]],list[tuple[float]] ]:
    &#34;&#34;&#34;
    Returns symmetry translation vectors as floating point pairs. 
    
    Derived from the size and shape of the tile attribute. These are not the minimal translation vectors, but the &#39;face to face&#39; vectors of the tile, such that a hexagonal tile will have 3 vectors, not the minimal parallelogram pair. Also supplies the inverse vectors.
    
    Optionally returns the vectors in a dictionary indexed by their 
    coordinates, e.g.
    
        {
            ( 1,  0): ( 100, 0), ( 0,  1): (0,  100),
            (-1,  0): (-100, 0), ( 0, -1): (0, -100)
        }
        
    For a tileable of type `TileShape.HEXAGON`, the indexing tuples 
    have three components. See https://www.redblobgames.com/grids/hexagons/ 
    
    Args:
        return_values (bool): If `True` returns the vectors only. If
            `False` returns a dictionary of the vectors indexed by tuples
            in the grid coordinate system. Defaults to `True`.
    
    Returns:
        Union[ dict[tuple[int],tuple[float]], list[tuple[float]] ]: 
            either the vectors as a list of float tuples, or a dictionary 
            of those vectors indexed by integer coordinate tuples. 
    &#34;&#34;&#34;
    bb = self.tile.geometry[0].bounds
    w, h = bb[2] - bb[0], bb[3] - bb[1]
    vec_dict = {}
    if self.tile_shape in (TileShape.RECTANGLE, ):
        vec_dict[(1, 0)] = (w, 0)
        vec_dict[(0, 1)] = (0, h)
        vec_dict[(-1, 0)] = (-w, 0)
        vec_dict[(0, -1)] = (0, -h)
    elif self.tile_shape in (TileShape.HEXAGON, ):
        # hex grid coordinates associated with each of the vectors
        i = [0, 1, 1, 0, -1, -1]
        j = [1, 0, -1, -1, 0, 1]
        k = [-1, -1, 0, 1, 1, 0]
        angles = [np.pi * 2 * i / 12 for i in range(1, 12, 2)]
        vecs = [(h * np.cos(a), h * np.sin(a)) for a in angles]
        vec_dict = {(i, j, k): v for i, j, k, v in zip(i, j, k, vecs)}
    else: # DIAMOND
        vec_dict[(1, 0)] = (w / 2, h / 2)
        vec_dict[(0, 1)] = (-w / 2, h / 2)
        vec_dict[(-1, 0)] = (-w / 2, -h / 2)
        vec_dict[(0, -1)] = (w / 2, -h / 2)
    return (list(vec_dict.values())
            if return_values
            else vec_dict)</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.inset_elements"><code class="name flex">
<span>def <span class="ident">inset_elements</span></span>(<span>self, inset:Â floatÂ =Â 0) â€‘>Â <a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new Tileable with an inset applied around the edges of the
tiling elements.</p>
<p>Works by applying a negative buffer of specfied size to all elements.
Elements that collapse to zero area are removed and the element_id
attribute updated accordingly.</p>
<p>NOTE: this method is likely to not preserve the relative area of
elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The distance to inset. Defaults to <code>0</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>"Tileable": the new inset Tileable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inset_elements(self, inset:float = 0) -&gt; &#34;Tileable&#34;:
    &#34;&#34;&#34;Returns a new Tileable with an inset applied around the edges of the 
    tiling elements.

    Works by applying a negative buffer of specfied size to all elements.
    Elements that collapse to zero area are removed and the element_id
    attribute updated accordingly.

    NOTE: this method is likely to not preserve the relative area of 
    elements.

    Args:
        inset (float, optional): The distance to inset. Defaults to `0`.
    
    Returns:
        &#34;Tileable&#34;: the new inset Tileable.
    &#34;&#34;&#34;
    inset_elements, inset_ids = [], []
    for p, id in zip(self.elements.geometry, self.elements.element_id):
        b = p.buffer(-inset, resolution = 1, join_style = 2)
        if not b.area &lt;= 0:
            inset_elements.append(b)
            inset_ids.append(id)
    result = copy.deepcopy(self)
    result.elements = gpd.GeoDataFrame(
        data = {&#34;element_id&#34;: inset_ids}, crs = self.crs,
        geometry = gpd.GeoSeries(inset_elements))
    return result</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.merge_fragments"><code class="name flex">
<span>def <span class="ident">merge_fragments</span></span>(<span>self, fragments:Â list[shapely.geometry.polygon.Polygon]) â€‘>Â list[shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<div class="desc"><p>Merges a set of polygons based on testing if they touch when subjected
to the translation vectors provided by <code>get_vectors()</code>. </p>
<p>Called by <code>regularise_elements()</code> to combine elements in a tile that
may be fragmented as supplied but will combine when tiled into single
elements. This step makes for more efficient implementation of the
tiling of map regions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fragments</code></strong> :&ensp;<code>list[geom.Polygon]</code></dt>
<dd>A set of polygons to merge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[geom.Polygon]</code></dt>
<dd>A minimal list of merged polygons.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_fragments(
            self, fragments:list[geom.Polygon]) -&gt; list[geom.Polygon]:
    &#34;&#34;&#34;
    Merges a set of polygons based on testing if they touch when subjected 
    to the translation vectors provided by `get_vectors()`. 
    
    Called by `regularise_elements()` to combine elements in a tile that 
    may be fragmented as supplied but will combine when tiled into single 
    elements. This step makes for more efficient implementation of the 
    tiling of map regions.

    Args:
        fragments (list[geom.Polygon]): A set of polygons to merge.

    Returns:
        list[geom.Polygon]: A minimal list of merged polygons.
    &#34;&#34;&#34;
    tile = self.tile.geometry[0]
    reg_tile = self.regularised_tile.geometry[0].buffer(
        self.fudge_factor, resolution = 1, join_style = 2)
    if len(fragments) == 1:
        return fragments
    changes_made = True
    while changes_made:
        changes_made = False
        for v in self.vectors:
            next_frags = []
            t_fragments = [affine.translate(f, v[0], v[1]) 
                           for f in fragments]
            # build a set of any near matching pairs of 
            # fragments and their translated copies
            matches = set()
            for i, f1 in enumerate(fragments):
                for j, f2, in enumerate(t_fragments):
                    if i != j and tiling_utils.touch_along_an_edge(f1, f2):
                        matches.add((i, j))
            # determine which of these when unioned has the 
            # larger area in common with the base tile
            fragments_to_remove = set()
            for i, j in matches:
                f1 = fragments[i]
                f2 = t_fragments[j]
                u1 = (f1.buffer(self.fudge_factor, 
                                resolution = 1, join_style = 2) | 
                      f2.buffer(self.fudge_factor, 
                                resolution = 1, join_style = 2))
                u2 = affine.translate(u1, -v[0], -v[1])
                if tile.intersection(u1).area &gt; tile.intersection(u2).area:
                    next_frags.append(u1)
                    reg_tile = (reg_tile | u1) - u2
                else:
                    next_frags.append(u2)
                    reg_tile = (reg_tile | u2) - u1
                changes_made = True
                fragments_to_remove.add(i)
                fragments_to_remove.add(j)
            fragments = [f for i, f in enumerate(fragments) 
                        if not (i in fragments_to_remove)]
            fragments = next_frags + fragments
    self.regularised_tile.geometry[0] = \
        reg_tile.buffer(-self.fudge_factor, resolution = 1, join_style = 2)
    return fragments</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ax=None, show_tile:Â boolÂ =Â True, show_reg_tile:Â boolÂ =Â True, show_ids=True, show_vectors:Â boolÂ =Â False, r:Â intÂ =Â 0, tile_edgecolor:Â strÂ =Â 'k', reg_tile_edgcolor:Â strÂ =Â 'r', cmap:Â list[str]Â =Â None, figsize:Â tuple[float]Â =Â (8, 8), **kwargs) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a representation of the Tileable on the supplied axis. **kwargs
are passed on to matplotlib.plot()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>matplotlib axis to draw to. Defaults to None.</dd>
<dt><strong><code>show_tile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the tile outline.
Defaults to <code>True</code>.</dd>
<dt><strong><code>show_reg_tile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the regularised tile
outline. Defaults to <code>True</code>.</dd>
<dt><strong><code>show_ids</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the element_ids.
Defaults to <code>True</code>.</dd>
<dt><strong><code>show_vectors</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> show the translation
vectors (not the minimal pair, but those used by
<code>get_local_patch()</code>). Defaults to <code>False</code>.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>passed to <code>get_local_patch()</code> to show context if
greater than 0. Defaults to <code>0</code>.</dd>
<dt><strong><code>tile_edgecolor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>outline colour for the tile.
Defaults to <code>"k"</code>.</dd>
<dt><strong><code>reg_tile_edgcolor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>outline colour for the
regularised. Defaults to <code>"r"</code>.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>list[str]</code>, optional</dt>
<dd>colour map to apply to the central
tiles. Defaults to <code>None</code>.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>size of the figure.
Defaults to <code>(8, 8)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, ax = None, show_tile:bool = True, show_reg_tile:bool = True, 
         show_ids = True, show_vectors:bool = False, r:int = 0,
         tile_edgecolor:str = &#34;k&#34;, reg_tile_edgcolor:str = &#34;r&#34;, 
         cmap:list[str] = None, figsize:tuple[float] = (8, 8), 
         **kwargs) -&gt; None:
    &#34;&#34;&#34;Plots a representation of the Tileable on the supplied axis. **kwargs
    are passed on to matplotlib.plot()

    Args:
        ax (_type_, optional): matplotlib axis to draw to. Defaults to None.
        show_tile (bool, optional): if `True` show the tile outline. 
            Defaults to `True`.
        show_reg_tile (bool, optional): if `True` show the regularised tile 
            outline. Defaults to `True`.
        show_ids (bool, optional): if `True` show the element_ids. 
            Defaults to `True`.
        show_vectors (bool, optional): if `True` show the translation 
            vectors (not the minimal pair, but those used by 
            `get_local_patch()`). Defaults to `False`.
        r (int, optional): passed to `get_local_patch()` to show context if 
            greater than 0. Defaults to `0`.
        tile_edgecolor (str, optional): outline colour for the tile. 
            Defaults to `&#34;k&#34;`.
        reg_tile_edgcolor (str, optional): outline colour for the 
            regularised. Defaults to `&#34;r&#34;`.
        cmap (list[str], optional): colour map to apply to the central 
            tiles. Defaults to `None`.
        figsize (tuple[float], optional): size of the figure. 
            Defaults to `(8, 8)`.
    &#34;&#34;&#34;
    w = self.tile.geometry[0].bounds[2] - self.tile.geometry[0].bounds[0] 
    n_cols = len(set(self.elements.element_id))
    if cmap is None:
        cm = &#34;Dark2&#34; if n_cols &lt;= 8 else &#34;Paired&#34;
    else:
        cm = cmap
    if ax is None:
        ax = self.elements.plot(column = &#34;element_id&#34;, cmap = cm, 
                                figsize = figsize, **kwargs)
    else:
        self.elements.plot(ax = ax, column = &#34;element_id&#34;, cmap = cm, 
                           figsize = figsize, **kwargs)
    if show_ids:
        for id, tile in zip(self.elements.element_id, 
                            self.elements.geometry):
            ax.annotate(id, (tile.centroid.x, tile.centroid.y),
                        ha = &#34;center&#34;, va = &#34;center&#34;,
                        bbox = {&#34;lw&#34;: 0, &#34;fc&#34;: &#34;#ffffff40&#34;})
    if r &gt; 0:
        self.get_local_patch(r = r).plot(ax = ax, column = &#34;element_id&#34;,
                                         alpha = 0.3, cmap = cm, **kwargs)
    if show_tile:
        self.tile.plot(ax = ax, ec = tile_edgecolor, lw = 0.5,
                       fc = &#34;#00000000&#34;, **kwargs) 
    if show_vectors:  # note that arrows in mpl are dimensioned in plotspace
        for v in self.vectors[:len(self.vectors) // 2]:
            ax.arrow(0, 0, v[0], v[1], color = &#34;k&#34;, width = w * 0.002,
                     head_width = w * 0.05, length_includes_head = True)
    if show_reg_tile:
        self.regularised_tile.plot(ax = ax, ec = reg_tile_edgcolor, 
                                   fc = &#34;#00000000&#34;, lw = 2, **kwargs)</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.regularise_elements"><code class="name flex">
<span>def <span class="ident">regularise_elements</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Combines separate elements that share an element_id value into
single elements, if they would end up touching when tiled. </p>
<p>Also adjusts the <code><a title="weavingspace.tileable.Tileable.regularised_tile" href="#weavingspace.tileable.Tileable.regularised_tile">Tileable.regularised_tile</a></code>
attribute accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regularise_elements(self) -&gt; None:
    &#34;&#34;&#34;Combines separate elements that share an element_id value into 
    single elements, if they would end up touching when tiled. 
    
    Also adjusts the `weavingspace.tileable.Tileable.regularised_tile` 
    attribute accordingly.
    &#34;&#34;&#34;
    self.regularised_tile = copy.deepcopy(self.tile)
    self.regularised_tile.geometry = \
        self.regularised_tile.geometry.buffer(
            self.fudge_factor, resolution = 1, join_style = 2)
    # This preserves order while finding uniques, unlike list(set()).
    # Reordering ids might cause confusion when colour palettes
    # are not assigned explicitly to each id, but in the order
    # encountered in the element_id Series of the GeoDataFrame.
    elements, element_ids = [], []
    ids = list(self.elements.element_id.unique())
    for id in ids:
        fragment_set = list(
            self.elements[self.elements.element_id == id].geometry)
        merge_result = self.merge_fragments(fragment_set)
        elements.extend(merge_result)
        element_ids.extend([id] * len(merge_result))

    self.elements = gpd.GeoDataFrame(
        data = {&#34;element_id&#34;: element_ids}, crs = self.crs,
        geometry = gpd.GeoSeries(elements))

    self.regularised_tile.geometry = \
        self.regularised_tile.geometry.explode(index_parts = False,
                                               ignore_index = True)
    if self.regularised_tile.geometry.shape[0] &gt; 1:
        self.regularised_tile.geometry = \
            tiling_utils.get_largest_polygon(self.regularised_tile.geometry)
    # This simplification seems very crude but fixes all kinds of issues...
    self.regularised_tile.geometry[0] = \
        self.regularised_tile.geometry[0].simplify(self.spacing / 100)
    return None</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.setup_regularised_tile_from_elements"><code class="name flex">
<span>def <span class="ident">setup_regularised_tile_from_elements</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the regularised tile to a union of the elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_regularised_tile_from_elements(self) -&gt; None:
    &#34;&#34;&#34;Sets the regularised tile to a union of the elements.
    &#34;&#34;&#34;
    self.regularised_tile = copy.deepcopy(self.tile)
    self.regularised_tile.geometry = tiling_utils.safe_union(
        self.elements.geometry)
    # This simplification seems very crude but fixes all kinds of issues...
    self.regularised_tile.geometry[0] = \
        self.regularised_tile.geometry[0].simplify(self.spacing / 100)
    return</code></pre>
</details>
</dd>
<dt id="weavingspace.tileable.Tileable.setup_vectors"><code class="name flex">
<span>def <span class="ident">setup_vectors</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the translation vectors of the tiling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_vectors(self) -&gt; None:
    &#34;&#34;&#34;Sets up the translation vectors of the tiling.
    &#34;&#34;&#34;
    self.vectors = self.get_vectors()
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.tileable.TileShape" href="#weavingspace.tileable.TileShape">TileShape</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tileable.TileShape.DIAMOND" href="#weavingspace.tileable.TileShape.DIAMOND">DIAMOND</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.HEXAGON" href="#weavingspace.tileable.TileShape.HEXAGON">HEXAGON</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.RECTANGLE" href="#weavingspace.tileable.TileShape.RECTANGLE">RECTANGLE</a></code></li>
<li><code><a title="weavingspace.tileable.TileShape.TRIANGLE" href="#weavingspace.tileable.TileShape.TRIANGLE">TRIANGLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weavingspace.tileable.Tileable" href="#weavingspace.tileable.Tileable">Tileable</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.tileable.Tileable.crs" href="#weavingspace.tileable.Tileable.crs">crs</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.elements" href="#weavingspace.tileable.Tileable.elements">elements</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.fit_elements_to_tile" href="#weavingspace.tileable.Tileable.fit_elements_to_tile">fit_elements_to_tile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.fudge_factor" href="#weavingspace.tileable.Tileable.fudge_factor">fudge_factor</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_local_patch" href="#weavingspace.tileable.Tileable.get_local_patch">get_local_patch</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_vectors" href="#weavingspace.tileable.Tileable.get_vectors">get_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.inset_elements" href="#weavingspace.tileable.Tileable.inset_elements">inset_elements</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.merge_fragments" href="#weavingspace.tileable.Tileable.merge_fragments">merge_fragments</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.plot" href="#weavingspace.tileable.Tileable.plot">plot</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularise_elements" href="#weavingspace.tileable.Tileable.regularise_elements">regularise_elements</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularised_tile" href="#weavingspace.tileable.Tileable.regularised_tile">regularised_tile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_regularised_tile_from_elements" href="#weavingspace.tileable.Tileable.setup_regularised_tile_from_elements">setup_regularised_tile_from_elements</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_vectors" href="#weavingspace.tileable.Tileable.setup_vectors">setup_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.spacing" href="#weavingspace.tileable.Tileable.spacing">spacing</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.tile" href="#weavingspace.tileable.Tileable.tile">tile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.tile_shape" href="#weavingspace.tileable.Tileable.tile_shape">tile_shape</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.vectors" href="#weavingspace.tileable.Tileable.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>