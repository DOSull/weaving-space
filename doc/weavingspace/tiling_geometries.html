<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.tiling_geometries API documentation</title>
<meta name="description" content="Functions for setting up a `weavingspace.tile_unit.TileUnit` with various
tile geometries. Some care is required in adding new functions that use
…">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.tiling_geometries</code></h1>
</header>
<section id="section-intro">
<p>Functions for setting up a <code><a title="weavingspace.tile_unit.TileUnit" href="tile_unit.html#weavingspace.tile_unit.TileUnit">TileUnit</a></code> with various
tile geometries. Some care is required in adding new functions that use
exisitng ones to get the sequence of setup operations right. Modify with care!</p>
<p>The available tilings can be viewed on <a href="https://dosull.github.io/weaving-space/tiling-explorer/">this page</a>.</p>
<p>These tilings (and many many more!) are discussed in</p>
<p>Grunbaum B, Shephard G C, 1987 <em>Tilings and Patterns</em> (W. H. Freeman and
Company, New York)</p>
<p>A more accessible introduction is</p>
<p>Kaplan C S, 2002 <em>Computer Graphics and Geometric Ornamental Design</em>, PhD
thesis, University of Washington, Seattle, WA,
<a href="https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf">https://cs.uwaterloo.ca/~csk/other/phd/kaplan_diss_full_print.pdf</a></p>
<p>and a more 'polished' version of that work focused on computer graphics is also
available</p>
<p>Kaplan C S, 2009 <em>Introductory tiling theory for computer graphics</em> (Morgan &amp;
Claypool)</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="weavingspace.tiling_geometries.get_4_parts_of_hexagon"><code class="name flex">
<span>def <span class="ident">get_4_parts_of_hexagon</span></span>(<span>unit: TileUnit) ‑> list[shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_4_parts_of_hexagon(unit: &#34;TileUnit&#34;) -&gt; list[geom.Polygon]:
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(3), 1/np.sqrt(3))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  o_hx = tiling_utils.get_corners(outer_h)
  i_hx = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(o_hx[:-1], o_hx[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      inner_h,
      geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o[11], o[0], o[2], o[3]]),
      geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o[3], o[4], o[6], o[7]]),
      geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o[7], o[8], o[10], o[11]])
    ]
  else:
    return [
      inner_h,
      geom.Polygon([i_hx[2], i_hx[1], i_hx[0], o_hx[0], o_hx[1], o_hx[2]]),
      geom.Polygon([i_hx[4], i_hx[3], i_hx[2], o_hx[2], o_hx[3], o_hx[4]]),
      geom.Polygon([i_hx[0], i_hx[5], i_hx[4], o_hx[4], o_hx[5], o_hx[0]])
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_geometries.get_7_parts_of_hexagon"><code class="name flex">
<span>def <span class="ident">get_7_parts_of_hexagon</span></span>(<span>unit: TileUnit) ‑> list[shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_7_parts_of_hexagon(unit: &#34;TileUnit&#34;) -&gt; list[geom.Polygon]:
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(7), 1/np.sqrt(7))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  outer = tiling_utils.get_corners(outer_h)
  inner = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(outer[:-1], outer[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    i = []
    for p1, p2 in zip(inner[:-1], inner[1:]):
      i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      inner_h,
      geom.Polygon([i[2], i[0], o[11], o[0], o[1]]),
      geom.Polygon([i[4], i[2]] + o[1:4]),
      geom.Polygon([i[6], i[4]] + o[3:6]),
      geom.Polygon([i[8], i[6]] + o[5:8]),
      geom.Polygon([i[10], i[8]] + o[7:10]),
      geom.Polygon([i[0], i[10]] + o[9:])
    ]
  else:
    return [
      inner_h,
      geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
      geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
      geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
      geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
      geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
      geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_geometries.get_9_parts_of_hexagon"><code class="name flex">
<span>def <span class="ident">get_9_parts_of_hexagon</span></span>(<span>unit: TileUnit) ‑> list[shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_9_parts_of_hexagon(unit: &#34;TileUnit&#34;) -&gt; list[geom.Polygon]:
  c = geom.Point(0, 0)
  outer_h = tiling_utils.get_regular_polygon(unit.spacing, 6)
  inner_h = affine.scale(outer_h, 1/np.sqrt(3), 1/np.sqrt(3))
  if unit.offset == 1:
    inner_h = affine.rotate(inner_h, 30, (0, 0))
  outer = tiling_utils.get_corners(outer_h)
  inner = tiling_utils.get_corners(inner_h)
  if unit.offset == 1:
    o = []
    for p1, p2 in zip(outer[:-1], outer[1:]):
      o.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    i = []
    for p1, p2 in zip(inner[:-1], inner[1:]):
      i.extend([p1, geom.Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2])])
    return [
      geom.Polygon([c, i[1], i[2], i[4], i[5]]),
      geom.Polygon([c, i[5], i[6], i[8], i[9]]),
      geom.Polygon([c, i[9], i[10], i[0], i[1]]),
      geom.Polygon([o[0], o[1], i[2], i[0], o[11]]),
      geom.Polygon([o[2], o[3], i[4], i[2], o[1]]),
      geom.Polygon([o[4], o[5], i[6], i[4], o[3]]),
      geom.Polygon([o[6], o[7], i[8], i[6], o[5]]),
      geom.Polygon([o[8], o[9], i[10], i[8], o[7]]),
      geom.Polygon([o[10], o[11], i[0], i[10], o[9]])
    ]
  else:
    return [
      geom.Polygon([c, inner[0], inner[1], inner[2]]),
      geom.Polygon([c, inner[2], inner[3], inner[4]]),
      geom.Polygon([c, inner[4], inner[5], inner[0]]),
      geom.Polygon([inner[1], inner[0], outer[0], outer[1]]),
      geom.Polygon([inner[2], inner[1], outer[1], outer[2]]),
      geom.Polygon([inner[3], inner[2], outer[2], outer[3]]),
      geom.Polygon([inner[4], inner[3], outer[3], outer[4]]),
      geom.Polygon([inner[5], inner[4], outer[4], outer[5]]),
      geom.Polygon([inner[0], inner[5], outer[5], outer[0]])
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_archimedean"><code class="name flex">
<span>def <span class="ident">setup_archimedean</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_archimedean(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;The Archimedean &#39;regular tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane

  Many of these are most easily constructed as duals of the Laves tilings.

  Some are not yet implemented:

  (3.3.3.4.4) is kind of weird (stripes of triangles and squares) so can&#39;t be
  bothered with it. Perhaps as a 5-variable option we&#39;ll get to it in time.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  if unit.code == &#34;3.3.3.3.3.3&#34;:
    _setup_base_tile(unit, TileShape.TRIANGLE)
    _setup_none_tile(unit)
    return
  if unit.code == &#34;3.3.3.3.6&#34;:
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;3.3.3.4.4&#34;:
    print(f&#34;The code [{unit.code}] is unsupported.&#34;)
  elif unit.code == &#34;3.3.4.3.4&#34;:
    # this is an attractive 6-colourable triangles and squares tiling
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;3.4.6.4&#34;:
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;3.6.3.6&#34;:
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;3.12.12&#34;:
    # nice! we can make dodecagons without having to think too hard
    # simply use the dual code. (Although really... it probably
    # would&#39;ve been easier to make the dodecagon... other than
    # calculating the scale relative to the hexagon base tile!)
    setup_laves(unit)
    unit.setup_vectors()
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;4.4.4.4&#34;:
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return
  elif unit.code == &#34;4.6.12&#34;:
    # more dodecagons for free!
    setup_laves(unit)
    unit.setup_vectors()
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;4.8.8&#34;:
    # this is the octagon and square tiling
    setup_laves(unit)
    unit.tiles = tiling_utils.get_dual_tile_unit(unit)
    unit.setup_regularised_prototile_from_tiles()
    return
  elif unit.code == &#34;6.6.6&#34;:
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return
  else:
    print(f&#34;[{unit.code}] is not a valid Laves code.&#34;)

  unit.tiling_type = None
  _setup_none_tile(unit)
  return</code></pre>
</details>
<div class="desc"><p>The Archimedean 'regular tilings. See <a href="https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane">https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Convex_uniform_tilings_of_the_Euclidean_plane</a></p>
<p>Many of these are most easily constructed as duals of the Laves tilings.</p>
<p>Some are not yet implemented:</p>
<p>(3.3.3.4.4) is kind of weird (stripes of triangles and squares) so can't be
bothered with it. Perhaps as a 5-variable option we'll get to it in time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_cairo"><code class="name flex">
<span>def <span class="ident">setup_cairo</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_cairo(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.
  This code shows how a &#39;handcoded&#39; set of geometries can be applied.

  Note that it is advisable to avoid intersection and union operations where
  possible, as it often yields floating point mismatches that can be hard
  to repair! (This tiling can be relatively conveniently generated by
  dissecting a square in 4 quarters at a 30 degree angle to the sides and
  then reflecting and rotating copies and joing them back together. But
  floating point issues make that very messy indeed. Much better to make
  the geometries &#39;pure&#39;.)

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  _setup_base_tile(unit, TileShape.RECTANGLE)  # a square
  d = unit.spacing
  x = d / 2 / (np.cos(np.radians(15)) + np.cos(np.radians(75)))
  # the following is just the geometry, it is what it is...
  # points are (more or less)
  #
  #         3
  #     2
  #            4
  #     1    0
  #
  # then rotate -15 and make 4 copies at 90 degree rotations
  p1 = geom.Polygon([(x, 0), (0, 0), (0, x),
             (x * np.sqrt(3) / 2, x + x / 2),
             (x * (1 + np.sqrt(3)) / 2, x * (3 - np.sqrt(3)) / 2)])
  p1 = affine.rotate(p1, -15, (0, 0))
  p2 = affine.rotate(p1, 90, (0, 0))
  p3 = affine.rotate(p1, 180, (0, 0))
  p4 = affine.rotate(p1, 270, (0, 0))

  # now move them so they are arranged as a hexagon centered on the tile
  p1 = affine.translate(p1, -unit.spacing / 2, 0)
  p2 = affine.translate(p2, unit.spacing / 2, 0)
  p3 = affine.translate(p3, unit.spacing / 2, 0)
  p4 = affine.translate(p4, -unit.spacing / 2, 0)

  unit.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: list(&#34;abcd&#34;)}, crs = unit.crs,
    geometry = gpd.GeoSeries([p1, p2, p3, p4]))
  unit.setup_regularised_prototile_from_tiles()</code></pre>
</details>
<div class="desc"><p>Sets up the Cairo tiling. King of tilings. All hail the Cairo tiling.
This code shows how a 'handcoded' set of geometries can be applied.</p>
<p>Note that it is advisable to avoid intersection and union operations where
possible, as it often yields floating point mismatches that can be hard
to repair! (This tiling can be relatively conveniently generated by
dissecting a square in 4 quarters at a 30 degree angle to the sides and
then reflecting and rotating copies and joing them back together. But
floating point issues make that very messy indeed. Much better to make
the geometries 'pure'.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_hex_colouring"><code class="name flex">
<span>def <span class="ident">setup_hex_colouring</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_hex_colouring(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;3, 4, and 7 colourings of a regular array of hexagons.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  hexagon = tiling_utils.get_regular_polygon(unit.spacing / np.sqrt(unit.n), 6)
  if unit.n == 3:
    # Point up hex at &#39;*&#39; displaced to 3 positions:
    #      2
    #      *
    #    3   1
    _setup_base_tile(unit, TileShape.HEXAGON)
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    # Copy and translate to alternate corners
    corners = [p for i, p in enumerate(hexagon.exterior.coords)
           if i in (0, 2, 4)]
    hexes = [affine.translate(hexagon, p[0], p[1]) for p in corners]
  elif unit.n == 4:
    # Point up hex at &#39;*&#39; displaced to 4 positions:
    #      2
    #     3*1
    #      4
    _setup_base_tile(unit, TileShape.DIAMOND)
    hexagon = affine.rotate(hexagon, 30, origin = (0, 0))
    hex1 = affine.translate(hexagon, unit.spacing / 4, 0)
    hex2 = affine.translate(hexagon, 0, unit.spacing * np.sqrt(3) / 4)
    hex3 = affine.translate(hexagon, -unit.spacing / 4, 0)
    hex4 = affine.translate(hexagon, 0, -unit.spacing * np.sqrt(3) / 4)
    hexes = [hex1, hex2, hex3, hex4]
  elif unit.n == 7:  # the &#39;H3&#39; tile
    # Make a hexagon and displace in the direction of its
    # own 6 corners, scaled as needed
    _setup_base_tile(unit, TileShape.HEXAGON)
    rotation = np.degrees(np.arctan(1 / 3 / np.sqrt(3)))
    corners = [p for p in hexagon.exterior.coords][:-1]
    hexagon = affine.rotate(hexagon, 30)
    hexes = [hexagon] + [affine.translate(
      hexagon, x * np.sqrt(3), y * np.sqrt(3)) for x, y in corners]
    hexes = [affine.rotate(h, rotation, origin = (0, 0))
             for h in hexes]
  else:
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return

  unit.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(hexes))
  unit.setup_regularised_prototile_from_tiles()</code></pre>
</details>
<div class="desc"><p>3, 4, and 7 colourings of a regular array of hexagons.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_hex_dissection"><code class="name flex">
<span>def <span class="ident">setup_hex_dissection</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_hex_dissection(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;Tilings from dissection of a hexagon into parts.

  The supplied unit should have offset and n set.

  self.offset == 1 starts at midpoints, 0 at hexagon corners
  self.n is the number of slices and should be 2, 3, 4, 6 or 12.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  _setup_base_tile(unit, TileShape.HEXAGON)
  if unit.n == 4:
    parts = get_4_parts_of_hexagon(unit)
  elif unit.n == 7:
    parts = get_7_parts_of_hexagon(unit)
  elif unit.n == 9:
    parts = get_9_parts_of_hexagon(unit)
  unit.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(parts))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)</code></pre>
</details>
<div class="desc"><p>Tilings from dissection of a hexagon into parts.</p>
<p>The supplied unit should have offset and n set.</p>
<p>self.offset == 1 starts at midpoints, 0 at hexagon corners
self.n is the number of slices and should be 2, 3, 4, 6 or 12.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_hex_slice"><code class="name flex">
<span>def <span class="ident">setup_hex_slice</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_hex_slice(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;Tilings from radial slices of a hexagon into 2, 3, 4, 6 or 12 slices.

  The supplied unit should have offset and n set.

  self.offset == 1 starts at midpoints, 0 at hexagon corners
  self.n is the number of slices and should be 2, 3, 4, 6 or 12.

  Again, construction avoids intersection operations where possible.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  _setup_base_tile(unit, TileShape.HEXAGON)
  hexagon = tiling_utils.get_regular_polygon(unit.spacing, 6)
  # note that shapely coords includes the first point at beginning
  # and end - very convenient!
  v = list(hexagon.exterior.coords)
  # midpoints
  m = [((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)
          for p1, p2 in zip(v[:-1], v[1:])]
  # chain into a list of corner, midpoint, corner, midpoint..., i.e.
  #
  #           6  5  4
  #          7       3
  #         8         2
  #          9       1
  #           10 11 0
  #
  # then depending on number of slices and offset pick out points.
  # Do this explicitly not by rotation to avoid gaps.
  p = list(itertools.chain(*zip(v[:-1], m)))
  if unit.n == 2:
    slices = (
      [geom.Polygon([p[0], p[2], p[4], p[6]]),
       geom.Polygon([p[6], p[8], p[10], p[0]])]
      if unit.offset == 0 else
      [geom.Polygon([p[1], p[2], p[4], p[6], p[7]]),
       geom.Polygon([p[7], p[8], p[10], p[0], p[1]])])
  elif unit.n == 3:
    slices = (
      [geom.Polygon([p[0], p[2], p[4], (0, 0)]),
       geom.Polygon([p[4], p[6], p[8], (0, 0)]),
       geom.Polygon([p[8], p[10], p[0], (0, 0)])]
      if unit.offset == 0 else
      [geom.Polygon([p[1], p[2], p[4], p[5], (0, 0)]),
       geom.Polygon([p[5], p[6], p[8], p[9], (0, 0)]),
       geom.Polygon([p[9], p[10], p[0], p[1], (0, 0)])])
  elif unit.n == 4:
    slices = (
      [geom.Polygon([p[0], p[2], p[3], (0, 0)]),
       geom.Polygon([p[3], p[4], p[6], (0, 0)]),
       geom.Polygon([p[6], p[8], p[9], (0, 0)]),
       geom.Polygon([p[9], p[10], p[0], (0, 0)])]
      if unit.offset == 0 else
      [geom.Polygon([p[1], p[2], p[4], (0, 0)]),
       geom.Polygon([p[4], p[6], p[7], (0, 0)]),
       geom.Polygon([p[7], p[8], p[10], (0, 0)]),
       geom.Polygon([p[10], p[0], p[1], (0, 0)])])
  elif unit.n == 6:
    slices = (
      [geom.Polygon([p[0], p[2], (0, 0)]),
       geom.Polygon([p[2], p[4], (0, 0)]),
       geom.Polygon([p[4], p[6], (0, 0)]),
       geom.Polygon([p[6], p[8], (0, 0)]),
       geom.Polygon([p[8], p[10], (0, 0)]),
       geom.Polygon([p[10], p[0], (0, 0)])]
      if unit.offset == 0 else
      [geom.Polygon([p[1], p[2], p[3], (0, 0)]),
       geom.Polygon([p[3], p[4], p[5], (0, 0)]),
       geom.Polygon([p[5], p[6], p[7], (0, 0)]),
       geom.Polygon([p[7], p[8], p[9], (0, 0)]),
       geom.Polygon([p[9], p[10], p[11], (0, 0)]),
       geom.Polygon([p[11], p[0], p[1], (0, 0)])])
  elif unit.n == 12:
    if unit.offset == 0:
      ids = [i for i in range(12)] + [0]
      slices = [geom.Polygon([p[i], p[j], (0, 0)])
                for i, j in zip(ids[:-1], ids[1:])]
    else:
      x = (np.sin(np.pi/6) - np.sin(np.pi/12)) / 6
      base = [x, 1/6 - x]
      steps = base
      for i in range(1, 6):
        steps = steps + [x + i/6 for x in base]
      steps = [steps[-1] - 1] + steps
      slices = [tiling_utils.get_polygon_sector(hexagon, p1, p2)
                for p1, p2 in zip(steps[:-1], steps[1:])]

  unit.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(slices))
  unit.regularised_prototile = copy.deepcopy(unit.prototile)</code></pre>
</details>
<div class="desc"><p>Tilings from radial slices of a hexagon into 2, 3, 4, 6 or 12 slices.</p>
<p>The supplied unit should have offset and n set.</p>
<p>self.offset == 1 starts at midpoints, 0 at hexagon corners
self.n is the number of slices and should be 2, 3, 4, 6 or 12.</p>
<p>Again, construction avoids intersection operations where possible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_laves"><code class="name flex">
<span>def <span class="ident">setup_laves</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_laves(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;The Laves tilings. See https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.

  These are all isohedral, but mostly not regular polygons. We
  prioritise them over the Archimedean tilings because being
  isohedral all tiles are the same size. Several are hex
  dissections and setup is delegated accordingly.

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  if unit.code == &#34;3.3.3.3.3.3&#34;:
    # this is the regular hexagons
    _setup_base_tile(unit, TileShape.HEXAGON)
    _setup_none_tile(unit)
    return
  if unit.code == &#34;3.3.3.3.6&#34;:
    # this one needs its own code
    _setup_laves_33336(unit)
    return
  elif unit.code == &#34;3.3.3.4.4&#34;:
    print(f&#34;The code [{unit.code}] is unsupported.&#34;)
  elif unit.code == &#34;3.3.4.3.4&#34;:
    # king of tilings!
    setup_cairo(unit)
    return
  elif unit.code == &#34;3.4.6.4&#34;:
    # the hex 6-dissection
    unit.n = 6
    unit.offset = 1
    setup_hex_slice(unit)
    return
  elif unit.code == &#34;3.6.3.6&#34;:
    # hex 3-dissection (also a cube weave!)
    unit.n = 3
    unit.offset = 0
    setup_hex_slice(unit)
    return
  elif unit.code == &#34;3.12.12&#34;:
    # again this one needs its own
    _setup_laves_31212(unit)
    return
  elif unit.code == &#34;4.4.4.4&#34;:
    # square grid
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return
  elif unit.code == &#34;4.6.12&#34;:
    # hex 12-dissection
    unit.n = 12
    unit.offset = 0
    setup_hex_slice(unit)
    return
  elif unit.code == &#34;4.8.8&#34;:
    # this one needs its own (a 4-dissection of the square)
    # perhaps to be added as a category later...
    _setup_laves_488(unit)
    return
  elif unit.code == &#34;6.6.6&#34;:
    # triangles
    _setup_base_tile(unit, TileShape.TRIANGLE)
    _setup_none_tile(unit)
  else:
    print(f&#34;[{unit.code}] is not a valid Laves code.&#34;)

  unit.tiling_type = None
  _setup_none_tile(unit)
  return</code></pre>
</details>
<div class="desc"><p>The Laves tilings. See <a href="https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.">https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#Laves_tilings.</a></p>
<p>These are all isohedral, but mostly not regular polygons. We
prioritise them over the Archimedean tilings because being
isohedral all tiles are the same size. Several are hex
dissections and setup is delegated accordingly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
<dt id="weavingspace.tiling_geometries.setup_square_colouring"><code class="name flex">
<span>def <span class="ident">setup_square_colouring</span></span>(<span>unit: TileUnit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_square_colouring(unit:&#34;TileUnit&#34;) -&gt; None:
  &#34;&#34;&#34;Colourings of a regular array of squares. Only supports n = 5 at present
  but we need a n=5 option

  Args:
    unit (TileUnit):  the TileUnit to setup.
  &#34;&#34;&#34;
  sq = tiling_utils.get_regular_polygon(unit.spacing, 4)
  if unit.n == 5:
    _setup_base_tile(unit, TileShape.RECTANGLE)

    # Copy and translate square
    tr = [(0, 0), (unit.spacing, 0), (0, unit.spacing),
        (-unit.spacing, 0), (0, -unit.spacing)]
    squares = [affine.translate(sq, v[0], v[1]) for v in tr]
    squares = [affine.scale(sq, 1 / np.sqrt(5), 1 / np.sqrt(5),
                origin = (0, 0)) for sq in squares]
    rotation = np.degrees(np.arctan2(1, 2))
    squares = [affine.rotate(sq, rotation, origin = (0, 0))
           for sq in squares]
  else:
    _setup_base_tile(unit, TileShape.RECTANGLE)
    _setup_none_tile(unit)
    return

  unit.tiles = gpd.GeoDataFrame(
    data = {&#34;tile_id&#34;: list(string.ascii_letters)[:unit.n]},
    crs = unit.crs,
    geometry = gpd.GeoSeries(squares))
  unit.setup_regularised_prototile_from_tiles()</code></pre>
</details>
<div class="desc"><p>Colourings of a regular array of squares. Only supports n = 5 at present
but we need a n=5 option</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>TileUnit</code></dt>
<dd>the TileUnit to setup.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="weavingspace.tiling_geometries.get_4_parts_of_hexagon" href="#weavingspace.tiling_geometries.get_4_parts_of_hexagon">get_4_parts_of_hexagon</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.get_7_parts_of_hexagon" href="#weavingspace.tiling_geometries.get_7_parts_of_hexagon">get_7_parts_of_hexagon</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.get_9_parts_of_hexagon" href="#weavingspace.tiling_geometries.get_9_parts_of_hexagon">get_9_parts_of_hexagon</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_archimedean" href="#weavingspace.tiling_geometries.setup_archimedean">setup_archimedean</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_cairo" href="#weavingspace.tiling_geometries.setup_cairo">setup_cairo</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_hex_colouring" href="#weavingspace.tiling_geometries.setup_hex_colouring">setup_hex_colouring</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_hex_dissection" href="#weavingspace.tiling_geometries.setup_hex_dissection">setup_hex_dissection</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_hex_slice" href="#weavingspace.tiling_geometries.setup_hex_slice">setup_hex_slice</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_laves" href="#weavingspace.tiling_geometries.setup_laves">setup_laves</a></code></li>
<li><code><a title="weavingspace.tiling_geometries.setup_square_colouring" href="#weavingspace.tiling_geometries.setup_square_colouring">setup_square_colouring</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
