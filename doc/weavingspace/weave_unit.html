<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>weavingspace.weave_unit API documentation</title>
<meta name="description" content="The `WeaveUnit` subclass of `weavingspace.tileable.Tileable` implements
tileable geometric patterns constructed by specifying 2- or 3-axial weaves …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weavingspace.weave_unit</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="weavingspace.weave_unit.WeaveUnit" href="#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code> subclass of <code><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></code> implements
tileable geometric patterns constructed by specifying 2- or 3-axial weaves.</p>
<h2 id="examples">Examples</h2>
<p>Explain usage here&hellip;</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weavingspace.weave_unit.WeaveUnit"><code class="flex name class">
<span>class <span class="ident">WeaveUnit</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class WeaveUnit(Tileable):
  &#34;&#34;&#34;Extends Tileable to allow for tiles that appear like woven patterns.
  &#34;&#34;&#34;

  weave_type:str = &#34;plain&#34;
  &#34;&#34;&#34;type of weave pattern, one of `plain`, `twill`, `basket`, `cube`, `hex` or
  `this`. Defaults to `plain`.&#34;&#34;&#34;
  aspect:float = 1.
  &#34;&#34;&#34;width of strands relative to the `spacing`. Defaults to 1.0.&#34;&#34;&#34;
  n:Union[int, tuple[int]] = (2, 2)
  &#34;&#34;&#34;number of over-under strands in biaxial weaves. Only one item is 
  required in a plain weave. Twill and basket patterns expect an even number of 
  entries in the tuple.&#34;&#34;&#34;
  strands:str = &#34;a|b|c&#34;
  &#34;&#34;&#34;specification of the strand labels along each axis. Defaults to `a|b|c`.&#34;&#34;&#34;
  _tie_up:np.ndarray = None
  &#34;&#34;&#34;optional tie-up array to pass through for `this` weave type.&#34;&#34;&#34;
  _tr:np.ndarray = None
  &#34;&#34;&#34;optional treadling array to pass through for `this` weave type.&#34;&#34;&#34;
  _th:np.ndarray = None
  &#34;&#34;&#34;optional threading array to pass through for `this` weave type.&#34;&#34;&#34;

  def __init__(self, **kwargs):
    super(WeaveUnit, self).__init__(**kwargs)
    self.weave_type = self.weave_type.lower()


  def _setup_tiles(self) -&gt; None:
    &#34;&#34;&#34;Returns dictionary with weave unit and tile GeoDataFrames based on
    parameters already supplied to the constructor.
    &#34;&#34;&#34;
    self._parameter_info()

    if self.weave_type in (&#34;hex&#34;, &#34;cube&#34;):
      self.base_shape = TileShape.HEXAGON
      self._setup_triaxial_weave_unit()
    else:
      self.base_shape = TileShape.RECTANGLE
      self._setup_biaxial_weave_unit()
    return
  
  
  def _setup_regularised_prototile(self) -&gt; None:
    self.regularise_tiles()
    if self.aspect &lt; 1:
      self.reattach_tiles()
    self.regularised_prototile.geometry = tiling_utils.repair_polygon(
      self.regularised_prototile.geometry)
    

  def _parameter_info(self) -&gt; None:
    &#34;&#34;&#34;Outputs logging message concerning the supplied aspect settings.
    &#34;&#34;&#34;
    if self.aspect == 0:
      logging.info(&#34;Setting aspect to 0 is probably not a great plan.&#34;)

    if self.aspect &lt; 0 or self.aspect &gt; 1:
      logging.warning(
        &#34;&#34;&#34;Values of aspect outside the range 0 to 1 won&#39;t produce tiles 
        that will look like weaves, but they might be pretty anyway! Values
        less than -1 seem particularly promising, especially with opacity 
        set less than 1.&#34;&#34;&#34;)

    return None


  def _setup_biaxial_weave_unit(self) -&gt; None:
    &#34;&#34;&#34;Returns weave tiles GeoDataFrame and tile GeoDataFrame in a 
    dictionary based on paramters already supplied to constructor.
    &#34;&#34;&#34;
    warp_threads, weft_threads, _ = \
      tiling_utils.get_strand_ids(self.strands)

    if self.weave_type == &#34;basket&#34; and isinstance(self.n, (list, tuple)):
      self.n = self.n[0]

    p = weave_matrices.get_weave_pattern_matrix(
      weave_type = self.weave_type, n = self.n, warp = warp_threads,
      weft = weft_threads, tie_up = self._tie_up, tr = self._tr,
      th = self._th)

    self._make_shapes_from_coded_weave_matrix(
      Loom(p), strand_labels = [weft_threads, warp_threads, []])


  def _get_triaxial_weave_matrices(self,
    strands_1:Union[list[str],tuple[str]] = [&#34;a&#34;],
    strands_2:Union[list[str],tuple[str]] = [&#34;b&#34;],
    strands_3:Union[list[str],tuple[str]] = [&#34;c&#34;]) -&gt; Loom:
    &#34;&#34;&#34;Returns encoded weave pattern matrix as Loom of three biaxial matrices.

    Allowed weave_types: &#34;cube&#34; or &#34;hex&#34;.

    &#34;hex&#34; is not flexible and will fail with any strand label lists that are 
    not length 3 or include more than one non-blank &#34;-&#34; item. You can 
    generate the &#34;hex&#34; weave with the default settings in any case!

    Strand lists should be length 3 or length 1. &#34;cube&#34; tolerates more 
    than &#34;hex&#34; for the items in the strand lists.

    Defaults will produce &#39;mad weave&#39;.

    Args:
      strands_1 (Union[list[str],tuple[str]], optional): list of labels
      for warp strands. Defaults to [&#34;a&#34;].
      strands_2 (Union[list[str],tuple[str]], optional): list of labels
      for weft strands. Defaults to [&#34;b&#34;].
      strands_3 (Union[list[str],tuple[str]], optional): list of labels
      for weft strands. Defaults to [&#34;c&#34;].

    Returns:
      Loom: which combines the three biaxial weaves 12, 23 and 31 implied
      by the strand label lists.
    &#34;&#34;&#34;
    if self.weave_type == &#34;hex&#34;:
      loom = Loom(
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;this&#34;, tie_up = np.ones((6, 6)),
          warp = strands_1, weft = strands_2),
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;this&#34;, tie_up = np.ones((6, 6)),
          warp = strands_2, weft = strands_3),
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;this&#34;, tie_up = np.ones((6, 6)),
          warp = strands_3, weft = strands_1))
    else: # &#34;cube&#34;
      loom = Loom(
      # Note n = (1,2,1,2) is required here to force 6x6 twill
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;twill&#34;, n = (1, 2, 1, 2),
          warp = strands_1, weft = strands_2),
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;twill&#34;, n = (1, 2, 1, 2),
          warp = strands_2, weft = strands_3),
        weave_matrices.get_weave_pattern_matrix(
          weave_type = &#34;twill&#34;, n = (1, 2, 1, 2),
          warp = strands_3, weft = strands_1))
    return loom


  def _setup_triaxial_weave_unit(self) -&gt; None:
    &#34;&#34;&#34;Returns weave tiles GeoDataFrame and tile GeoDataFrame in a
    dictionary based on parameters already supplied to constructor.
    &#34;&#34;&#34;
    strands_1, strands_2, strands_3 = \
      tiling_utils.get_strand_ids(self.strands)

    loom = self._get_triaxial_weave_matrices(
      strands_1 = strands_1, strands_2 = strands_2, strands_3 = strands_3)

    self._make_shapes_from_coded_weave_matrix(
      loom, strand_labels = [strands_1, strands_2, strands_3])


  def _make_shapes_from_coded_weave_matrix(
    self, loom:Loom, strand_labels:list[list[str]] = [[&#34;a&#34;], [&#34;b&#34;], [&#34;c&#34;]]
    ) -&gt; None:
    &#34;&#34;&#34;Returns weave tiles and prototile GeoDataFrames in a dictionary

    Builds the geometries associated with a given weave supplied as
    &#39;loom&#39; containing the coordinates in an appropriate grid (Cartesian or
    triangular) and the orderings of the strands at each coordinate location

    Args:
      loom (Loom): matrix or stack of matrices representing the weave
      pattern.
      strand_labels (list[list[str]], optional): list of lists of labels
      for strands in each direction. Defaults to [[&#34;a&#34;], [&#34;b&#34;], [&#34;c&#34;]]
    &#34;&#34;&#34;
    grid = WeaveGrid(loom.n_axes, loom.orientations, self.spacing)
    # expand the list of strand labels if needed in each direction
    # labels = []
    labels = [thread * int(np.ceil(dim // len(thread)))
              for dim, thread in zip(loom.dimensions, strand_labels)]
    weave_polys = [] 
    strand_ids = [] 
    cells = []
    for k, strand_order in zip(loom.indices, loom.orderings):
      ids = [thread[coord] for coord, thread in zip(k, labels)]
      cells.append(grid.get_grid_cell_at(k))
      if strand_order is None:
        continue  # No strands present
      if strand_order == &#34;NA&#34;:
        continue  # Inconsistency in layer order
      n_slices = [len(id) for id in ids]
      next_polys = grid.get_visible_cell_strands(
        width = self.aspect, coords = k,
        strand_order = strand_order, n_slices = n_slices)
      weave_polys.extend(next_polys)
      next_labels = [list(ids[i]) for i in strand_order]  # list of lists
      next_labels = list(itertools.chain(*next_labels))   # flatten
      strand_ids.extend(next_labels)
    # sometimes empty polygons make it to here, so
    # filter those out along with the associated IDs
    real_polys = [not p.is_empty for p in weave_polys]
    weave_polys = [p for p, b in zip(weave_polys, real_polys) if b]
    strand_ids = [id for id, b in zip(strand_ids, real_polys) if b]
    # note that the tile is important for the biaxial case, which may
    # not be centred on (0, 0)
    tile = tiling_utils.safe_union(gpd.GeoSeries(cells), as_polygon = True)
    shift = (-tile.centroid.x, -tile.centroid.y) if loom.n_axes == 2 else (0, 0)
    tile = grid.get_tile_from_cells(tile)
    self.tiles = self._get_weave_tiles_gdf(weave_polys, strand_ids, shift)
    self.prototile = gpd.GeoDataFrame(geometry = gpd.GeoSeries([
      tiling_utils.get_clean_polygon(tile)]), crs = self.crs)
    # self.setup_vectors()
    return None


  def _get_weave_tiles_gdf(
      self, polys:list[geom.Polygon], strand_ids:list[str], 
      offset:tuple[float]) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Makes a GeoDataFrame from weave tile polygons, labels, etc.

    Args:
      polys (list[Polygon | MultiPolygon]): list of weave tile
        polygons.
      strand_ids (list[str]): list of strand labels.
      offset (tuple[float]): offset to centre the weave tiles on the
        tile.

    Returns:
      geopandas.GeoDataFrame: GeoDataFrame clipped to the tile, with
        margin applied.
    &#34;&#34;&#34;
    weave = gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: strand_ids},
      geometry = gpd.GeoSeries([affine.translate(p, offset[0], offset[1])
                                for p in polys]))
    weave = weave[weave.tile_id != &#34;-&#34;]
    
    # some buffering is required if aspect is 1 to safely dissolve and
    # explode weave unit tiles that meet at corners
    if self.aspect == 1:
      # grow for dissolve
      weave.geometry = weave.geometry.buffer(
        self.spacing * tiling_utils.RESOLUTION, 
        join_style = 2, cap_style = 3)
      weave = weave.dissolve(by = &#34;tile_id&#34;, as_index = False)
      # shrink by more to explode into separate polygons
      weave.geometry = weave.geometry.buffer(
        -2 * self.spacing * tiling_utils.RESOLUTION, 
        join_style = 2, cap_style = 3)
      weave = weave.explode(ignore_index = True)
      weave.geometry = weave.geometry.buffer(
        self.spacing * tiling_utils.RESOLUTION, 
        join_style = 2, cap_style = 3)
    else: # aspect &lt; 1 is fine without buffering
      weave = weave.dissolve(by = &#34;tile_id&#34;, as_index = False)
      weave = weave.explode(ignore_index = True)

    weave.geometry = gpd.GeoSeries(
      [tiling_utils.get_clean_polygon(p) for p in weave.geometry])
    return weave.set_crs(self.crs)


  def _get_axis_from_label(self, label:str = &#34;a&#34;, strands:str = None):
    &#34;&#34;&#34;Determines the axis of a tile_id from the strands spec string.

    Args:
      label (str, optional): the tile_id. Defaults to &#34;a&#34;.
      strands (str, optional): the strand spec. Defaults to the WeaveUnit
      strands attribute.

    Returns:
      _type_: the axis in which the supplied tile is found.
    &#34;&#34;&#34;
    if strands == None:
      strands = self.strands
    index = strands.index(label)
    return strands[:index].count(&#34;|&#34;)


  def _get_legend_tiles(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;Returns tiles suitable for use in a legend representation.

    One tile for each tile_id value will be chosen, close to the
    centre of the prototile extent, and not among the smallest tiles present
    (for example not a short length of strand mostly hidden by other
    strands)

    Returns:
      gpd.GeoDataFrame: the chosen tiles.
    &#34;&#34;&#34;
    angles = ((0, 240, 120)
              if self.weave_type in (&#34;hex&#34;, &#34;cube&#34;)
              else (90, 0))
    tile_ids = pd.Series.unique(self.tiles.tile_id)
    groups = self.tiles.groupby(&#34;tile_id&#34;)
    tiles, rotations = [], []
    for id in tile_ids:
      candidates = groups.get_group(id)
      axis = self._get_axis_from_label(id, self.strands)
      tiles.append(self._get_most_central_large_tile(
      candidates, tiles))
      rotations.append(-angles[axis] + self.rotation)
    return gpd.GeoDataFrame(
      data = {&#34;tile_id&#34;: tile_ids, &#34;rotation&#34;: rotations},
      crs = self.crs,
      geometry = gpd.GeoSeries(tiles))


  def _get_most_central_large_tile(self, tiles:gpd.GeoDataFrame,
          other_tiles:list[geom.Polygon]) -&gt; geom.Polygon:
    &#34;&#34;&#34;Gets a large tile close to the centre of the WeaveUnit.

    Args:
      tiles (gpd.GeoDataFrame): the set of tiles to choose from.

    Returns:
      geom.Polygon: the chosen, large central tile.
    &#34;&#34;&#34;
    areas = [g.area for g in tiles.geometry]
    min_area, max_area = min(areas), max(areas)
    if min_area / max_area &gt; 0.5:
      geoms = list(tiles.geometry)
    else:
      mean_log_a = np.mean(np.log(areas))
      geoms = [g for g, a in zip(tiles.geometry, areas)
              if np.log(a) &gt; mean_log_a]
    if len(other_tiles) == 0 or self.weave_type in (&#34;cube&#34;, &#34;hex&#34;):
      d = [g.centroid.distance(geom.Point(0, 0)) for g in geoms]
    else:
      c = geom.MultiPolygon(other_tiles).centroid
      d = [geom.MultiPolygon([g] + other_tiles).centroid.distance(c)
          for g in geoms]
    return geoms[d.index(min(d))]


  def _get_legend_key_shapes(self, polygon:geom.Polygon,
                             counts:Iterable = [1] * 25, angle:float = 0,
                             radial:bool = False) -&gt; list[geom.Polygon]:
    &#34;&#34;&#34;Returns a list of polygons obtained by slicing the supplied polygon
    across its length into n slices. Orientation of the polygon is
    indicated by the angle.

    The returned list of polygons can be used to form a colour ramp in a
    legend.

    Args:
      polygon (geom.Polygon): the weave strand polygon to slice.
      counts (Iterable, optional): an iterable list of the numbers of
        slices in each category. Defaults to [1] * 25.
      angle (float, optional): orientation of the polygon. Defaults to 0.
      categorical (bool, optional): ignored by WeaveUnit.

    Returns:
      list[geom.Polygon]: a list of polygons.
    &#34;&#34;&#34;
    c = polygon.centroid
    g = affine.rotate(polygon, -angle, origin = c)
    width, height, left, bottom = \
      tiling_utils.get_width_height_left_bottom(gpd.GeoSeries([g]))
    total = sum(counts)
    cuts = list(np.cumsum(counts))
    cuts = [0] + [c / total for c in cuts]
    cuts = [left + c * width for c in cuts]
    # add margin to avoid weird effects intersecting almost parallel lines.
    cuts[0] = cuts[0] - 1
    cuts[-1] = cuts[-1] + 1
    bottom = bottom - 1
    top = bottom + height + 1
    slices = []
    for l, r in zip(cuts[:-1], cuts[1:]):
      slice = geom.Polygon([(l, bottom), (r, bottom), (r, top), (l, top)])
      slices.append(slice.intersection(g))
    return [affine.rotate(s, angle, origin = c) for s in slices]</code></pre>
</details>
<div class="desc"><p>Extends Tileable to allow for tiles that appear like woven patterns.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="weavingspace.weave_unit.WeaveUnit.aspect"><code class="name">var <span class="ident">aspect</span> : float</code></dt>
<dd>
<div class="desc"><p>width of strands relative to the <code>spacing</code>. Defaults to 1.0.</p></div>
</dd>
<dt id="weavingspace.weave_unit.WeaveUnit.n"><code class="name">var <span class="ident">n</span> : int | tuple[int]</code></dt>
<dd>
<div class="desc"><p>number of over-under strands in biaxial weaves. Only one item is
required in a plain weave. Twill and basket patterns expect an even number of
entries in the tuple.</p></div>
</dd>
<dt id="weavingspace.weave_unit.WeaveUnit.strands"><code class="name">var <span class="ident">strands</span> : str</code></dt>
<dd>
<div class="desc"><p>specification of the strand labels along each axis. Defaults to <code>a|b|c</code>.</p></div>
</dd>
<dt id="weavingspace.weave_unit.WeaveUnit.weave_type"><code class="name">var <span class="ident">weave_type</span> : str</code></dt>
<dd>
<div class="desc"><p>type of weave pattern, one of <code>plain</code>, <code>twill</code>, <code>basket</code>, <code>cube</code>, <code>hex</code> or
<code>this</code>. Defaults to <code>plain</code>.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="weavingspace.tileable.Tileable" href="tileable.html#weavingspace.tileable.Tileable">Tileable</a></b></code>:
<ul class="hlist">
<li><code><a title="weavingspace.tileable.Tileable.base_shape" href="tileable.html#weavingspace.tileable.Tileable.base_shape">base_shape</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.crs" href="tileable.html#weavingspace.tileable.Tileable.crs">crs</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.debug" href="tileable.html#weavingspace.tileable.Tileable.debug">debug</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.fit_tiles_to_prototile" href="tileable.html#weavingspace.tileable.Tileable.fit_tiles_to_prototile">fit_tiles_to_prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_local_patch" href="tileable.html#weavingspace.tileable.Tileable.get_local_patch">get_local_patch</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.get_vectors" href="tileable.html#weavingspace.tileable.Tileable.get_vectors">get_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.inset_tiles" href="tileable.html#weavingspace.tileable.Tileable.inset_tiles">inset_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.merge_fragments" href="tileable.html#weavingspace.tileable.Tileable.merge_fragments">merge_fragments</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.plot" href="tileable.html#weavingspace.tileable.Tileable.plot">plot</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.prototile" href="tileable.html#weavingspace.tileable.Tileable.prototile">prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.reattach_tiles" href="tileable.html#weavingspace.tileable.Tileable.reattach_tiles">reattach_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularise_tiles" href="tileable.html#weavingspace.tileable.Tileable.regularise_tiles">regularise_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.regularised_prototile" href="tileable.html#weavingspace.tileable.Tileable.regularised_prototile">regularised_prototile</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.rotation" href="tileable.html#weavingspace.tileable.Tileable.rotation">rotation</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles" href="tileable.html#weavingspace.tileable.Tileable.setup_regularised_prototile_from_tiles">setup_regularised_prototile_from_tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.setup_vectors" href="tileable.html#weavingspace.tileable.Tileable.setup_vectors">setup_vectors</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.spacing" href="tileable.html#weavingspace.tileable.Tileable.spacing">spacing</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.tiles" href="tileable.html#weavingspace.tileable.Tileable.tiles">tiles</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_rotate" href="tileable.html#weavingspace.tileable.Tileable.transform_rotate">transform_rotate</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_scale" href="tileable.html#weavingspace.tileable.Tileable.transform_scale">transform_scale</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.transform_skew" href="tileable.html#weavingspace.tileable.Tileable.transform_skew">transform_skew</a></code></li>
<li><code><a title="weavingspace.tileable.Tileable.vectors" href="tileable.html#weavingspace.tileable.Tileable.vectors">vectors</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weavingspace" href="index.html">weavingspace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weavingspace.weave_unit.WeaveUnit" href="#weavingspace.weave_unit.WeaveUnit">WeaveUnit</a></code></h4>
<ul class="">
<li><code><a title="weavingspace.weave_unit.WeaveUnit.aspect" href="#weavingspace.weave_unit.WeaveUnit.aspect">aspect</a></code></li>
<li><code><a title="weavingspace.weave_unit.WeaveUnit.n" href="#weavingspace.weave_unit.WeaveUnit.n">n</a></code></li>
<li><code><a title="weavingspace.weave_unit.WeaveUnit.strands" href="#weavingspace.weave_unit.WeaveUnit.strands">strands</a></code></li>
<li><code><a title="weavingspace.weave_unit.WeaveUnit.weave_type" href="#weavingspace.weave_unit.WeaveUnit.weave_type">weave_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
